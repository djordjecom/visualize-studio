IT354 - VEB SISTEMI 1

Uvod u React
Lekcija 01

IT354 - VEB SISTEMI 1
Lekcija 01

UVOD U REACT
Uvod u React
Poglavlje 1: Uvod u predmet IT354 Veb sistemi 1
Poglavlje 2: Uvod u React
Poglavlje 3: Šta je React?
Poglavlje 4: Problem koji React rešava
Poglavlje 5: Deklerativni pristup u Reactu
Poglavlje 6: React preduslovi
Poglavlje 7: Pokazne vežbe: Instalacija i prva React aplikacija
Poglavlje 8: Domaći zadatak
Zaključak

Copyright © 2017 – UNIVERZITET METROPOLITAN, Beograd. Sva prava zadržana. Bez prethodne pismene dozvole
od strane Univerziteta METROPOLITAN zabranjena je reprodukcija, transfer, distribucija ili memorisanje nekog
dela ili čitavih sadržaja ovog dokumenta., kopiranjem, snimanjem, elektronskim putem, skeniranjem ili na bilo
koji drugi način.
Copyright © 2017 BELGRADE METROPOLITAN UNIVERSITY. All rights reserved. No part of this publication may
be reproduced, stored in a retrieval system or transmitted in any form or by any means, electronic, mechanical,
photocopying, recording, scanning or otherwise, without the prior written permission of Belgrade Metropolitan
University.

www.metropolitan.ac.rs

Uvod
UVOD
Cilj lekcije, ishodi učenja i kompetencije koje ova lekcija omogućava
studentima
Cilj lekcije:

Cilj lekcije je da upozna studente se React razvojnim okvirom.

Ishodi učenja:
•
•
•
•
•
•
•

Student može da definiše šta su tačno komponente
Student može da efikasno izgradi i koristi komponente
Student može da koristi uobičajene konvencije imenovanja i obrasce koda
Student može da opišete odnos između komponenti i JSX -a
Student može da napiše JSX kod i razume zašto se koristi
Student može da napišete React komponente bez korišćenja JSX koda
Student može da napiše svoje prve React aplikacije

3

Poglavlje 1
Uvod u predmet IT354 Veb sistemi
1
UVOD ZA PREDMET
Cilj uvoda je da objasni studentima šta će raditi na predmetu
Na ovom predmetu izučavaćemo rad sa frontend tehnologijom React. Istražićemo kako React
funkcioniše, kako se koristi za izradu interaktivnih i modernih veb aplikacija, i zašto je jedan
od najpopularnijih alata u industriji.
Tokom ovog predmeta, studenti će imati priliku da se detaljno upoznaju sa osnovnim i
naprednim tehnikama rada u React-u. Cilj predmeta je da osposobi studente za efikasno
kreiranje modernih, interaktivnih korisničkih interfejsa korišćenjem React biblioteke. U okviru
predmeta, biće obrađene sledeće teme:
• Uvod u React – Razumevanje osnovnih koncepata i strukture React aplikacija.
• Moderni JavaScript – Pregled ES6+ sintakse neophodne za rad u React-u.
• Komponente i JSX – Rad sa komponentama, JSX sintaksom, i prenosom podataka pomoću
Props i Children.
• Događaji i stanje u React-u – Upravljanje događajima i stanjima unutar aplikacije.
• Uslovno prikazivanje, liste i efekti – Kako upravljati prikazom komponenti zasnovano na
uslovima i rad sa listama.
• Stilizovanje – Različiti načini stilizovanja komponenti u React-u.
• Reference (Refs) – Rad sa referencama u React-u za pristup DOM elementima.
• Optimizacija – Tehnike optimizacije performansi aplikacije.
• Rad sa globalnim stanjem (Context) – Upravljanje globalnim stanjem aplikacije pomoću
Context API-ja.
• Korisnički (Custom) i Definisani (Built-in) Hook-ovi – Uvod u React hooks i njihovo
prilagođavanje potrebama aplikacije.
• Rutiranje – Korišćenje React Router-a za navigaciju unutar aplikacije.
• Upravljanje podacima preko rutera – Prenos podataka između različitih ruta.
• Testiranje – Pisanje i izvođenje testova za React aplikacije.

4

Poglavlje 2
Uvod u React
UVOD
Sadržaj nastavnog materijala za nivo 2 lekcije
Sadržaj nivoa 2 nastavnog materijala ove lekcije u formi LAMS objekata učenja :
SADRŽAJ: LAMS objekti učenja lekcije 1:
1. Uvod
2. Šta je React?
3. Problem koji React rešava
4. Deklerativni pristup Reactu
5. React preduslovi
6. Pokazne vežbe: Instalacija i prva React aplikacija
7. Domaći zadatak
8. Zaključak
OCENJIVANJE NAUČENOG:
1. Test
2. Domaći zadatak
Obim nastavnog materijala nivoa lekcije: jedan nivo

5

Poglavlje 3
Šta je React?
ŠTA JE REACT ?
Definicija pojma React
React je open-source JavaScript biblioteka koju je razvila kompanija Facebook (sada Meta) za
izgradnju korisničkih interfejsa. Prema zvaničnoj veb stranici, React je namenjen za kreiranje
interaktivnih korisničkih interfejsa, ali šta to tačno znači? Da bi se to shvatilo, važno je
razumeti ulogu JavaScript-a u pretraživačima, jer React se uglavnom koristi na klijentskoj
strani. JavaScript omogućava programerima da dodaju interaktivne elemente na veb sajtove,
omogućavajući reakciju na korisničke akcije i manipulaciju sadržajem stranice nakon njenog
učitavanja. Ovo je ključno za kreiranje dinamičnih i interaktivnih korisničkih interfejsa.

Šta zapravo znači "biblioteka" i kako React pomaže u kreiranju korisničkih interfejsa? Iako
postoji mnogo rasprava o razlikama između biblioteke i okvira, jednostavna definicija
biblioteke je da ona predstavlja skup funkcija koje olakšavaju postizanje određenih rezultata
uz manje pisanja koda i napora. React koristi komponentnu arhitekturu, što znači da je
aplikacija izgrađena od manjih, višekratno upotrebljivih delova (komponenti), što olakšava
održavanje i skaliranje aplikacija. Ove komponente su nezavisne i mogu se lako kombinovati
i ponovo koristiti u različitim delovima aplikacije.

ŠTA JE REACT? #2
Definicija pojma React #2
Pored toga, React koristi deklarativni pristup, što znači da programeri opisuju kako UI treba
da izgleda u određenom stanju, a React se brine o ažuriranju korisničkog interfejsa kako
bi odgovarao tom stanju, bez potrebe da se ručno manipuliše DOM-om. Biblioteke kao što
je React omogućavaju programerima da pišu efikasniji kod i brže implementiraju određene
funkcionalnosti. Time se programeri mogu fokusirati na suštinsku logiku svojih aplikacija,
čime ubrzavaju razvoj i poboljšavaju kvalitet koda, jer ne moraju iznova rešavati već rešene
probleme. React nije ograničen samo na veb stranice; uz pomoć React-a i React Native-a,
mogu se razvijati i mobilne aplikacije za različite platforme. Bez obzira na ciljanu platformu,
kreiranje interaktivnih korisničkih interfejsa samo uz JavaScript može postati vrlo kompleksno
i izazovno, što React značajno pojednostavljuje.

6

Poglavlje 3 Šta je React?

React se generalno smatra slojem prezentacije u jednoj aplikaciji. Aplikacije su obično
podeljene na različite slojeve, kao što su sloj prezentacije, sloj logike i sloj podataka. U ovom
kontekstu, React prvenstveno upravlja slojem pezentacije, što podrazumeva renderovanje i
ažuriranje korisničkog interfejsa na osnovu promena u podacima i stanju aplikacije. React
komponente menjaju ono što korisnik vidi. Sledeći dijagram ilustruje gde se React uklapa u
frontend kod slika 4.1

Slika 3.1 Slojevi u React aplikaciji [Izvor: Autor]

REACT NA VIŠE PLATFORMI
React ima mogućnost da se koristi za bilo koji korisnički interfejs koji
želimo da kreiramo.
React ima mogućnost da se koristi za bilo koji korisnički interfejs koji želimo da kreiramo.
S obzirom da je React biblioteka uz dodatka specijalizovane biblioteke React se može ciljati
različite platforme ne, a ne samo veb aplikacije. Sledeći dijagram daje ideju o tome kako
React može koristiti i druge platforme koje nisu pretraživač slika 4.2. Na slici sleva na desno
React DOM koji se koristi da omogući prikazivanje React-a u pretraživaču, React Native koji
gađa mobilne uređaje, React PDF koji štampa u PDF i React Unity koji se može koristiti u
računarskim igrama.

7

Poglavlje 3 Šta je React?

Slika 3.2 React platforme [Izvor: Autor]

ŠTA JE REACT? #3
Youtube video koji dodatno objašnjava gradivo u lekciju
Ova lekcija sadrži video materijal. Ukoliko želite da pogledate ovaj video morate da
otvorite LAMS lekciju.

8

Poglavlje 4
Problem koji React rešava
PROBLEM SA OBIČNIM JAVASCRIPT-OM #1
Problem koji React i slični alati rešavaju
"Običan JavaScript" je termin koji se često koristi u veb razvoju i odnosi se na "JavaScript
bez ikakvih okvira ili biblioteka". To znači da programer piše sav JavaScript kod samostalno,
bez oslanjanja na bilo koje biblioteke ili okvire koji bi pružali dodatne funkcionalnosti. Kada se
radi sa "običnim JavaScript-om", posebno se ne koriste frontend biblioteke ili okviri kao što su
React ili Angular. Korišćenje čistog JavaScript-a generalno ima prednost u tome što posetioci
veb stranice moraju da preuzmu manje JavaScript koda (pošto su glavni okviri i biblioteke
obično prilično veliki i mogu brzo dodati 50+ kb dodatnog JavaScript koda koji mora biti
preuzet). Nedostatak oslanjanja na čist JavaScript je taj što programer mora da implementira
sve funkcionalnosti od nule, samostalno. Ovo može biti sklono greškama i izuzetno vremenski
zahtevno. Stoga, posebno složeniji korisnički interfejsi i veb sajtovi mogu brzo postati veoma
teški za upravljanje uz običan JavaScript. React pojednostavljuje kreiranje i upravljanje takvim
korisničkim interfejsima prelaskom sa imperativnog na deklarativni pristup.

PROBLEM SA OBIČNIM JAVASCRIPT-OM #2
Problem koji React i slični alati rešavaju #2
Da bi se ovo bolje shvatilo, kao i ideja iza "imperativnih naspram deklarativnih pristupa"
i zašto bi neko možda želeo da koristi React umesto samo običan JavaScript-a, korisno je
napraviti korak unazad i podsetiti se kako JavaScript funkcioniše.
Kod prikazan dole može se prevesti na sledeće, ljudima razumljivije, instrukcije:
1. Pronađi HTML element tipa dugme da bi dobio referencu na prvo dugme na stranici.
2. Napravi konstantu (tj. kontejner za podatke) pod nazivom buttonElement koja će
sadržati tu referencu na dugme.
3. Ponovi korak 1, ali dobavi referencu na prvi element tipa p.
4. Sačuvaj referencu na paragraf u konstanti pod nazivom paragraphElement.
5. Dodaj slušača događaja na buttonElement koji sluša događaje klika i pokreće
funkciju updateTextHandler kad god se takav događaj klika dogodi.
6. Unutar funkcije updateTextHandler, koristi paragraphElement da postavi njegov
textContent na "Tekst je promenjen!".

9

Poglavlje 4 Problem koji React rešava

Primer 1:

const buttonElement = document.querySelector('button');
const paragraphElement = document.querySelector('p');
function updateTextHandler() {
paragraphElement.textContent = 'Text was changed!';
}
buttonElement.addEventListener('click', updateTextHandler);

PROBLEM SA OBIČNIM JAVASCRIPT-OM #3
Problem koji React i slični alati rešavaju #3
Ovo ne bi trebalo da bude iznenađenje, jer tako funkcioniše većina programskih jezika:
definiše se niz koraka koji moraju biti izvršeni redom. To je pristup koji ima puno smisla,
jer redosled izvršavanja koda ne bi trebalo da bude nasumičan ili nepredvidiv. Međutim,
kada se radi sa korisničkim interfejsima, ovaj imperativni pristup nije idealan. Zapravo,
može brzo postati nezgrapan, jer programer mora dodavati mnogo instrukcija koje, iako
ne dodaju veliku vrednost, ne mogu jednostavno biti izostavljene. Potrebno je napisati sve
DOM (Document Object Model) instrukcije koje omogućavaju kodu interakciju sa elementima,
dodaje elemente, manipuliše elementima, itd.

Osnovna poslovna logika (npr. izvođenje i definisanje stvarnog teksta koji treba postaviti
nakon klika) često čini samo mali deo celokupnog koda. Kada se kontrolišu i manipulišu veb
korisnički interfejsi sa JavaScript-om, veliki deo (često većina) koda često se sastoji od DOM
instrukcija, slušaoca događaja, operacija sa HTML elementima i upravljanja stanjima UI-a.

Moderni veb korisnički interfejsi često su prilično složeni, sa puno interaktivnosti koja se
dešava u pozadini. Veb stranica možda treba da sluša unos korisnika u polju za unos, pošalje
te unete podatke na server radi validacije, prikaže poruku povratne informacije o validaciji na
ekranu i prikaže modalni prozor sa greškom ako su uneti podaci netačni.

10

Poglavlje 5
Deklerativni pristup u Reactu
DEKLERATIVNI PRISTUP U REACTU #1
Primer koda koji pokazuje kako izgleda deklerativni kod u Reactu
Na primeru 2 sa desne strane može se videti kako kod napisan u primeru 1 izgleda kad se
napiše u Reactu.

Ovaj kod izgleda potpuno drugačije kao mešavina JavaScript-a i HTML-a. I zaista, React koristi
sintaksnu ekstenziju koja se zove JSX (tj. JavaScript sa ugrađenim XML-om). Za sada je
dovoljno razumeti da će ovaj JSX kod raditi zahvaljujući koraku pred-procesiranja koji je deo
radnog toka izgradnje svakog React projekta.

Predprocesiranje znači da određeni alati, koji su deo React projekata, analiziraju i transformišu
kod pre nego što se on implementira. Ovo omogućava sintaksu koja je samo za razvoj, poput
JSX-a, koja ne bi radila u pregledaču i zbog toga se transformiše u regularni JavaScript pre
nego što se implementira.

import { useState } from 'react';
function App() {
const [outputText, setOutputText] = useState('');
function updateTextHandler() {
setOutputText('Kliknuli ste dugme!');
}
return (
<>
<button onClick={updateTextHandler}>Klikni na tekst!</button>
<p>{outputText}</p>
</>
);
}
export default App;

11

Poglavlje 5 Deklerativni pristup u Reactu

DEKLERATIVNI PRISTUP U REACTU #2
Sa React-om i JSX-om, fokus se stavlja na JavaScript poslovnu logiku i
definisanje željenog HTML izlaza koji treba na kraju da se postigne
Ono što je prikazano u prethodnom primeru je "deklarativni pristup" koji koristi React:
JavaScript logika (npr. funkcije koje treba da se izvrše) se piše i kombinuje sa HTML kodom
koji treba da je pokrene ili na koji utiče. Nema potrebe za pisanjem instrukcija za selektovanje
određenih DOM elemenata ili promenu tekstualnog sadržaja nekih DOM elemenata. Umesto
toga, sa React-om i JSX-om, fokus se stavlja na JavaScript poslovnu logiku i definisanje
željenog HTML izlaza koji treba na kraju da se postigne. Taj izlaz može i obično će sadržati
dinamičke vrednosti koje se izvode unutar glavnog JavaScript koda.
U prethodnom primeru, outputText je stanje kojim upravlja React. U kodu, funkcija
updateTextHandler se pokreće kada se dogodi klik, i vrednost stanja outputText se postavlja
na novu string vrednost (‘Kliknuli ste dugme!‘) uz pomoć funkcije setOutputText. Opšta ideja
je, međutim, da se vrednost stanja menja, a pošto se ona referencira u poslednjem paragrafu
(<p>{outputText}</p>), React ispisuje trenutnu vrednost stanja na tom mestu u stvarnom
DOM-u (i stoga na stvarnoj veb stranici). React će održavati paragraf ažuriranim, i zbog
toga, kad god se outputText promeni, React će ponovo selektovati ovaj paragraf element i
automatski ažurirati njegov textContent.

Ovo je deklarativni pristup na delu. Kao programer, ne mora se brinuti o tehničkim detaljima
(na primer, selektovanju paragrafa, ažuriranju njegovog textContent). Umesto toga, taj posao
se prepušta React-u. Fokusira se samo na željeno krajnje stanje gde je cilj jednostavno
prikazati trenutnu vrednost outputText na određenom mestu (tj. u ovom slučaju u paragrafu)
na stranici. React preuzima na sebe "posao iza scene" kako bi došao do tog rezultata.

NAČIN NA KOJI REACT MENJA DOM
React stvara virtuelnu DOM-sličnu strukturu stabla koja odražava
trenutno stanje korisničkog interfejsa
Kao što je ranije pomenuto, kada se piše React kod, obično se koristi pristup prikazan
iznad: HTML se meša sa JavaScript kodom koristeći JSX sintaksnu ekstenziju. Važno je
napomenuti da JSX kod ne funkcioniše direktno u pregledačima. On mora biti predprocesiran
pre implementacije. JSX kod se mora transformisati u regularni JavaScript kod pre nego
što bude poslat pregledačima. Sledeće poglavlje će detaljnije razmotriti JSX i u šta se on
transformiše. Za sada je dovoljno imati na umu da JSX kod mora biti transformisan.

Ipak, važno je znati da kod u koji će JSX biti transformisan takođe neće sadržati nikakve
DOM instrukcije. Umesto toga, transformisani kod će izvršavati razne pomoćne metode i

12

Poglavlje 5 Deklerativni pristup u Reactu

funkcije koje su ugrađene u React (drugim rečima, one koje pruža React paket koji je potrebno
dodati svakom React projektu). Interno, React stvara virtuelnu DOM-sličnu strukturu stabla
koja odražava trenutno stanje korisničkog interfejsa.

Dakle, React (biblioteka) deli svoju osnovnu logiku na dva glavna paketa: Glavni react paket i
react-dom paket. Glavni react paket je JavaScript biblioteka koja mora biti uvezena u projekat
kako bi se koristile React-ove funkcije (kao što su JSX ili state). Ovaj paket kreira virtuelni
DOM i izvodi trenutno stanje korisničkog interfejsa. Ali, takođe je potreban i react-dom paket
u projektu ako se želi manipulisati DOM-om pomoću React-a.
Paket react-dom, posebno deo react-dom/client, deluje kao "prevodilački most" između React
koda, interno generisanog virtuelnog DOM-a, i pregledača sa njegovim stvarnim DOM-om koji
treba da se ažurira. Upravo react-dom paket proizvodi stvarne DOM instrukcije koje selektuju,
ažuriraju, brišu i kreiraju DOM elemente. Ova podela postoji jer se React može koristiti i
sa drugim ciljanim okruženjima. Veoma popularna i dobro poznata alternativa DOM-u (tj.
pregledaču) bio bi React Native, koji omogućava programerima da grade nativne mobilne
aplikacije uz pomoć React-a. Sa React Native-om, takođe se uključuje react paket u projekat,
ali umesto react-dom, koristi se react-native paket.

APLIKACIJE OD JEDNE STRANICE
Veb stranica koja ne koristi samo React za delove svojih stranica, već
za sve podstranice i za rutiranje, naziva se "Aplikacija od jedne
stranice"
React se može koristiti za pojednostavljenje kreiranja složenih korisničkih interfejsa, i postoje
dva glavna načina za to:
• Upravljanje delovima veb stranice (npr. chat-om u donjem levom uglu).
• Upravljanje celom stranicom i svim korisničkim interakcijama koje se na njoj događaju.
Oba pristupa su izvodljiva, ali češći i popularniji scenario je drugi: korišćenje React-a za
upravljanje celom veb stranicom, umesto samo delovima nje. Ovaj pristup je popularniji jer
većina veb stranica sa složenim korisničkim interfejsima nema samo jedan složeni element,
već više elemenata na svojim stranicama. Složenost bi se zapravo povećala ako bi se React
koristio za neke delove veb stranice, a ne za druge. Iz tog razloga, vrlo je uobičajeno da se
celom veb stranicom upravlja pomoću React-a.

Ovo se ne završava samo na korišćenju React-a na jednoj specifičnoj stranici sajta. Zapravo,
React se može koristiti za rukovanje promenama URL putanja i ažuriranje delova stranice
koji treba da se ažuriraju kako bi se odrazila nova stranica koja treba da se učita. Ova
funkcionalnost se zove "rutiranje" i paketi kao što je react-router-dom, koji se integrišu sa
React-om, omogućavaju kreiranje veb stranice na kojoj je ceo korisnički interfejs kontrolisan
putem React-a.
13

Poglavlje 5 Deklerativni pristup u Reactu

Veb stranica koja ne koristi samo React za delove svojih stranica, već za sve podstranice i za
rutiranje, naziva se "Aplikacija od jedne stranice" ( Single Page Application - SPA) jer se sastoji
od samo jednog HTML fajla (obično nazvanog index.html) koji se koristi za inicijalno učitavanje
React JavaScript koda. Nakon toga, React biblioteka i React kod preuzimaju kontrolu nad
stvarnim korisničkim interfejsom. To znači da se celokupni korisnički interfejs kreira i njime
upravlja JavaScript putem React-a i React koda.

14

Poglavlje 6
React preduslovi
HTML
Pre nego što započnemo rad sa React-om, važno je razumeti osnove
HTML-a.
Pre nego što započnemo rad sa React-om, važno je razumeti osnove HTML-a. HTML
(HyperText Markup Language) je osnova svih web stranica i ključni je alat za strukturu
sadržaja na internetu. React koristi HTML sintaksu unutar JavaScript koda kroz JSX (JavaScript
XML), što znači da dobro poznavanje HTML-a olakšava rad sa React-om.
Na slici 4.1 osnovni kostur svake web stranice. U React aplikacijama, sadržaj unutar <body>
često zamenjuje jedan "root" element (npr. <div id="root">), gde React aplikacija postavlja
svoje komponente.

Slika 6.1 Osnovna struktura HTML stranice [Izvor: Autor]

Razumevanje razlike između blokovskih i inline elemenata je važno za pravljenje pravilno
strukturisanih komponenti u React-u.
Blokovski elementi zauzimaju čitavu širinu svog roditeljskog elementa i kreiraju novi red.
Primeri:
•
•
•
•

<div>
<h1>
<p>
<section>

Inline elementi zauzimaju samo onoliko prostora koliko je potrebno za njihov sadržaj i ne
kreiraju novi red. Primeri:
• <span>
• <a>

15

Poglavlje 6 React preduslovi

• <strong>
• <em>
U React-u ćemo često koristiti blokovske elemente kao omotačke komponente koje sadrže
druge elemente i stilizuju ih. Inline elementi će uglavnom služiti za manje stilizovane delove
teksta.

HTML #2
Pre nego što započnemo rad sa React-om, važno je razumeti osnove
HTML-a. #2
Naslovi
Naslovi (<h1> do <h6>) i paragrafi (<p>) su ključni za strukturiranje teksta.
Ovi elementi su korisni u React-u, jer pomažu u organizaciji sadržaja unutar komponenti. Na
primer, mogu se koristiti da se prikažeu različiti delovi aplikacije na strukturiran način.
Liste
Liste su važne za prikazivanje grupisanih informacija. Postoje dve glavne vrste lista:
• Neuređena lista: koristi <ul> i <li> elemente.
• Uređena lista: koristi <ol> i <li> elemente.

Slika 6.2 Primer za liste [Izvor: Autor]

U React-u, kada se prikazuju nizovi podataka iz stanja ili propova, često se koriste liste. Ključni
koncept u React-u je pridavanje jedinstvenog ključa (key) svakom elementu u listi da bi se
optimizovala ažuriranja. Optimizaciji zbog njene važnosti će biti posvećena jedna cela lekcija.
Linkovi se kreiraju pomoću <a> elementa, što je ključno za navigaciju između stranica.
U React-u se koristi posebna komponenta <Link> iz biblioteke React Router za navigaciju
između različitih ruta u aplikaciji, ali osnovno znanje o <a> elementu je neophodno.
Formulari su važan deo interaktivnih aplikacija. Koriste se za unos podataka pomoću
elemenata kao što su <input>, <textarea>, i <button>.

16

Poglavlje 6 React preduslovi

U React-u se formulari često koriste uz state za kontrolu unosa podataka. Osnovno znanje o
HTML formama je preduslov za rad sa kontrolisanim komponentama u React-u.

Slika 6.3 Formular u HTML [Izvor: Autor]

HTML - OBNAVLJANJE
Za studente koji su zaboravili HTML ovde je dat link ka eksternom
tutorijalu pomoću koga mogu da obnove gradivo
Iz prethodno rečenog jasno je da je bez poznavanja HTML-a nemoguće razumeti React ukoliko
ste zaboravili HTML sa CS105 možete to nadoknaditi tako što ćete odgledati sledeći video
tutorijal. U od ovog trenutka se u daljim lekcijama podrazumeva da HTML znate.
Ova lekcija sadrži video materijal. Ukoliko želite da pogledate ovaj video morate da
otvorite LAMS lekciju.

CSS - SELEKTORI
CSS (Cascading Style Sheets) je jezik koji se koristi za stilizovanje
HTML elemenata na web stranici.
CSS (Cascading Style Sheets) je jezik koji se koristi za stilizovanje HTML elemenata na web
stranici. Pre nego što pređemo na rad sa React-om, važno je razumeti osnove CSS-a, jer je
stilizacija sastavni deo izrade veb aplikacija. Ne kaže se bez razloga internet prezentacija.
U React-u, stilizovanje može biti malo drugačije (uz pomoć stilskih datoteka, CSS modula,
stilizovanih komponenti, itd.), ali osnovni principi CSS-a su uvek primenljivi bez obzira da li
se koristi osnovni CSS ili neka specijalizovana biblioteka. U sledećih nekoliko sekcija ukratko
ćemo se podsetiti najbitnijih CSS svojstava.
Selektori
Selektori su osnovni način na koji ciljamo HTML elemente u CSS-u kako bismo ih stilizovali.
Možemo ciljati:
• element
• id elementa
• klasu elementa

17

Poglavlje 6 React preduslovi

Slika 6.4 Primer CSS selektori [Izvor: Autor]

CSS - BOX MODEL, BOJE, POZADINE, TIPOGRAFIJA
Razumevanje CSS box modela je ključno za kontrolisanje rasporeda
elemenata na stranici.
Razumevanje CSS box modela je ključno za kontrolisanje rasporeda elemenata na stranici.
Box model određuje kako se svaki HTML element "ponaša" u odnosu na prostor koji zauzima.
Box model se sastoji od sledećih delova:
•
•
•
•

Content: Prostor gde se nalazi sadržaj (tekst, slike, itd.).
Padding: Unutrašnji prostor između sadržaja i ivice elementa.
Border: Okvir koji okružuje padding.
Margin: Spoljni prostor između elemenata.

U React-u, poznavanje box modela je važno, jer će se često koristiti padding, margin i border
da bi se definisao izgled komponenti i njihova međusobnu interakciju.
Boje i pozadine:
•
•
•
•

color - postavlja boju slova
background-color - postavlja boju pozadine
background-image - postavlja sliku pozadine
background-size - postavlja veličinu pozadine

18

Poglavlje 6 React preduslovi

Tipografija:
• font-family: ‘Arial‘, sans-serif; - postavlja font
• font-size: 24px; - postavlja veličinu slova
• font-weight: bold; - postavlja debljinu slova

CSS - RASPOREĐIVANJE ELEMENATA
Raspoređivanje elemenata je ključ za kreiranje dobro organizovanih i
responzivnih stranica.
Raspoređivanje elemenata je ključ za kreiranje dobro organizovanih i responzivnih stranica.
Display je svojstvo koje definiše kako će element biti prikazan:
• block: - Element zauzima ceo red.
• inline: - Element zauzima samo onoliko prostora koliko je potrebno.
• flex: - Koristi se za fleksibilno raspoređivanje elemenata unutar kontejnera
Position kontroliše kako je element pozicioniran u odnosu na druge elemente.
• static: - Standardni način pozicioniranja.
• relative: - Element se pomera u odnosu na svoje standardno mesto.
• absolute: - Element se pozicionira u odnosu na najbližeg roditelja sa relative ili absolute
pozicioniranjem.
Flexbox je jedan od najmoćnijih alata u CSS-u za raspoređivanje elemenata unutar
kontejnera. Omogućava jednostavno poravnanje i raspodelu prostora između elemenata.
Osnovna svojstva flexbox-a:
• display: flex: - Aktivira flexbox na kontejneru.
• justify-content: - Poravnava elemente po glavnoj osi (horizontalno).
• align-items: - Poravnava elemente po poprečnoj osi (vertikalno).
U React-u, flexbox je vrlo popularan za raspoređivanje komponenti, jer omogućava dinamičko
prilagođavanje izgleda na različitim uređajima.

CSS - OBNAVLJANJE
Za studente koji su zaboravili CSS ovde je dat link ka eksternom
tutorijalu pomoću koga mogu da obnove gradivo
Iz prethodno rečenog jasno je da je bez poznavanja CSS-a nemoguće razumeti React ukoliko
ste zaboravili CSS sa CS105 možete to nadoknaditi tako što ćete odgledati sledeći video
tutorijal ili ponoviti CS105.

19

Poglavlje 6 React preduslovi

Ova lekcija sadrži video materijal. Ukoliko želite da pogledate ovaj video morate da
otvorite LAMS lekciju.

JAVASCRIPT - OBNAVLJANJE
JavaScript je srž moderne veb tehnologije
JavaScript je srž moderne veb tehnologije, a poznavanje osnovnih JavaScript koncepata
ključno je za razumevanje kako React funkcioniše. Uz to, rad sa DOM-om (Document Object
Model) je ključan deo dinamičkih veb stranica. React koristi virtualni DOM, što olakšava
upravljanje promenama na stranici, ali osnovno razumevanje manipulisanja "pravog" DOMa pomaže da se shvati kako React efikasno upravlja ažuriranjem sadržaja. U ovoj lekciji,
ponovićemo samo ključne JavaScript koncepte sa posebnim osvrtom na to kako radi
manipulacija (menjanje) DOM-a, što je direktan preduslov za rad sa React-om.
U JavaScript-u postoje tri načina za deklarisanje varijabli: var, let i const. U React-u je
preporučeno koristiti let za promenljive vrednosti, dok je const standard za vrednosti koje se
ne menjaju, kao što su funkcije, komponente ili stanja koje ne treba menjati direktno.
Funkcije su temelj za organizaciju koda u JavaScript-u. Postoje različiti načini za definisanje
funkcija
• Funkcija putem dekleracije
• Funkcija putem izraza
• Streličasta (Arrow funkcija)
Primeri su prikazani na slici 4.5

Slika 6.5 Funkcije u Javascriptu [Izvor: Autor]

20

Poglavlje 6 React preduslovi

JAVASCRIPT - OBNAVLJANJE #2
JavaScript je srž moderne veb tehnologije #2
Objekti i nizovi su osnovne strukture podataka u JavaScript-u. U React-u se često koristi state
koji može sadržavati objekte i nizove. Objekti se koriste za skladištenje podataka u formi ključvrednost. Nizovi se koriste za skladištenje više vrednosti slika 4.6

Slika 6.6 Objekat osoba i niz brojevi [Izvor: Autor]

JavaScript petlje omogućavaju prolazak kroz nizove ili objekte. U React-u, ove petlje se koriste
za renderovanje liste elemenata iz niza podataka.
U React-u, map metoda se gotovo uvek koristi kada je potrebno dinamičko renderovanje liste
React komponenti iz niza podataka. Primeri za petlje i map dati su na slici 4.7

Slika 6.7 Primer za for, foreach i map [Izvor: Autor]

JAVASCRIPT - OBNAVLJANJE #3
JavaScript je srž moderne veb tehnologije #3
21

Poglavlje 6 React preduslovi

Da bi manipulacija DOM-a bila moguća, prvo se mora pristupiti željenim elementima na
stranici. Da bi se manipulisalo elementima na stranici, moraju se prvo "dohvatiti" pomoću
Javascript funkcija. Najčešće korišćeni načini selektovanja DOM elemenata su (primer na slici
4.8):
• getElementById: Selektuje element prema njegovom ID-u.
• getElementsByClassName: Selektuje sve elemente koji imaju određenu klasu.
• querySelector i querySelectorAll: Selektuju elemente pomoću CSS selektora.

Slika 6.8 Primer za selektovanje DOM elemenata [Izvor: Autor]

Kada selektujemo element, možemo manipulisati njegovim sadržajem, atributima i stilovima.
textContent i innerHTML se koriste za promenu teksta ili HTML sadržaja unutar elementa slika
4.9.

Slika 6.9 Primer promena sadržaja elementa [Izvor: Autor]

Moguće je direktno menjati stilove elemenata preko style objekta slika 4.10.

Slika 6.10 Primer za izmenu stila selektovanog elementa [Izvor: Autor]

JAVASCRIPT - OBNAVLJANJE #4
JavaScript je srž moderne veb tehnologije #4

22

Poglavlje 6 React preduslovi

Javascript takođe omogućava manipulaciju sa HTML atributima, kao što su src za slike, href
za linkove, ili class za klase elemenata. setAttribute i getAttribute omogućavaju dodavanje,
promenu i čitanje atributa elemenata.
Takođe moguće je i dinamičko dodavanje novih elemenata na stranicu ili uklanjanje postojećih
elemenata. Ove operacije su ključne za dinamičke aplikacije. Funkcija createElement kreira
novi HTML element, a appendChild i removeChild dodaju i uklanjaju elemente iz DOM-a.
Primeri se mogu videti na slici 4.11

Slika 6.11 Manipulacija DOM atributima dodavanje i uklanjanje elemenata [Izvor: Autor]

Reagovanje na događaje kao što su klikovi, unos podataka u formu ili prelasci mišem je
osnovna funkcionalnost veb aplikacija. U Javascript-u, se koriste osluškivači događaja ( Event
Listener) za obradu događaja.

addEventListener - dodaje događaj na element.
removeEventListener - uklanja događaj.

Slika 6.12 Primer za dodavanje i uklanjanje događaja [Izvor: Autor]

React značajno pojednostavljuje sve operacije upravljanja DOM-om. O ovome će više reči biti
u narednim lekcijama.

23

Poglavlje 6 React preduslovi

JAVASCRIPT
Za studente koji su zaboravili osnovni Javascript ovde je dat link ka
eksternom tutorijalu pomoću koga mogu da obnove gradivo
Iz prethodno rečenog jasno je da je bez poznavanja Javascripta-a nemoguće razumeti React
ukoliko ste zaboravili Javascript sa CS105 možete to nadoknaditi tako što ćete odgledati
sledeći video tutorijal ili ponoviti CS105.
Ova lekcija sadrži video materijal. Ukoliko želite da pogledate ovaj video morate da
otvorite LAMS lekciju.

24

Poglavlje 7
Pokazne vežbe: Instalacija i prva
React aplikacija
KREIRANJE REACT PROJEKTA #1
U radu na vežbama studenti prolaze kroz proces instaliranja i
pokretanja prve React aplikacije
Na vežbama Asistent prikazuje proces kreiranja novog React projekta sa Vite-om
Da bi se kreirao projekat sa Vite-om, potrebno je da na sistemu bude instaliran Node.js.
po mogućstvu najnovija (ili najnovija LTS) verzija. Zvanični Node.js instalacijski program za
sve operativne sisteme može se preuzeti sa nodejs.org. Nakon instalacije Node.js-a, korisnik
dobija pristup ugrađenoj npm komandi, koja se može koristiti za kreiranje novog React
projekta pomoću Vite-a. Sledeća komanda može se pokrenuti u komandnoj liniji (Windows),
bash-u (Linux) ili terminalu (macOS). Važno je da se korisnik uveri da je navigirao (cd) u folder
u kojem želi da kreira novi projekat:

npm create vite@latest moja-prva-react-aplikacija

Nakon izvršavanja ove komande, od korisnika će se tražiti da odabere framework ili biblioteku
koju želi da koristi za ovaj novi projekat. Potrebno je odabrati "React" i zatim "JavaScript".
Ova komanda kreira novi podfolder sa osnovnim React projektom (tj. sa različitim fajlovima
i folderima) na mestu gde je pokrenuta. Komanda bi trebalo da se pokrene u putanji na
sistemu gde korisnik ima potpuni pristup čitanju i pisanju i gde ne dolazi u sukob sa bilo kojim
sistemskim ili drugim projektnim fajlovima.

KREIRANJE REACT PROJEKTA #2
U radu na vežbama studenti prolaze kroz proces instaliranja i
pokretanja prve React aplikacije #2
Važno je napomenuti da komanda za kreiranje projekta ne instalira potrebne zavisnosti, kao
što su React biblioteke. Zato je neophodno otići u kreirani folder u terminalu ili komandnoj
liniji (cd moja-prva-react-aplikacija) i instalirati ove pakete pokretanjem sledeće komande:

npm install

25

Poglavlje 7 Pokazne vežbe: Instalacija i prva React aplikacija

Kada se instalacija uspešno završi, proces postavljanja projekta je gotov.
Da bi videli kreiranu React aplikaciju, korisnik može pokrenuti razvojni server na svojoj mašini
pomoću sledeće komande:
npm run dev
Ova komanda pokreće skriptu koju obezbeđuje Vite i koja će aktivirati lokalni veb server.
Taj server predprocesira, izgrađuje i hostuje njegovu React SPA (Single Page Application)
po defaultu na adresi localhost:5173. Dok radi na kodu, obično drži ovaj razvojni server
pokrenutim, jer mu omogućava pregled i testiranje promena u kodu.
Najbolje od svega, ovaj lokalni razvojni server automatski će ažurirati veb stranicu kad god se
sačuvaju promene u kodu, omogućavajući da se gotovo trenutno vide sve promene. Server
se može isključiti kad se završi sa radom pritiskom na CTRL + C u terminalu ili komandnoj
liniji gde se izvr[avaju komande npm run dev.

KREIRANJE REACT PROJEKTA #3
U radu na vežbama studenti prolaze kroz proces instaliranja i
pokretanja prve React aplikacije #3
Ova lekcija sadrži video materijal. Ukoliko želite da pogledate ovaj video morate da
otvorite LAMS lekciju.

POKAZNI PRIMER 1
Isti kod je napisan u Reactu i u čistom Javascriptu
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hello World App</title>
<style>
body, html {
height: 100%;
margin: 0;
display: flex;
justify-content: center;
align-items: center;
background-color: #f0f0f0;
}
#alertButton {
padding: 10px 20px;
font-size: 16px;

26

Poglavlje 7 Pokazne vežbe: Instalacija i prva React aplikacija

cursor: pointer;
}
</style>
</head>
<body>
<div id="app">
<button id="alertButton">Click Me</button>
</div>
<script>
document.getElementById('alertButton').addEventListener('click', function()
{
alert('Hello, World!');
});
</script>
</body>
</html>
import React from 'react';
function App() {
const showAlert = () => {
alert('Hello, World!');
};
return (
<div className="App">
<button onClick={showAlert}>Click Me</button>
</div>
);
}
export default App;

POKAZNI PRIMER 2
Primer 2 Html struktura
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>1. Primer HTML strukture</title>
</head>
<body>
<div id="root">
<h1>Ovo je div root u koji bi React aplikacija bila ubačena </h1>
<p>U React aplikaciji u ovom div-u bi se nalazile React komponente</p>
</div>

27

Poglavlje 7 Pokazne vežbe: Instalacija i prva React aplikacija

</body>
</html>

POKAZNI PRIMER 3
Primer 3 CSS selektori
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>2. CSS Selektori</title>
<style>
/* Element selektor */
p {
color: blue;
}
/* ID selektor */
#header {
background-color: gray;
padding: 10px;
}
/* Klasa selektor */
.button {
padding: 10px;
border-radius: 5px;
background-color: green;
color: white;
display: inline-block;
}
</style>
</head>
<body>
<div id="header">
<h1>Ovo je heder</h1>
</div>
<p>Ovo je paragraf sa plavim tekstom.</p>
<div class="button">Ovo je dugme</div>
</body>
</html>

POKAZNI PRIMER 4
Primer 4 Box model

28

Poglavlje 7 Pokazne vežbe: Instalacija i prva React aplikacija

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3. CSS Box Model primer</title>
<style>
.box {
width: 200px;
height: 100px;
padding: 20px;
border: 2px solid black;
margin: 10px;
background-color: lightblue;
}
</style>
</head>
<body>
<div class="box">
Ovaj div prikazuje kako se koristi CSS box model. Ima sadržaj, padding,
border, and marginu.
</div>
</body>
</html>

POKAZNI PRIMER 5
Primer 5 Box model
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>5. Primer Flexbox</title>
<style>
.container {
display: flex;
justify-content: space-between;
align-items: center;
height: 200px;
background-color: #f0f0f0;
}
.item {
flex: 1;
margin: 10px;
padding: 20px;
background-color: #3498db;
color: white;

29

Poglavlje 7 Pokazne vežbe: Instalacija i prva React aplikacija

text-align: center;
}
</style>
</head>
<body>
<div class="container">
<div class="item">Item 1</div>
<div class="item">Item 2</div>
<div class="item">Item 3</div>
</div>
</body>
</html>

POKAZNI PRIMER 6
Primer 6 JavaScript Objekti i nizovi
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>6. JavaScript Objekti i nizovi</title>
</head>
<body>
<h1>JavaScript Objekti i Nizovi</h1>
<div id="output"></div>
<script>
// Objekat
const person = {
name: "Ana",
age: 30,
city: "Beograd"
};
// Niz
const numbers = [1, 2, 3, 4, 5];
// Korišćenje map metode
const doubledNumbers = numbers.map(num => num * 2);
// Prikaz rezultata
const output = document.getElementById('output');
output.innerHTML = `
<h2>Person Objekat:</h2>
<p>Name: ${person.name}</p>
<p>Age: ${person.age}</p>
<p>City: ${person.city}</p>

30

Poglavlje 7 Pokazne vežbe: Instalacija i prva React aplikacija

<h2>Originalni niz:</h2>
<p>${numbers.join(', ')}</p>
<h2>Duplirani niz:</h2>
<p>${doubledNumbers.join(', ')}</p>
`;
</script>
</body>
</html>

POKAZNI PRIMER 7
Primer 7
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>7. DOM Manipulacija</title>
</head>
<body>
<h1 id="header">Originalni Header</h1>
<button onclick="manipulateDOM()">Manipuliši DOM-om</button>
<script>
function manipulateDOM() {
// Selektovanje elementa
const header = document.getElementById('header');
// Menjanje sadržaja
header.textContent = 'Dobrodošli u React';
// Menjanje stila
header.style.color = 'blue';
// Dodavanje novog elementa
const newParagraph = document.createElement('p');
newParagraph.textContent = 'Ovo je novi paragraf.';
document.body.appendChild(newParagraph);
}
</script>
</body>
</html>

POKAZNI PRIMER 8
Primer 8 Osluškivači događaja (Event Listeners)

31

Poglavlje 7 Pokazne vežbe: Instalacija i prva React aplikacija

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>8. Osluškivači događaja (Event Listeners)</title>
</head>
<body>
<button id="myButton">Klikni me!</button>
<p id="output"></p>
<script>
const button = document.getElementById('myButton');
const output = document.getElementById('output');
function handleClick() {
output.textContent = 'Dugme je kliknuto!';
}
button.addEventListener('click', handleClick);
</script>
</body>
</html>

POKAZNI PRIMER 9
Primer 9 ES6 Destrukturiranje
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>9. ES6 Destructuriranje</title>
</head>
<body>
<h1>ES6 Destructuriranje</h1>
<div id="output"></div>
<script>
const person = { name: 'Marko', age: 25, city: 'Novi Sad' };
// Destruktuiranje objekta
const { name, age } = person;
const numbers = [1, 2, 3, 4, 5];
// Destruktuiranje niza
const [first, second, ...rest] = numbers;

32

Poglavlje 7 Pokazne vežbe: Instalacija i prva React aplikacija

// Prikaz rezultata
const output = document.getElementById('output');
output.innerHTML = `
<h2>Destructuriranje objekta:</h2>
<p>Name: ${name}</p>
<p>Age: ${age}</p>
<h2>Destrukturiranje niza:</h2>
<p>First: ${first}</p>
<p>Second: ${second}</p>
<p>Rest: ${rest.join(', ')}</p>
`;
</script>
</body>
</html>

33

Poglavlje 8
Domaći zadatak
ZADATAK ZA SAMOSTALNI RAD
Domaći zadatak
Student treba da kod kuće podigne razvojno okruženje i uradi zadatak. Svaki student piše
unikatan zadatak sličan zadatku sa pokazne vežbe s time što umesto Hello World treba da
napiše svoje ime i prezime i broj indeksa. Treba napraviti po jedan zadatak za čisti html i jedan
za React. Predmetnom asistentu se dostavljaju oba zadatka i screenshoti razvojnog okruženja
sa otkucanim zadacima u njemu kao na slici.

Slika 8.1 Postavka zadatka [Izvor: Autor]

34

Poglavlje 9
Zaključak
REZIME
• React je biblioteka, ali zapravo je kombinacija dva glavna paketa: react i react-dom
i beskonačnog broja paketa treće strane koji se mogu veoma jednostavno uključiti u
aplikaciju. Iako je moguće izgraditi složene korisničke interfejse bez React-a, korišćenje
samo običnog JavaScript-a za to može biti nezgrapno, sklono greškama i teško za
održavanje.
• React pojednostavljuje kreiranje složenih korisničkih interfejsa pružanjem deklarativnog
načina za definisanje željenog krajnjeg stanja korisničkog interfejsa.
• Deklarativni pristup znači da definišete ciljni sadržaj i strukturu korisničkog interfejsa,
kombinovano sa različitim stanjima (npr. "da li je modalni prozor otvoren ili zatvoren?"), i
prepuštate React-u da odredi odgovarajuće DOM instrukcije.
• Paket react sam po sebi izvodi stanja korisničkog interfejsa i upravlja virtuelnim DOM-om.
"Mostovi" kao što su react-dom ili react-native prevode ovaj virtuelni DOM u stvarne UI
(DOM) instrukcije.
• Sa React-om možete izgraditi jednostrane aplikacije (Single Page Applications - SPAs), što
znači da se React koristi za kontrolisanje celog korisničkog interfejsa na svim stranicama,
kao i za rutiranje između stranica.
• React projekti mogu biti kreirani uz pomoć paketa vite, koji obezbeđuje unapred
konfigurisan projektni folder i razvojni server za pregled uživo.

LITERATURA
Literatura
[1] Maximilian Schwarzmuller. React Key Concepts. Packt Publishing Ltd, 2022.

35

IT354 - VEB SISTEMI 1

Moderni JavaScript u React-u
Lekcija 02

IT354 - VEB SISTEMI 1
Lekcija 02

MODERNI JAVASCRIPT U REACT-U
Moderni JavaScript u React-u
Poglavlje 1: Istorija JavaScripta
Poglavlje 2: Moderni JavaScript za React
Poglavlje 3: Simuliranje REST servera
Poglavlje 4: Pokazne vežbe
Zaključak

Copyright © 2017 – UNIVERZITET METROPOLITAN, Beograd. Sva prava zadržana. Bez prethodne pismene dozvole
od strane Univerziteta METROPOLITAN zabranjena je reprodukcija, transfer, distribucija ili memorisanje nekog
dela ili čitavih sadržaja ovog dokumenta., kopiranjem, snimanjem, elektronskim putem, skeniranjem ili na bilo
koji drugi način.
Copyright © 2017 BELGRADE METROPOLITAN UNIVERSITY. All rights reserved. No part of this publication may
be reproduced, stored in a retrieval system or transmitted in any form or by any means, electronic, mechanical,
photocopying, recording, scanning or otherwise, without the prior written permission of Belgrade Metropolitan
University.

www.metropolitan.ac.rs

Uvod
UVOD
Cilj lekcije, ishodi učenja i kompetencije koje ova lekcija omogućava
studentima
Cilj lekcije: Cilj lekcije je da upozna studente sa modernim elementima JavaScript jezika koji
se najviše koriste sa React razvojnim okvirom.

Ishodi učenja:
Student može da objasni istoriju razvoja JavaScripta
Student može da objasni šta je ECMAScript
Student može da koristi Moderne elemente JavaScript jezika
Student može da simulira REST server pomoću JSON servera
Student može da radi sa eksternim API-jima uz korišćenje Fetch API-ja

3

Poglavlje 1
Istorija JavaScripta
NASTANAK JAVASCRIPTA
Činjenica da je jedini programski jezik koji se nativno izvršava u web
pretraživačima čini ga posebno važnim
JavaScript je kreiran u maju 1995. godine za samo 10 dana, a tvorac mu je Brendan Eich,
koji je radio u Netscape-u i implementirao JavaScript za njihov web pregledač, Netscape
Navigator. Ideja je bila da se ključni interaktivni delovi na klijentskoj strani weba
implementiraju u Javi. JavaScript je trebalo da bude jezik koji povezuje te delove i omogućava
da HTML postane interaktivniji. Kako je JavaScript imao ulogu podrške Javi, morao je da
izgleda kao Java, što je isključilo postojeća rešenja kao što su Perl, Python, TCL i drugi jezici.
Drugi jezici, poput Pythona ili Jave, ne mogu se direktno izvršavati u pretraživaču bez
dodatnih alata ili prevodilaca. Na primer, da bi se Python kod pokrenuo u pretraživaču, on
bi morao da bude preveden u JavaScript (koristeći alate poput Brython-a) ili da se izvršava
na serveru, a rezultati zatim šalju pretraživaču putem mrežnih protokola. JavaScript je, s
druge strane, direktno integrisan u pretraživače, što ga čini neizostavnim alatom za front-end
razvoj.
Činjenica da je jedini programski jezik koji se nativno izvršava u web pretraživačima čini
ga posebno važnim. Kada korisnik otvori web stranicu, pretraživač preuzima HTML, CSS i
JavaScript fajlove, a zatim izvršava JavaScript direktno na strani klijenta (tj. na računaru
korisnika). Ovo omogućava dinamičko ponašanje web stranica, kao što su interaktivni
elementi, validacija formi, manipulacija strukturom stranice (DOM) i slično.
Druga izuzetno bitna činjenica u vezi javascripta je da je on u potpunosti standardizovan
jezik. Postoje dva standarda za JavaScript: ECMA-262, koji je domaćin organizacija Ecma
International i predstavlja glavni standard. ISO/IEC 16262, standard koji pripada
Međunarodnoj organizaciji za standardizaciju (ISO) i Međunarodnoj elektrotehničkoj komisiji
(IEC), predstavlja sekundarni standard. Jezik koji opisuju ovi standardi zove se ECMAScript,
a ne JavaScript, jer je Sun Microsystems (sada Oracle) imao zaštitni znak za ime JavaScript.
"ECMA" u nazivu dolazi od organizacije koja je domaćin glavnog standarda. U početku je to
bio akronim za European Computer Manufacturers Association, ali kasnije je ime promenjeno
u Ecma International.

4

Poglavlje 1 Istorija JavaScripta

KRATAK PREGLED VERZIJA ECMASCRIPT-A
Kratak pregled toka razvoja JacaScripta
Kratak pregled toka razvoja JacaScripta može se videti ako se sagledaju datumi objavljivanja
novih verzija primetno je da od 2015 godine novi standard izlazi svake godine u junu. Na listi
su datumi objavljivanja kao i najvažnija unapređenja jezika u svakoj od verzija.
• ECMAScript 1 (jun 1997): Prva verzija standarda.
• ECMAScript 2 (jun 1998): Mala ažuriranja radi usklađivanja sa ISO standardom.
• ECMAScript 3 (decembar 1999): Dodate mnoge osnovne funkcije, kao što su regularni
izrazi, bolja obrada stringova, nove naredbe kontrole toka (do-while, switch), rukovanje
izuzecima (try/catch).
• ECMAScript 4 (napušten u julu 2008): Trebalo je da bude velika nadogradnja (sa
statičkom tipizacijom, modulima, imenovanjima i više), ali je projekat bio previše
ambiciozan i doveo do neslaganja među kreatorima jezika.
• ECMAScript 5 (decembar 2009): Doneo je manje promene, uključujući nove funkcije
standardne biblioteke i strict mode.
• ECMAScript 5.1 (jun 2011): Mala ažuriranja radi usklađivanja standarda Ecma i ISO. Ova
revizija je postala standard ISO/IEC 16262:2011
• ECMAScript 6 (jun 2015): Velika nadogradnja koja je ispunila mnoga obećanja ECMAScript
4 verzije. Ovo je prva verzija koja je zvanično nazvana po godini objavljivanja,
ECMAScript 2015.Veliko ažuriranje koje je uvelo klase, module, streličaste funkcije,
šablonske stringove, destrukturisanje, promise i dr.
• ECMAScript 2016 (jun 2016): Metoda Array.prototype.includes() i eksponencijalni
operator (**)
• ECMAScript 2017 (jun 2017): Uvedene su asinhrone funkcije (async/await), kao i
Object.entries i Object.values
• ECMAScript 2018 (jun 2018): Funkcije rest/spread svojstava za objekte, asinhronih
iteracija, Promise.finally
• ECMAScript 2019 (jun 2019): Array.flat() i Array.flatMap(), Object.fromEntries(),
String.trimStart()
• ECMAScript 2020 (jun 2020): opcionalnog ulančavanja (?.), operator nul-koalescencije
(??), dinamičkih uvoza i BigInt.
• ECMAScript 2021 (jun 2021): String.prototype.replaceAll(), Promise.any()
• ECMAScript 2022 (jun 2022): await na najvišem nivou i nove metode za nizove poput
Array.prototype.at()
• ECMAScript 2023 (jun 2023): Array.prototype.toReversed(), Array.prototype.toSorted(),
Array.prototype.toSpliced(), Array.prototype.with()
• ECMAScript 2024 (jun 2024): Grupisanje objekata, Promise.withResolvers

5

Poglavlje 1 Istorija JavaScripta

1.1 Istorija JavaScripta primer
PRIMERI ELEMENATA JEZIKA
Primer za elementa jezika dodate u skorije vreme
<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ECMAScript Primeri (2016-2024)</title>
</head>
<body>
<h1>ECMAScript Primeri (2016-2024)</h1>

<script>
// Funkcija za dodavanje teksta u output
const log = (text) => {
document.getElementById('output').textContent += text + '\n';
};
// ECMAScript 2016
log("ECMAScript 2016:");
// Array.prototype.includes()
const niz = [1, 2, 3, 4, 5];
log(`Da li niz sadrži 3? ${niz.includes(3)}`);
// Eksponencijalni operator (**)
log(`2 na 3. stepen: ${2 ** 3}`);
// ECMAScript 2017
log("\nECMAScript 2017:");
// Asinhrone funkcije (async/await)
async function primerAsyncAwait() {
await new Promise(resolve => setTimeout(resolve, 1000));
return "Završeno!";
}
primerAsyncAwait().then(rezultat => log(rezultat));
// Object.entries i Object.values
const obj = { a: 1, b: 2, c: 3 };
log(`Object.entries: ${JSON.stringify(Object.entries(obj))}`);
log(`Object.values: ${JSON.stringify(Object.values(obj))}`);
// ECMAScript 2018
log("\nECMAScript 2018:");
// Rest/spread svojstva za objekte
const { a, ...ostatak } = obj;
log(`Rest operator: a = ${a}, ostatak = ${JSON.stringify(ostatak)}`);
const noviObj = { ...obj, d: 4 };

6

Poglavlje 1 Istorija JavaScripta

log(`Spread operator: ${JSON.stringify(noviObj)}`);
// Promise.finally
Promise.resolve().finally(() => log("Promise.finally se izvršio"));
// ECMAScript 2019
log("\nECMAScript 2019:");
// Array.flat() i Array.flatMap()
const ugnjezdeniNiz = [1, [2, 3], [4, [5, 6]]];
log(`Array.flat(): ${ugnjezdeniNiz.flat(2)}`);
log(`Array.flatMap(): ${[1, 2, 3].flatMap(x => [x, x * 2])}`);
// Object.fromEntries()
const entries = [['a', 1], ['b', 2], ['c', 3]];
log(`Object.fromEntries(): ${JSON.stringify(Object.fromEntries(entries))}`);
// String.trimStart()
log(`String.trimStart(): "${'
Zdravo
'.trimStart()}"`);
// ECMAScript 2020
log("\nECMAScript 2020:");
// Opcionalno ulančavanje (?.)
const user = { adresa: { ulica: "Glavna" } };
log(`Opcionalno ulančavanje: ${user?.adresa?.ulica}`);
// Operator nul-koalescencije (??)
const ime = null;
log(`Nul-koalescencija: ${ime ?? "Nepoznato ime"}`);
// BigInt
const velikiBroj = 1234567890123456789012345678901234567890n;
log(`BigInt: ${velikiBroj}`);
// ECMAScript 2021
log("\nECMAScript 2021:");
// String.prototype.replaceAll()
log(`replaceAll: ${"abababab".replaceAll("a", "c")}`);
// Promise.any()
Promise.any([
Promise.reject("Greška 1"),
Promise.resolve("Uspeh"),
Promise.reject("Greška 2")
]).then(rezultat => log(`Promise.any rezultat: ${rezultat}`));
// ECMAScript 2022
log("\nECMAScript 2022:");
// Array.prototype.at()
const niz2022 = [1, 2, 3, 4, 5];
log(`Array.at(-1): ${niz2022.at(-1)}`);
// ECMAScript 2023
log("\nECMAScript 2023:");
const niz2023 = [3, 1, 4, 1, 5, 9];
// Array.prototype.toReversed()
log(`toReversed: ${niz2023.toReversed()}`);
// Array.prototype.toSorted()
log(`toSorted: ${niz2023.toSorted()}`);
// Array.prototype.toSpliced()

7

Poglavlje 1 Istorija JavaScripta

log(`toSpliced: ${niz2023.toSpliced(1, 2, 6, 7)}`);
// Array.prototype.with()
log(`with: ${niz2023.with(2, 10)}`);
// ECMAScript 2024
log("\nECMAScript 2024:");
// Grupisanje objekata
const grupa = {
ime: "Grupa A",
članovi: {
prvi: { ime: "Ana" },
drugi: { ime: "Bojan" }
}
};
log(`Grupisanje objekata: ${JSON.stringify(grupa)}`);
// Promise.withResolvers()
const { promise, resolve, reject } = Promise.withResolvers();
promise.then(value => log(`Promise.withResolvers rezultat: ${value}`));
resolve("Rešeno!");
// Dinamički uvoz (simulacija)
log("Dinamički uvoz će biti demonstriran kada bude podržan u pregledaču.");
</script>
</body>
</html>

8

Poglavlje 2
Moderni JavaScript za React
LET
deklaracija promenljive sa var može biti jako nezgodna za
debugovanje
Ako već neko vreme pišete JS, znate da je deklaracija promenljive sa var može biti jako
nezgodna za debugovanje. U skoro svakom drugom jeziku, promenljiva se deklariše tamo
gde se vrši deklaracija. Ali u JS-u postoji koncept nazvan "hoisting" koji zapravo deklariše
promenljivu na takav način da će ona funkcionisati kao da je deklarisana na vrhu funkcije, čak
i ako je deklarisana kasnije.

Slika 2.1.1 Promenljiva name je deklarisana sa var [Izvor: Autor]

Deklaracija promenljive sa slike 2.1 potpuno je ekvivalentna sa deklaracijom na slici 2.2

Slika 2.1.2 Primer deklaracije ekvivalentne deklaraciji sa slike 3.1 [Izvor: Autor ]

ES2015 uvodi novu ključnu reč za deklaraciju promenljivih, let, koja se ponaša "normalno"
onako kako biste očekivali da se ponaša u drugim programskim jezicima koje ste do sada učili
slika 2.3:

9

Poglavlje 2 Moderni JavaScript za React

Slika 2.1.3 Primer deklaracije promenljive sa let [Izvor: Autor]

CONST
ES2015 uveo je const za deklarisanje konstanti.
ES2015 uveo je const za deklarisanje konstanti. Kada se deklariše promenljiva sa const, ona
mora biti inicijalizovana i ne možete joj dodeliti drugu vrednost kasnije.
const ocena = 6;
ocena = 8; //Greška
Kao i za promenljive deklarisane sa let, konstante su deklarisane su samo na nivou bloka.
U radu sa objektma const se ponaša nešto drugačije s obzirom da se objektima pristupa preko
reference moguće sa objektima raditi kao na slici 2.4

Slika 2.1.4 Primer korišćenja const [Izvor: Autor]

Razlog zašto dodela radi u linijama 2 i 5, a ne radi na liniji 6 se krije u tome što se nizu i
objektu pristupa preko reference koja je konstantna i postavlja se sadržaj na toj memorijskoj
lokaciji, a na liniji 6 se menja sama referenca što ključna reč const ne dozvoljava i izbacuje
grešku slika 2.5

Slika 2.1.5 Greška dodele konstantnoj promenljivoj [Izvor: Autor]

10

Poglavlje 2 Moderni JavaScript za React

DESTRUKTURIRAJUĆA DODELA
Od ES2015 postoji skraćeni način za dodelu promenljivih iz objekata ili
nizova.
Od ES2015 postoji skraćeni način za dodelu promenljivih iz objekata ili nizova. Ova
mogućnost se izuzetno mnogo koristi u modernom Javascriptu i React-u praktično je na
svakom koraku zato što značajno pojednostavljuje proces dodele vrednost. Ranije u ES5
dodela iz objekta izgledala bi kao na slici 2.6

Slika 2.1.6 Dodela vrednosti iz objekta ES5

Isto se može postići sa destrukturiranjem slika 2.7

Slika 2.1.7 Primer destruktuiranja sa menjanjem imena ključa

Ukoliko se pak ne želi menjati ime ključa unutar objekta moguće je destrukturiranje obaviti
kao na slici 2.8

Slika 2.1.8 Destruktuiranje kada nova promenljiva ima istu vrednost kao svojstvo objekta

Moguće je pristupati i iz objekta vaditi ugnježđene vrednosti kao na slici 2.9

Slika 2.1.9 Destrukturiranje ugnježđenog objekta

Moguće je destrukturirati i nizove slika 2.10:

11

Poglavlje 2 Moderni JavaScript za React

Slika 2.1.10 Destrukturiranje niza

PODRAZUMEVANI PARAMETRI I VREDNOSTI
JavaScript omogućava programerima da pozovu funkciju sa bilo kojim
brojem argumenata
Jedna od karakteristika JavaScript -a je da omogućava programerima da pozovu funkciju sa
bilo kojim brojem argumenata:
• Ako se prosledi više argumenata nego što funkcija ima parametara, dodatni argumenti
se ignorišu (iako se mogu koristiti sa specijalnom promenljivom arguments).
• Ako se prosledi manje argumenata nego što funkcija ima parametara, nedostajući
parametar će biti postavljen na undefined.
Od ES2015 uveden je precizniji način za postavljanje podrazumevanih parametara, direktno
u definiciji funkcije slika 2.11. Dakle, ako se parametar prosledi u funkciji će imati prosleđenu
vrednost, a ako se ne prosledi onda će imati postavljenu podrazumevanu vrednost.

Slika 2.1.11 Postavljanje podrazumevanih vrednosti parametara

Podrazumevana vrednost može biti vrednost funkcije ili izraz koji uključuje druge parametre
funkcije slika 2.12

Slika 2.1.12 Postavljanje podrazumevane vrednosti pomoću funkcije ili drugog parametra

Ovaj mehanizam za postavljanje početnih vrednosti može se koristiti i kod destrukturianja
slika 2.13

12

Poglavlje 2 Moderni JavaScript za React

Slika 2.1.13 Postvljanje podrazumevane vrednosti prilikom destrukturiranja

Na ovaj način konstanta timeout biće postavljena na vrednost 1000 ako ne postoji ili na
vrednost koja postoji.

REST I SPREAD OPERATERI
Rest operater omogućava prikupljanje svih preostalih elemenata u niz
ili objekat
Rest operater omogućava prikupljanje svih preostalih elemenata u niz ili objekat, kada se
prosleđju kao argumenti funkciji ili prilikom destrukturiranja podataka. Sintaksa su tri tačke
(...), a koristi se da "uhvati" preostale vrednosti u funkciji ili objektu.

Korišćenje u funkciji može se videti na slici 3.14. svi prosleđeni studenti biće ubačeni u jedan
niz students

Slika 2.1.14 Korišćenja rest operatera u funkciji [Izvor: Autor]

Rest operater može se koristiti i kod destrukturiranja podataka slika 3.15
na ovoj slici će niz studentsInClass biti destruktuiran tako da prvi element postaje prezenter,
a ostali će biti smešteni u niz listeners.

Slika 2.1.15 Korišćenje rest operatera priliom destruktuiranja [Izvor: Autor]

13

Poglavlje 2 Moderni JavaScript za React

Spread operator koristi se za proširenje elemenata niza ili objekta u drugu strukturu podataka.
U osnovi, "proširuje" elemente niza ili objekta u novi niz, objekt ili argumente funkcije. Primer
se može videti na slici 3.16

Slika 2.1.16 Korišćenje spread operatera [Izvor: Autor]

Na slici 3.16 u drugoj liniji niz arr1 se proširuje sa tri nova elementa. Na liniji 5 objektu obj1 se
dodaje novo polje city.

PROMISI (OBEĆANJA)
Promisi imaju za cilj da pojednostave asinhrono programiranje
Promisi imaju za cilj da pojednostave asinhrono programiranje. JS kod je pun asinhronih
poziva, kao što su AJAX zahtevi, i obično se koriste povratni pozive (callbacks) za obradu
rezultata i grešaka. Ali to može postati nepregledno, sa povratnim pozivima unutar povratnih
poziva, što čini kod teškim za čitanje i održavanje. Anti-patern "Piramida smrti" ili "callback
hell" nastaje kada se programiranjem pomoću povratnih poziva napravi potpuno nečitka i
neupotrebljiva konstrukcija koja liči na piramidu slika 3.17 prikazuje manju piramidu koja
je još uvek čitljiva, ali dok nisu uvedeni promisi bilo je uobičajeno da ovakva konstrukcija
naraste i na 20, pa čak i 30 nivoa i da bude u potpunosti nemoguća za održavanje. Promisi
su mnogo lepša varijanta od povratnih poziva, jer izravnavaju kod i time ga čine lakšim za
razumevanje.

Slika 2.1.17 "Piramida" povratnih poziva [Izvor: Autor]

Promisi su uvedeni kako bi se rešio problem sa povratnim pozivima u JavaScript-u. Umesto
ugnježđenih callback funkcija, korišćenjem .then() za povezivanje asinhronih operacija, što
pomaže u linearnom pisanju koda. Evo primera kako se "piramida smrti" sa slike 3.17 može
refaktorisati koristeći promise slika 3.18.

14

Poglavlje 2 Moderni JavaScript za React

Slika 2.1.18 Primer sa slike 2.17 refaktorisan pomoću promisa [Izvor: Autor]

Kao što se na slici može videti, promis je objekat koji ima metodu then. Ova metoda prima dva
argumenta: jedan povratni poziv za uspeh i jedan povratni poziv za grešku. Promis ima tri
stanja: pending (na čekanju): dok obećanje nije završeno, na primer, naš serverski poziv još
nije završen. fulfilled (ispunjeno): kada je obećanje uspešno završeno, na primer, serverski
poziv vraća OK HTTP status. rejected (odbijeno): kada je obećanje propalo, na primer, server
vraća 404 NOT FOUND status.

PROMISI (OBEĆANJA) #2
Kreiranje promisa je prilično jednostavno
Kreiranje promisa je prilično jednostavno, postoji klasa pod nazivom Promise, čiji konstruktor
očekuje funkciju sa dva parametra, resolve i reject.

Slika 2.1.19 Kreiranje novog promisa

Nakon kreiranja promisa, povratni poziv se može registrovati pomoću metode then. Ova
metoda može primiti dva parametra, dva povratna poziva u slučaju uspeha ili u slučaju
greške. Na slici 3.20 Prosleđuje se samo povratni poziv za uspeh, ignorišući potencijalnu
grešku.

15

Poglavlje 2 Moderni JavaScript za React

Slika 2.1.20 Povratni poziv za uspeh

Kada se promis razreši, povratni poziv za uspeh (ovde jednostavno ispisuje korisnika na
konzolu) će biti pozvan. Ukoliko posle toga treba uraditi još nešto asinhrono a u određenom
redosledu može se ulančati još jedan then poziv kao na slici 3.21

Slika 2.1.21 Ulančavanje promisa

PROMISI (OBEĆANJA) #3 OBRADA GREŠKE
Kreiranje promisa je prilično jednostavno #3
Kad se radi sa promisima moguće je koristiti jednu funkciju za obradu greške po promisu slika
3.22 ili što je mnogo popularnije, a i jednostavnije rešenje imati jedan hendler koji obrađuje
svaku grešku u lancu slika 3.23.

16

Poglavlje 2 Moderni JavaScript za React

Slika 2.1.22 Obrada greške za svaki promis pojedinačno

Na slici 3.23 ukoliko getUser pukne izvršavanje se odma prekida i ide se na catch blok
getRights i eventualni dodatni .then blokovi se ne izvršavaju.

Slika 2.1.23 Obrada greške za više promisa sa jednim catch blokom

Ova lekcija sadrži video materijal. Ukoliko želite da pogledate ovaj video morate da
otvorite LAMS lekciju.

STRELIČASTE (ARROW) FUNKCIJE
Streličaste funkcije su kraći i moderniji način za pisanje funkcija u
JavaScript-u

17

Poglavlje 2 Moderni JavaScript za React

Streličaste funkcije su kraći i moderniji način za pisanje funkcija u JavaScript-u. Uvedene su
u ES6 (ECMAScript 2015) i pružaju nekoliko prednosti, poput kraće sintakse i specifičnog
ponašanja sa ključnom reči this.

Sintaksa streličastih funkcija koristi simbol =>, odakle dolazi i naziv. Osnovna struktura data
je na slici 3.24.

Slika 2.1.24 Primeri streličastih funkcija

Bitno je napomenuti da su streličaste funkcije uvek anonimne zbog čega u startu imaju kraću
sintaksu. Kada postoji jedan parametar nije potrebno pisati zagrade, a kada je funkcija
jednolinijska onda nije potrebno pisati ni vitičaste zagrade za blok niti službenu reč return.
Jedna od najvažnijih razlika između streličastih funkcija i običnih funkcija u tome kako funkcije
vide vrednost this. U običnim funkcijama, vrednost this zavisi od načina na koji je funkcija
pozvana, dok streličaste funkcije ne vezuju svoj this kontekst; one koriste this iz okoline u
kojoj su definisane.

STRELIČASTE (ARROW) FUNKCIJE - RAZLIKE
Streličaste funkcije su kraći i moderniji način za pisanje funkcija u
JavaScript-u #2
Službena reč this u JavaScriptu je još jedna od stvari koje se ne ponašaju kao u ostalim
jezicima. Arrow funkcije rešavaju ovaj problem ali zbog toga ne mogu da koriste this kao
klasične JavaScript funkcije, jer ga ne vezuju direktno, što ih čini pogodnim za korišćenje u
situacijama kao što su setTimeout, setInterval i razni callback-ovi, gde nije poželjno da this
bude promenjen slika 3.25.

18

Poglavlje 2 Moderni JavaScript za React

Slika 2.1.25 Razlika this u klasičnoj i streličastoj funkciji

Kod funkcije Person this u anonimnoj funkciji koja je prosleđena funkciji setInterval ukazivaće
na globalni objekat zbog čega će nastati problem. Kod funkcije Person2 streličasta funkcija će
na očekivani način primeniti this i ovo će raditi kao u većini drugih programskih jezika.
Ostale razlike se mogu videti na slici 3.26. Streličasta funkcija dodeljena konstanti Person se
ne može koristiti kao konstruktor i streličaste funkcije ne mogu koristiti arguments objekat
koji obične funkcije imaju.

Slika 2.1.26 Razlike klasične i streličaste funkcije

Ova lekcija sadrži video materijal. Ukoliko želite da pogledate ovaj video morate da
otvorite LAMS lekciju.

ASYNC/AWAIT
Konstrukcija async/await je moderni način za rad sa asinhronim
operacijama u JavaScript-u

19

Poglavlje 2 Moderni JavaScript za React

Konstrukcija async/await je moderni način za rad sa asinhronim operacijama u JavaScriptu, on omogućava pisanje asinhronog kod-a na način koji je lakši za čitanje i razumevanje,
jerizgleda kao da je sinhroni. Pre uvođenja async/await, JavaScript je koristio callback funkcije
ili promise-e za rad sa asinhronim kodom, što je moglo rezultirati nečitljivim kodom (kao što
je piramida smrti u slučaju callback funkcija). async/await je uveden u ECMAScript 2017 (ES8)
standardu kako bi dodatno pojednostavio rad sa promisima (koji su uvedeni 2015).
Na slici 3.27 vidi se razlika između korišćenja promisa i async/await sintakse . Ovde, funkcija
fetchDataAsync koristi await da sačeka da se vrati vrednost, čime se eliminiše potreba za
.then() i .catch(). Da bi se koristio await, funkcija mora biti deklarisana sa async.

Slika 2.1.27 Uporedni prikaz promisa i async/await

ASYNC/AWAIT SEKVENCIJALNO/PARALELNO
await se može koristiti da se obavi više operacija u nizu
Sekvencijalne operacije:
await se može koristiti da se obavi više operacija u nizu, čime se čini kao da se asinhrone
operacije izvršavaju sinhrono jedna po jedna. Isečak koda prikazan je na slici 3.28. Na isečku
se vidi kako se tri zadatka izvršavaju paralelno jedan za drugim.

20

Poglavlje 2 Moderni JavaScript za React

Slika 2.1.28 Sekvencijalno izvršavanje asinhronih zadataka pomoću async/await

Moguće je takođe startovati više asinhronih procesa paralelno kao što je prikazano na slici
3.29. Ovaj isečak koda pokrenuće sva tri zadatka istovremeno i čekaće da se svi završe pre
nego što nastavi dalje.

Slika 2.1.29 Paralelno izvršavanje asinhronog koda pomoću async/await

SETOVI I MAPE
Set je kolekcija jedinstvenih vrednosti
Set je kolekcija jedinstvenih vrednosti, što znači da ne može sadržati duplikate. Set može
sadržati bilo koji tip vrednosti, uključujući primitivne i reference.

Nova instanca Set-a instancira se sa:

const mojSet = new Set();
Osnovne metode Set-a:
add() – Dodaje novu vrednost u Set.
delete() – Uklanja vrednost iz Set-a.
has() – Proverava da li Set sadrži određenu vrednost.
clear() – Briše sve elemente iz Set-a.
size – Vraća broj elemenata u Set-u.

Set se može koristiti sa for...of ili forEach.
21

Poglavlje 2 Moderni JavaScript za React

Slika 2.1.30 Primer korišćenja Set kolekcije

Jedna od čestih primena Set kolekcije je ekstrakcija jedinstvenih elemenata niza slika 3.31

Slika 2.1.31 Primer rada sa Set i nizom

SETOVI I MAPE #2
Map je kolekcija parova ključa i vrednosti
Map je kolekcija parova ključa i vrednosti, gde ključevi mogu biti bilo kojeg tipa (ne samo
stringovi kao u običnim objektima). Mape čuvaju redosled umetanja, što znači da se može
iterirati kroz njih redosledom kojim su elementi dodati.
Osnovne metode Map:
set(key, value) – Dodaje par ključa i vrednosti u Map.
get(key) – Vraća vrednost povezanu sa datim ključem.
delete(key) – Uklanja par ključa i vrednosti iz Map.
has(key) – Proverava da li Map sadrži određeni ključ.
clear() – Briše sve elemente iz Map.
size – Vraća broj parova u Map.
Map se može koristiti sa for...of ili forEach.
Primena nabrojanih metoda može se videti na slici 3.32. Ukratko, Set se koristi kada je
potrebno napraviti skup jedinstvenih vrednosti, a Map kada je neophodno imati kolekciju
parova ključa i vrednosti gde ključevi mogu da budu bilo kojeg tipa.

22

Poglavlje 2 Moderni JavaScript za React

Slika 2.1.32 Primer korišćenja Map

TEMPLATE LITERALI
Template literali omogućavaju umetanje promenljive direktno u string
Pre uvođenja template literala, za spajanje stringova i umetanje promenljivih unutar stringa
koristio se operator konkatenacije + .
Ovaj pristup može brzo postati težak za održavanje, naročito kada se radi sa dužim
stringovima ili višestrukim promenljivama. Template literali omogućavaju umetanje
promenljive direktno u string koristeći posebnu sintaksu - backticks (`) umesto klasičnih
jednostrukih ili dvostrukih navodnika. Promenljive i izrazi se mogu umetnuti unutar ${}.
Primer na slici
3.33 prikazuje kako se isti izlaz dobija konkatenacijom i templejt literalom.

23

Poglavlje 2 Moderni JavaScript za React

Slika 2.1.33 Primer umetanja promenljive u string konkatenacijom i templejt literalom

Drugi slučaj korišćenja templejt literala je višelinijski string koji se sada piše mnogo
jednostavnije.Primer poređenja starog i novig načina može se videti na slici 3.34 ovde je
ranije morao da se koristi specijalni karakter za novi red \n dok sada on vi[e nije potreban.

Slika 2.1.34 Višelinijski string na novi i stari način

2.1 Moderni JavaScript za React primer
PRIMER
Primer za predavanje
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>let i const primer</title>
</head>
<body>
<h1>let i const primer</h1>
<div id="output"></div>
<script>
const output = document.getElementById('output');
function exampleFunction() {
let x = 1;
const y = 2;

24

Poglavlje 2 Moderni JavaScript za React

if (true) {
let x = 10; // Nova varijabla sa dosegom u ovom bloku
const y = 20; // Nova konstanta vidljiva samo u ovom bloku
output.innerHTML += `Unutrašnji blok: x = ${x}, y = ${y}<br/>`;
}
output.innerHTML += `Spoljašnji blok: x = ${x}, y = ${y}<br/>`;
// Ovo će prijaviti grešku:
// y = 3; // Odkomentarisanje ove linije prijavljuje grešku (pokazati
na vežbama)
// Ovo radi:
x = 3;
output.innerHTML += `Posle promene vrednosti: x = ${x}<br/>`;
}
exampleFunction();
</script>
</body>
</html>

25

Poglavlje 3
Simuliranje REST servera
UVOD U FETCH API
Jedan od ključnih aspekata modernih veb aplikacija je sposobnost
komuniciranja sa serverima
Jedan od ključnih aspekata modernih veb aplikacija je sposobnost komuniciranja sa serverima
kako bi se preuzeli podaci ili poslao korisnički unos. Pre uvođenja Fetch API-ja, JavaScript
je koristio zastareli XMLHttpRequest objekat, koji je bio težak za upotrebu i dovodio do
nečitljivog koda. ES6 je uveo Fetch API, moderniji i jednostavniji način za rad sa HTTP
zahtevima. Fetch API koristi obećanja (promise) i omogućava slanje asinhronih HTTP zahteva
kako bi se preuzeli ili poslali podaci, u vidu JSON-a ili fajlova. Što znači da omogućava
elegantno upravljanje uspešnim i neuspešnim odgovorima.
Funkcija fetch vraća promis koji se rešava kada server odgovori. U slučaju uspešnog
odgovora, vraća se objekat tipa Response. U slučaju greške, promis prelazi u stanje "rejected"
i može se obraditi u catch bloku.

Slika 3.1.1 Osnovna sintaksa fetch

Prilikom slanja HTTP zahteva koristeći Fetch API, mogu se podesiti različita HTTP zaglavlja
(headers) kako bi se poslale dodatne informacije serveru. Ova zaglavlja mogu uključivati
podatke kao što su tip sadržaja, autentifikacioni tokeni ili informacije o jeziku. Pomoću
zaglavlja se može kontrolisati kako će server obraditi zahtev.
request.headers omogućava slanje specifičnih metapodataka kao deo zahteva. Ova zaglavlja
su ključna za ispravno funkcionisanje REST API-ja i komunikaciju sa serverima, posebno kada
su u pitanju podaci u različitim formatima (npr. JSON, HTML) ili zahtevi koji zahtevaju
autentifikaciju.
Kada se šalje zahtev sa Fetch API-jem, mogu se dodati zaglavlja koja sadrže informacije kao
što su tip sadržaja ili autentifikacioni token.

26

Poglavlje 3 Simuliranje REST servera

Slika 3.1.2 primer prosleđivanje kroz header

request.headers su ključna komponenta HTTP zahteva, jer omogućavaju slanje dodatnih
informacija serveru koje pomažu u obradi zahteva.

RAZUMEVANJE OBJEKTA RESPONSE
Kada Fetch API vrati odgovor, dobijamo Response objekat
Kada Fetch API vrati odgovor, dobijamo Response objekat, koji sadrži važne informacije o
odgovoru servera, uključujući statusni kod, zaglavlja, i telo odgovora.
Statusni kod i uspešnost odgovora
Svaki HTTP odgovor ima statusni kod koji označava uspešnost ili neuspeh zahteva. Fetch API
ne smatra neuspehom samo ako sam upit ne uspe, ako upit uspe i vrati status koji je greška,
statusni kod 404 ili 500, fetch će to i dlje smatrati uspehom. Zato je neophodno dodatno
obraditi statusne kodove. Slika 3.2 Prikazuje jedan takav primer.

Slika 3.1.3 Primer obrade graške kod fetch

UVOD REST API
Današnje web aplikacije sve češće zavise od REST API-ja
Današnje web aplikacije sve češće zavise od REST API-ja za komunikaciju između klijentske
strane (frontend) i serverske strane (backend). REST API (Representational State Transfer) je
arhitektura koja omogućava klijentima da komuniciraju sa serverima putem HTTP zahteva,
obično u JSON formatu. Prilikom razvoja aplikacija, često se dešava da frontend tim počne rad
27

Poglavlje 3 Simuliranje REST servera

na interfejsu pre nego što je backend u potpunosti spreman. U takvim situacijama, korisno je
znati kako simulirati REST API i testirati frontend aplikaciju bez stvarnog servera.

REST API je stil arhitekture koji se koristi za komunikaciju između klijenta i servera preko
HTTP-a. REST API je u suštini skup pravila i konvencija koje omogućavaju lako slanje i primanje
podataka između aplikacija, koristeći standardne HTTP metode.

Ključne karakteristike REST API-ja su:
• Resursi: REST API koristi URI-ove (Uniform Resource Identifiers) za identifikaciju resursa
(npr. korisnika, proizvoda, porudžbina).
• Stateless: Svaki zahtev koji klijent šalje serveru je nezavistan, što znači da server ne
zadržava informacije o prethodnim zahtevima.
• HTTP metode: REST API koristi standardne HTTP metode za interakciju sa resursima:
GET za preuzimanje podataka. POST: za slanje novih podataka. PUT/PATCH za ažuriranje
postojećih podataka i DELETE za brisanje podataka.

GET I POST
GET i POST zahtevi
GET – Preuzimanje podataka
GET zahtevi se koriste za preuzimanje podataka sa servera. Oni ne menjaju podatke, već
samo traže informacije.

Slika 3.1.4 Primer GET upita pomoću Fetcha

POST – Slanje podataka
POST metoda se koristi za kreiranje novih podataka na serveru. Kada se šalje POST zahtev,
obično se šalju i neki JSON podaci u telu zahteva. Na slici je prikazano slanje podataka
korisnika na API endpoint jsonplaceholder.typicode.com/users ovo je lažni API koji se može
pozivati radi vežbanja. u nastavku lekcije biće objašnjeno kako je moguće napraviti svoj mock
API.

28

Poglavlje 3 Simuliranje REST servera

Slika 3.1.5 Primer POST upita pomoću Fetch

PUT, PATCH I DELETE
PUT, PATCH i DELETE zahtevi
PUT i PATCH – Ažuriranje podataka

PUT ili PATCH metode koriste se za ažuriranje postojećih podataka. PUT se obično koristi za
potpuna ažuriranja, dok PATCH služi za delimična. Kod put je dakle bitno da se pošalju sva
polja objekta, jer se ceo objekat menja onim što je poslato dok kod PATCH može biti poslato
samo ono polje koje se menja.

Slika 3.1.6 Primer PUT upita pomoću Fetcha

DELETE – Brisanje podataka

29

Poglavlje 3 Simuliranje REST servera

DELETE metoda koristi se za brisanje podataka sa servera. Obično se prosleđuje samo id
objekta koji treba da bude obrisan.

Slika 3.1.7 Primer DELETE upita pomoću Fetcha

KREIRANJE FRONTENDA POMOĆU JSON SERVERA
Frontend programeri često moraju da rade bez gotovog backenda
Tokom razvoja modernih web aplikacija, frontend programeri često moraju da rade bez
gotovog backenda. Da bi se izbeglo čekanje na izgradnju serverskog dela, jedan od efikasnih
alata koji omogućava simulaciju REST API -ja je JSON Server. Ovaj alat omogućava brz razvoj
prototipova i testiranje aplikacija bez potrebe za pravim backend serverom. JSON Server je
alat koji omogućava brzo podizanje lokalnog REST API-ja korišćenjem samo jednog JSON fajla.
Ovaj alat automatski generiše sve osnovne RESTful rute (GET, POST, PUT, DELETE) na osnovu
sadržaja JSON fajla. Ovo ga čini idealnim rešenjem za frontend timove koji rade bez gotovog
backenda.
Da bi se koristilo JSON Server, mora se instalirati. JSON Server se instalira putem Node
Package Manager-a ( NPM), tako da je potrebno imati instaliran Node.js na računaru.
npm install -g json-server

Instalira biblioteku json-server na računar globalno, moguće je instalirati ga i zasebno u svaki
projekat ako se izostavi -g
Nakon što je JSON Server instaliran, potrebno je kreirati JSON fajl koji će služiti kao baza
podataka za lažni API slika 3.8.

30

Poglavlje 3 Simuliranje REST servera

Slika 3.1.8 Primer JSON fajla db.json

KORIŠĆENJE JSON-SERVERA
JSON Server omogućava da simulirani API bude dostupan na
http://localhost:3000
Nakon kreiranja db.json fajla, može se pokrenuti JSON Server. Ovo će kreirati REST API koji
može da komunicira sa podacima iz fajla.
json-server --watch db.json
Ova komanda pokreće JSON Server i omogućava da API bude dostupan na
http://localhost:3000 Takođe, koristi opciju --watch kako bi se sve izmene u db.json
automatski reflektovale u API-ju bez potrebe za restartovanjem servera.
Kada je JSON Server pokrenut, kreirani su RESTful endpoint-i na osnovu podataka u db.json.

REST API raspolaže sa sledećim osnovnim endpoint-ima:
GET /users: Vraća listu svih korisnika.
GET /users/{id}: Vraća korisnika sa određenim id.
POST /users: Dodaje novog korisnika.
PUT /users/{id}: Ažurira celog korisnika sa određenim id.
PATCH /users/{id}: Ažurira delimično korisnika sa određenim id.
DELETE /users/{id}: Briše korisnika sa određenim id.

3.1 Simuliranje REST servera primer
PRIMER ZA FETCH
Primer sa JSON placeholderom
<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fetch API Primer sa JSONPlaceholder</title>
</head>
<body>
<h1>Fetch API Primer sa JSONPlaceholder</h1>

31

Poglavlje 3 Simuliranje REST servera

<div id="controls">
<button id="getPosts">Dohvati objave</button>
<button id="getUser">Dohvati korisnika</button>
<button id="createPost">Kreiraj objavu</button>
<button id="updatePost">Ažuriraj objavu</button>
<button id="deletePost">Obriši objavu</button>
</div>
<pre id="output">
<pre>
<pre>
<script>
// Funkcija za dodavanje teksta u output
const log = (text) => {
document.getElementById('output').textContent += text + '\n';
};
// Funkcija za čišćenje outputa
const clearOutput = () => {
document.getElementById('output').textContent = '';
};
// GET zahtev - dohvatanje objava
document.getElementById('getPosts').addEventListener('click', () => {
clearOutput();
fetch('https://jsonplaceholder.typicode.com/posts?_limit=5')
.then(response => response.json())
.then(data => {
log('Dohvaćene objave:');
data.forEach(post => {
log(`ID: ${post.id}, Naslov: ${post.title}`);
});
})
.catch(error => log(`Greška: ${error}`));
});
// GET zahtev - dohvatanje korisnika
document.getElementById('getUser').addEventListener('click', () => {
clearOutput();
fetch('https://jsonplaceholder.typicode.com/users/1')
.then(response => response.json())
.then(user => {
log('Dohvaćen korisnik:');
log(`Ime: ${user.name}`);
log(`Email: ${user.email}`);
log(`Grad: ${user.address.city}`);
})
.catch(error => log(`Greška: ${error}`));
});
// POST zahtev - kreiranje nove objave
document.getElementById('createPost').addEventListener('click', () => {
clearOutput();
fetch('https://jsonplaceholder.typicode.com/posts', {
method: 'POST',

32

Poglavlje 3 Simuliranje REST servera

body: JSON.stringify({
title: 'Nova objava',
body: 'Ovo je sadržaj nove objave.',
userId: 1
}),
headers: {
'Content-type': 'application/json; charset=UTF-8',
}
})
.then(response => response.json())
.then(data => {
log('Kreirana nova objava:');
log(`ID: ${data.id}`);
log(`Naslov: ${data.title}`);
log(`Sadržaj: ${data.body}`);
})
.catch(error => log(`Greška: ${error}`));
});
// PUT zahtev - ažuriranje objave
document.getElementById('updatePost').addEventListener('click', () => {
clearOutput();
fetch('https://jsonplaceholder.typicode.com/posts/1', {
method: 'PUT',
body: JSON.stringify({
id: 1,
title: 'Ažurirana objava',
body: 'Ovo je ažurirani sadržaj objave.',
userId: 1
}),
headers: {
'Content-type': 'application/json; charset=UTF-8',
}
})
.then(response => response.json())
.then(data => {
log('Ažurirana objava:');
log(`ID: ${data.id}`);
log(`Naslov: ${data.title}`);
log(`Sadržaj: ${data.body}`);
})
.catch(error => log(`Greška: ${error}`));
});
// DELETE zahtev - brisanje objave
document.getElementById('deletePost').addEventListener('click', () => {
clearOutput();
fetch('https://jsonplaceholder.typicode.com/posts/1', {
method: 'DELETE',
})
.then(response => {
if (response.ok) {
log('Objava uspešno obrisana.');

33

Poglavlje 3 Simuliranje REST servera

} else {
log('Greška prilikom brisanja objave.');
}
})
.catch(error => log(`Greška: ${error}`));
});
</script>
</body>
</html>

34

Poglavlje 4
Pokazne vežbe
POKAZNA VEŽBA: USER MANAGEMENT SYSTEM
Vežbanje koncepata sa predavanja
Na vežbama Asistent prikazuje proces simuliranja REST APi sa JSON serverom. Tema pokazne
vežbe je frontend sistem za upravljanje korisnicima napisan u čistom JavaScript-u koji
komunicira sa REST API-jem simuliranim pomoću JSON servera.

Nakon kreiranja projekta u Visual Studio Code editoru. Prvo je potrebno napraviti fajl db.json
u koji se unose podaci korisnika.
Zatim se pravi fajl index.html u kojem se kreira cela aplikacija.
Nakon toga potrebno je pokrenuti json-server sa komandom:
npx json-server --watch db.json

npx je alat koji dolazi sa npm-om (Node Package Manager) i omogućava izvršavanje Node.js
paketa bez potrebe za njihovom prethodnom instalacijom.
Kada koristite npxjson − server , npx će:
• Prvo proveriti da li je json-server već instaliran lokalno ili globalno.
• Ako nije instaliran, npx će privremeno preuzeti i instalirati najnoviju verziju json-servera.
• Nakon toga, izvršiće komandu json − server − − watchdb. json .
{
"users": [
{
"id": "1",
"name": "John Doe",
"email": "john@example.com"
},
{
"id": "2",
"name": "Pera",
"email": "pera@mika.com"
}
]
}

35

Poglavlje 4 Pokazne vežbe

POKAZNA VEŽBA: USER MANAGEMENT SYSTEM INTERFEJS
Prikaz interfejsa aplikacije

Slika 4.1 Interfejs za pokaznu vežbu Izvor: Autor

POKAZNA VEŽBA: USER MANAGEMENT SYSTEM SORS KOD
Kod gotovog projekta
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IT354 User Management System</title>
<style>
body {
font-family: Arial, sans-serif;
max-width: 800px;
margin: 0 auto;
padding: 20px;
}
h1, h2 {
color: #333;
}

36

Poglavlje 4 Pokazne vežbe

form {
margin-bottom: 20px;
}
input, button {
margin: 5px 0;
padding: 5px;
}
#userList {
list-style-type: none;
padding: 0;
}
#userList li {
background-color: #f0f0f0;
margin: 5px 0;
padding: 10px;
border-radius: 5px;
}
.error {
color: red;
}
</style>
</head>
<body>
<h1>IT354 User Management System</h1>
<h2>Dodaj novog korisnika </h2>
<form id="addUserForm">
<input type="text" id="name" placeholder="Ime" required>
<input type="email" id="email" placeholder="Email" required>
<button type="submit">Dodaj</button>
</form>
<h2>Ažuriraj korisnika</h2>
<form id="updateUserForm">
<input type="number" id="updateId" placeholder="ID" required>
<input type="text" id="updateName" placeholder="Novo Ime">
<input type="email" id="updateEmail" placeholder="Novi Email">
<button type="submit">Ažuriraj korisnika</button>
</form>
<h2>Obriši korisnika</h2>
<form id="deleteUserForm">
<input type="number" id="deleteId" placeholder="ID" required>
<button type="submit">Obriši korisnika</button>
</form>
<h2>Lista korisnika</h2>
<button id="refreshButton">Refreshuj listu korisnika</button>
<ul id="userList"></ul>
<script>
const API_URL = 'http://localhost:3000';

37

Poglavlje 4 Pokazne vežbe

// Funkcija koja prikazuje greške
function showError(message) {
const errorDiv = document.createElement('div');
errorDiv.className = 'error';
errorDiv.textContent = message;
document.body.appendChild(errorDiv);
setTimeout(() => errorDiv.remove(), 3000);
}
// Funkcija koja fetchuje i prikazuje korisnike
async function fetchUsers() {
try {
const response = await fetch(`${API_URL}/users`);
if (!response.ok) {
throw new Error(`HTTP greška! status: ${response.status}`);
}
const users = await response.json();
const userList = document.getElementById('userList');
userList.innerHTML = '';
users.forEach(user => {
const li = document.createElement('li');
li.textContent = `ID: ${user.id}, Ime: ${user.name}, Email:
${user.email}`;
userList.appendChild(li);
});
} catch (error) {
showError(`Neuspešno učitavanje korisnika: ${error.message}`);
}
}
// Dodaj novog korisnika
document.getElementById('addUserForm').addEventListener('submit', async (e)
=> {
e.preventDefault();
const name = document.getElementById('name').value;
const email = document.getElementById('email').value;
try {
const response = await fetch(`${API_URL}/users`, {
method: 'POST',
headers: {
'Content-Type': 'application/json',
},
body: JSON.stringify({ name, email }),
});
if (!response.ok) {
throw new Error(`HTTP greška! status: ${response.status}`);
}
await fetchUsers();
e.target.reset();
} catch (error) {
showError(`Neuspešno dodavanje korisnika: ${error.message}`);
}
});

38

Poglavlje 4 Pokazne vežbe

// Ažuriranje korisnika
document.getElementById('updateUserForm').addEventListener('submit', async
(e) => {
e.preventDefault();
const id = document.getElementById('updateId').value;
const name = document.getElementById('updateName').value;
const email = document.getElementById('updateEmail').value;
const updateData = {};
if (name) updateData.name = name;
if (email) updateData.email = email;
try {
const response = await fetch(`${API_URL}/users/${id}`, {
method: 'PATCH',
headers: {
'Content-Type': 'application/json',
},
body: JSON.stringify(updateData),
});
if (!response.ok) {
throw new Error(`HTTP greška! status: ${response.status}`);
}
await fetchUsers();
e.target.reset();
} catch (error) {
showError(`Neuspešno ažuriranje korisnika: ${error.message}`);
}
});
// Brisanje korisnika
document.getElementById('deleteUserForm').addEventListener('submit', async
(e) => {
e.preventDefault();
const id = document.getElementById('deleteId').value;
try {
const response = await fetch(`${API_URL}/users/${id}`, {
method: 'DELETE',
});
if (!response.ok) {
throw new Error(`HTTP greška! status: ${response.status}`);
}
await fetchUsers();
e.target.reset();
} catch (error) {
showError(`Neušpešno brisanje korisnika: ${error.message}`);
}
});
// Registrovanje osluškivača događaja na dugme osveži listu
document.getElementById('refreshButton').addEventListener('click',
fetchUsers);
// Fečuj korisnike kad se strana učita

39

Poglavlje 4 Pokazne vežbe

fetchUsers();
</script>
</body>
</html>

40

Poglavlje 5
Zaključak
REZIME
Rezime lekcije
U lekciji su predstavljeni sledeći bitni koncepti:
• let i const: Uvođenje blok promenljivih (let) i konstanti (const), što omogućava bolju
kontrolu nad životnim vekom i mutabilnošću varijabli.
• Destrukturirajuća dodela: Omogućava efikasno raspakivanje vrednosti iz nizova ili
svojstava iz objekata u zasebne varijable, čineći kod čitljivijim i konciznijim.
• Podrazumevani parametri i vrednosti: Dozvoljava definisanje podrazumevanih vrednosti
za parametre funkcija i u destrukturiranju, što povećava fleksibilnost i smanjuje potrebu
za proveram undefined vrednosti.
• Rest i spread operatori: Rest (...) omogućava prikupljanje preostalih elemenata u niz,
dok spread (...) omogućava širenje elemenata niza ili svojstava objekta, pružajući veću
fleksibilnost u radu sa kolekcijama podataka.
• Promisi (Obećanja): Uvode mehanizam za rad sa asinhronim operacijama,
omogućavajući bolje upravljanje i lanac asinhronih poziva, što rezultira čitljivijim i
održivijim kodom u poređenju sa callback funkcijama.
• Template literali: Pružaju unapređen način za kreiranje stringova, omogućavajući
interpolaciju izraza i višelinijske stringove bez potrebe za posebnim karakterima za
escape ili konkatenacijom.

LITERATURA
1. React key concepts: Consolidate your knowledge of React’s core features. Schwarzmuller,
M. . Packt Publishing Ltd. (2022)
2. https://exploringjs.com/js/index.html - Besplatna online JavaScript knjiga: Exploring
JavaScript ES2024 Edition, dr Axel Rauschmayer
3. Become ninja with Angular, Ninja Squad (2024)
4. https://github.com/typicode/json-server/tree/v0 - JSON Server dokumentacija

41

Poglavlje 5 Zaključak

42

IT354 - VEB SISTEMI 1

Komponente i JSX
Lekcija 03

IT354 - VEB SISTEMI 1
Lekcija 03

KOMPONENTE I JSX
Komponente i JSX
Poglavlje 1: Komponente
Poglavlje 2: JSX
Poglavlje 3: Kombinovanje komponenti
Poglavlje 4: Pokazne vežbe
Zaključak

Copyright © 2017 – UNIVERZITET METROPOLITAN, Beograd. Sva prava zadržana. Bez prethodne pismene dozvole
od strane Univerziteta METROPOLITAN zabranjena je reprodukcija, transfer, distribucija ili memorisanje nekog
dela ili čitavih sadržaja ovog dokumenta., kopiranjem, snimanjem, elektronskim putem, skeniranjem ili na bilo
koji drugi način.
Copyright © 2017 BELGRADE METROPOLITAN UNIVERSITY. All rights reserved. No part of this publication may
be reproduced, stored in a retrieval system or transmitted in any form or by any means, electronic, mechanical,
photocopying, recording, scanning or otherwise, without the prior written permission of Belgrade Metropolitan
University.

www.metropolitan.ac.rs

Uvod
UVOD
Uvod u lekciju
U prethodnom delu objašnjeno je šta je React, zašto je postao jedan od najpopularnijih alata
za pravljenje korisničkih interfejsa. Pored toga, dat je detaljan uvid u proces kreiranja React
projekata, čime je olakšan početak rada sa ovim moćnim framework-om. U ovoj lekciji, pažnja
je usmerena na jedan od najvažnijih i najosnovnijih koncepata unutar React-a: komponente.
Objašnjeno je da su komponente osnovni građevinski blokovi, koji se mogu višekratno koristiti
za kreiranje različitih delova korisničkog interfejsa, čineći razvoj aplikacija modularnijim i
organizovanijim. Takođe, biće obrađen JSX, specifičan sintaksni dodatak za JavaScript, koji
omogućava jednostavnije i intuitivnije kreiranje komponenti. Detaljno je opisano kako treba
da se koriste komponente i JSX, kako bi se postavili temelji za izradu, osnovnih React
aplikacija. Na taj način, student će biti osposobljeni da kreiraju funkcionalne i prilagodljive
korisničke interfejse koristeći React.

3

Poglavlje 1
Komponente
REACT KOMPONENTE
React komponente uvod
Komponente su osnovni i ključni koncept u React-u, koji omogućava modularnu izgradnju
korisničkih interfejsa. One predstavljaju višekratno upotrebljive građevinske blokove koji
se mogu kombinovati na različite načine kako bi se sastavio celokupni korisnički interfejs
aplikacije. Na primer, osnovni veb-sajt može biti organizovan kao skup različitih komponenti,
gde zaglavlje uključuje navigacioni meni, a glavna sekcija sadrži formular za autentifikaciju.
Svaka od ovih funkcionalnosti može biti zasebna komponenta, što omogućava jednostavnije
održavanje i lakšu izmenu ili proširenje aplikacije. Na taj način, React omogućava
developerima da grade složene korisničke interfejse sa većom fleksibilnošću i ponovnom
upotrebljivošću koda.

Bez obzira na to koju veb stranicu mislimo, sve su one sastavljene od određenih građevinskih
blokova. Ovaj koncept nije specifičan za React; zapravo, čak i HTML "razmišlja" u
komponentama. Ako se pažljivije analizira HTML, može se primetiti da koristi različite
elemente, poput <img>, <header>, <nav>, i mnoge druge, koji se kombinuju kako bi se
opisao i strukturirao sadržaj veb stranice.

React dodatno proširuje ovu ideju razbijanja veb stranice na višekratno upotrebljive
građevinske blokove. Ovaj pristup omogućava programerima da se fokusiraju na male, lako
upravljive delove koda, što je daleko jednostavnije i održivije nego raditi na jednoj velikoj
HTML ili React datoteci. Zbog ovih prednosti, i druge biblioteke bilo da su to frontend
biblioteke poput React-a ili Angular-a, ili backend biblioteke i template biblioteke kao što
je EJS (Embedded JavaScript templates) takođe prihvataju koncept komponenti. Iako se
terminologija može razlikovati, često se koriste izrazi poput " partials" ili " includes", koji imaju
sličnu funkciju.

Kada se radi sa React -om, posebno je važno da kod bude modularan i lako upravljiv.
React komponente nisu samo kolekcije HTML koda; one takođe mogu enkapsulirati JavaScript
logiku, a često i CSS stilizaciju. Kod razvoja složenih korisničkih interfejsa, kombinacija
markup-a ( JSX), logike ( JavaScript), i stilizacije ( CSS) može brzo dovesti do velikih delova
koda. Upravljanje takvim kodom postaje veoma izazovno ako nije pravilno organizovan. U
situaciji u kojoj postoji ogromna HTML datoteka koja sadrži i JavaScript i CSS kod, rad u
takvom okruženju bio bi izrazito nepraktičan i teško održiv. Korišćenje komponenti značajno
ublažava ove izazove, omogućavajući kreiranje funkcionalnih i održivih aplikacija.

4

Poglavlje 1 Komponente

PRINCIP RADA KOMPONENTE
Objašnjenje principa rada komponente
U React-u, komponente su funkcije (ili klase, iako su one, kao što je ranije pomenuto, sve
manje relevantne u modernom razvoju). Funkcija je regularna JavaScript konstrukcija i nije
specifična za React. Ovo je važan aspekt koji treba napomenuti: React je JavaScript biblioteka
i, kao takva, koristi postojeće JavaScript funkcionalnosti, poput funkcija, za implementaciju
svojih karakteristika. React nije potpuno novi programski jezik; umesto toga, on proširuje
mogućnosti JavaScript-a za izgradnju korisničkih interfejsa. Kada se radi sa React-om,
regularne JavaScript funkcije mogu se koristiti za enkapsulaciju HTML (ili, tačnije, JSX) koda,
kao i JavaScript logike koja pripada tom markup kodu. Međutim, važno je naglasiti da će
funkcija biti tretirana kao React komponenta samo ako zadovoljava određene kriterijume,
odnosno ako se koristi na specifičan način unutar React ekosistema. Na primer, u ranijim
delovima koda, funkcija submitHandler je takođe regularna JavaScript funkcija, ali ona nije
React komponenta. Razlika je u tome što submitHandler funkcija obavlja specifičnu akciju (u
ovom slučaju, postavlja stanje isSubmitted), dok funkcionalne komponente u React-u vraćaju
JSX, odnosno strukturirani markup, koji određuje kako će deo korisničkog interfejsa izgledati.
Da bi funkcija bila prepoznata kao React komponenta, ona mora vraćati JSX i može koristiti
React-ove hooks-e za rad sa stanjem i životnim ciklusom komponenti.

U delovima koda gde je definisana funkcija pod nazivom SubmitButton , ta dve funkcija se
kvalifikovala kao React komponenta zato što vraćaja JSX kod. JSX je poseban oblik koda koji
React može da renderuje, čineći te funkcije "renderabilnim" komponentama. Kada funkcija
zadovolji ovaj kriterijum, ona postaje React komponenta i može se koristiti poput HTML
elementa unutar JSX koda. Na primer, <SubmitButton /> je korišćen kao samozatvarajući
HTML element, što je moguće zato što SubmitButton funkcija vraća JSX. Ono što je specifično
kod funkcionalnih komponenti u React-u, u poređenju sa običnim JavaScript funkcijama,
jeste način na koji se one koriste. Kada radite sa običnim JavaScript-om, obično direktno
pozivate funkcije kako biste ih izvršili. Međutim, kod funkcionalnih komponenti u React-u,
to funkcioniše drugačije. React poziva ove funkcije automatski u vaše ime kada renderuje
komponente. Kao programer, vi te funkcije koristite poput HTML elemenata unutar JSX
koda, ne brinući o njihovom eksplicitnom pozivanju. Ovaj pristup omogućava jednostavniju i
intuitivniju izgradnju korisničkih interfejsa, jer funkcionalne komponente izgledaju i ponašaju
se kao obični HTML elementi, dok u pozadini React upravlja procesom njihovog pozivanja i
renderovanja.

KORISNIČKI KREIRANE KOMPONENTE
Komponente kreirane od strane korisnika
Uopšteno, funkcije u React-u mogu biti imenovane na različite načine barem u okviru
datoteke u kojoj su definisane. Međutim, uobičajena praksa je korišćenje PascalCase
konvencije imenovanja, gde prvi karakter počinje velikim slovom, a više reči se spajaju u
jednu reč (npr. SubmitButton umesto Submit Button), pri čemu svaka " podrečenica" takođe

5

Poglavlje 1 Komponente

počinje velikim slovom.
Iako je ovo samo konvencija imenovanja prilikom definisanja funkcije komponente, ona
postaje obavezna u JSX kodu kada se koriste korisnički kreirane komponente. Na primer, nije
moguće koristiti korisnički kreiranu komponentu na sledeći način:
<pozdrav />
React zahteva da imena korisnički kreiranih komponenti da počinju velikim slovom kada se
koriste u JSX kodu. Ovo pravilo postoji kako bi React-u omogućilo da jednostavno razlikuje
korisnički kreirane komponente komponente od ugrađenih elemenata kao što su <div>, <p>,
i slični. React samo proverava početni karakter kako bi odredio da li je u pitanju ugrađeni
element ili korisnički kreirana komponenta.

Pored imenovanja funkcija komponenti, važno je razumeti i konvencije imenovanja datoteka.
Korisničke komponente se obično čuvaju u posebnim datotekama smeštenim unutar foldera
src/components/. Iako ovo nije strogo pravilo, uobičajena praksa je korišćenje foldera pod
nazivom components/.
Dok je PascalCase standard za imenovanje funkcija komponenti, ne postoji univerzalno
prihvaćen standard za imenovanje datoteka. Neki programeri preferiraju PascalCase i za
nazive datoteka; na primer, u novokreiranim React projektima, komponenta App se može
naći u datoteci pod nazivom App.js. S druge strane, mnogi React projekti koriste kebabcase konvenciju imenovanja (sva slova su mala, a više reči se spaja pomoću crtice). Prema
ovoj konvenciji, funkcije komponenti bi mogle biti smeštene u datoteke nazvane, na primer,
submit-button.js.

UGRAĐENE KOMPONENTE
Razumevanje ugrađenih komponenti
Kao što je prikazano u prethodnim primerima, moguće je kreirati prilagođene komponente
definisanjem funkcija koje vraćaju JSX kod. Ovo je jedna od osnovnih aktivnosti koje će svaki
React programer redovno obavljati u svakodnevnom radu: stalno će kreirati funkcionalne
komponente. Te komponente su ključne za modularizaciju i organizaciju koda.

Međutim, ako bi se sav JSX kod spojio u jedan veliki blok, kao što je prikazano u nekim
primerima, rezultat bi bio JSX kod koji sadrži samo standardne HTML elemente, poput <div>,
<h2>, <p>, i slično.

Važno je razumeti da, kada se koristi React , ne kreiraju se novi HTML elementi koje
pretraživač direktno prikazuje i obrađuje. Umesto toga, kreiraju se komponente koje
funkcionišu unutar React okruženja. Ove komponente, pre nego što stignu do pretraživača,
bivaju evaluirane od strane React -a i "prevedene" u JavaScript instrukcije za manipulaciju
DOM-om, poput document.append(…) i drugih sličnih operacija.

6

Poglavlje 1 Komponente

Međutim, treba imati na umu da JSX kod nije deo samog JavaScript jezika. JSX je zapravo
sintaktičko pojednostavljenje koje pruža React biblioteka, zajedno sa odgovarajućim
podešavanjem projekta za pisanje React koda. Dakle, kada se koriste elementi poput <div>
u JSX kodu, oni nisu obični HTML elementi. Iako izgledaju kao HTML, nalaze se unutar .js
datoteke i predstavljaju specijalan JSX kod.

Ovo je važno razumeti, jer JSX kod nije isto što i HTML markup koji bi se pisao direktno u
.html datotekama. Umesto toga, JSX služi kao most između intuitivne sintakse slične HTML-u
i JavaScript-a koji stoji u pozadini, omogućavajući React-u da efikasno manipuliše DOM-om i
renderuje korisnički interfejs.

Zbog toga su elementi poput <div> i <h2>, koje se vide u svim ovim primerima, na kraju
takođe samo React komponente. Međutim, to nisu komponente koje su programeri sami
kreirali, već su obezbeđene od strane React-a, tačnije, od strane ReactDOM. React pruža
ove osnovne komponente koje se ponašaju kao HTML elementi, ali su u stvari deo Reactovog virtuelnog DOM-a i služe kao most između JSX koda i stvarnog DOM-a koji pretraživač
prikazuje.

1.1 Primer za komponente
PRIMER KOMPONENTE
Primer izgleda react komponente
Primer jedne komponente može se videti sa desne strane gde je prikazana komponenta
SubmitButton. Ovakav deo koda bi se nalazio sačuvan u posebnoj datoteci, na primer,
nazvanoj SubmitButton.js, koja bi se nalazila unutar foldera /components, smeštenog u /src
folderu React projekta. Nakon što je komponenta definisana u ovoj datoteci, može se uvesti
u druge komponente koje je zahtevaju. Na primer, sledeća komponenta uvozi prethodno
definisanu komponentu SubmitButton i koristi je u svom return iskazu kako bi prikazala
dugme za slanje.

1. Na početku, SubmitButton komponenta se uvozi pomoću import naredbe. Ovde je
navedena relativna putanja do datoteke gde je SubmitButton komponenta definisana
(./components/SubmitButton).
2. U return delu funkcije App, SubmitButton komponenta se koristi kao JSX element.
3. Kada korisnik klikne na dugme unutar SubmitButton komponente, ono će
promeniti svoj tekst iz "Submit" u "Loading…".

7

Poglavlje 1 Komponente

Ovaj pristup organizaciji koda u React projektima olakšava ponovno korišćenje komponenti i
održavanje projekta, jer se svaka komponenta nalazi u svojoj datoteci i može se jednostavno
uvesti gde god je potrebna.

Slika 1.1.1 SubmitButton komponenta [Izvor:[1]]

Slika 1.1.2 Uvoz i korišćenje SubmitButton komponente u App [Izvor:[1]]

PRIMER KOMPONENTE #2
Primer izgleda react komponente #2
Import iskazi prikazani u ovim primerima su standardni JavaScript import iskazi sa jednim
specifičnim dodatkom: ekstenzija datoteke (.js u ovom slučaju) često može biti izostavljena
u većini React projekata, poput onih kreiranih putem vite. U JavaScriptu, import i export
su ključne reči koje omogućavaju modularnost koda, omogućavajući razdvajanje povezanog
koda u više datoteka. Promenljive, konstante, klase ili funkcije mogu biti izvožene putem
export ili export default, što omogućava njihovu upotrebu u drugim datotekama kada se tamo
uvezu. Važno je napomenuti da su komponente prikazane u ovim primerima pojednostavljene
i sadrže funkcionalnosti koje možda još nisu obrađene, poput useState()hook-a. Ipak, osnovna
8

Poglavlje 1 Komponente

ideja o postojanju samostalnih građevinskih blokova, odnosno komponenti, koje se mogu
kombinovati kako bi se izgradili složeniji korisnički interfejsi, trebalo bi da bude jasna. Ovaj
modularni pristup omogućava programerima da lakše održavaju i skaliraju aplikacije, jer
se svaki deo koda može razvijati, testirati i ažurirati nezavisno od drugih delova. Takođe,
ponovna upotreba komponenti doprinosi doslednosti u dizajnu i funkcionalnosti aplikacije.
Kada se radi sa React-om, postoje dva alternativna načina za definisanje komponenti:
• Komponente bazirane na klasama (ili "klasne komponente"): Ove komponente su
definisane pomoću ključne reči class. Klasne komponente su bile dominantne u ranijim
verzijama React-a, naročito pre nego što su uvedeni React hooks. Ove komponente
nasleđuju iz React.Component klase i koriste render() metodu za povratak JSX-a koji
opisuje kako bi korisnički interfejs trebalo da izgleda.
• Funkcionalne komponente: Ove komponente su definisane pomoću regularnih JavaScript
funkcija. Funkcionalne komponente su postale veoma popularne, posebno nakon
uvođenja React hooks-a, kao što su useState i useEffect, koji omogućavaju funkcionalnim
komponentama da koriste stanje i druge React funkcionalnosti koje su ranije bile
dostupne samo u klasnim komponentama. React je uveo funkcionalne komponente od
verzije 16.8 2018. godine.
Na ovom predmetu koristićemo funkcionalne komponente. Funkcionalne komponente su
izgrađene kao JavaScript funkcije. Kao React programer, možete se sresti sa starim kodom
koji je napravljen pomoću klasnih komponenti. Potrebno je odabrati i koristiti jedan od ova
dva pristupa, jer React očekuje da komponente budu ili funkcije ili klase. Iako su klasne
komponente i dalje potpuno podržane, funkcionalne komponente omogućavaju lakše pisanje
i održavanje koda, posebno za jednostavne i srednje složene komponente i zato se uglavnom
samo one koriste.

9

Poglavlje 2
JSX
JSX - RAZUMEVANJE POJMA
Razumevanje pojma JSX-a
JSX je funkcionalnost koja nije deo standardnog JavaScript-a. Ono što može biti zbunjujuće
jeste to što JSX nije ni direktno deo React biblioteke. Umesto toga, JSX je sintaktičko
pojednostavljenje koje omogućava proces izgradnje (build workflow) koji je deo celokupnog
React projekta. Kada se pokrene razvojni web server putem komandenpm start ili kada se
gradi React aplikacija za produkciju putem komande npm run build, pokreće se proces koji
transformiše JSX kod nazad u regularne JavaScript instrukcije. Kao programer, ne dolazi se u
direktan kontakt sa tim finalnim instrukcijama, ali React biblioteka ih prima i evaluira kako bi
renderovala korisnički interfejs.

Ovaj proces omogućava programerima da pišu kod koji izgleda vrlo slično HTML -u, ali
koji zapravo koristi snagu JavaScript -a i React -a za dinamično upravljanje korisničkim
interfejsom. JSX pruža intuitivniji i efikasniji način za definisanje komponenti i njihovog
izgleda, dok se sve složene transformacije obavljaju u pozadini.

JSX je, dakle, most između intuitivne, HTML-olike sintakse i snage JavaScript-a,
omogućavajući programerima da pišu komponentni kod na način koji je lako razumljiv i
održiv. Ispod haube, sav JSX kod se prevodi u JavaScript instrukcije koje manipulišu DOMom. Ova kombinacija omogućava jednostavnost u pisanju koda, dok istovremeno koristi moć
JavaScript-a za dinamičko upravljanje korisničkim interfejsima.

REACT FRAGMENT
Objašnjenje fragmenta
Pošto
je
JSX
samo
sintaktički
dodatak
koji
se
transformiše
u
poziveReact.createElement(),postoje neki ključni koncepti i pravila koja je važno razumeti:

1. JSX elementi su na kraju obične JavaScript vrednosti (preciznije, funkcije). Iako JSX
elementi izgledaju kao HTML, React ih tretira kao JavaScript vrednosti. Oni su zapravo
JavaScript funkcije koje se pozivaju kako bi se generisali odgovarajući elementi
korisničkog interfejsa.

10

Poglavlje 2 JSX

2. JSX elementi podležu istim pravilima kao i sve druge JavaScript vrednosti. Kao i sve
JavaScript vrednosti, JSX elementi mogu biti dodeljeni promenljivama, prosleđeni kao
argumenti funkcijama ili vraćeni iz funkcija.
3. Kada se očekuje jedna vrednost, mora postojati samo jedan JSX element. Na
primer, kada se koristi return unutar React komponente, potrebno je vratiti samo
jedan JSX element. Ako postoji potreba da se vrati više elemenata, oni moraju biti
ugnježdeni unutar jednog zajedničkog roditeljskog elementa, poput <div> ili React
fragmenta (<>...</>). Ovo pravilo proizlazi iz činjenice da return očekuje jednu
vrednost, pa je neophodno da se na tom mestu nalazi samo jedan JSX element.
Razumevanje ovih koncepata omogućava efikasnije pisanje React koda, pružajući bolju
kontrolu nad strukturom i organizacijom korisničkog interfejsa.
Kada je potrebno vratiti susedne elemente, kao što je prikazano u ovim primerima, koristi
se posebna vrsta obuhvatne komponente: React Fragment. To je ugrađena komponenta
koja omogućava vraćanje ili definisanje susednih JSX elemenata bez potrebe za dodatnim
HTML elementima, poput <div>. React Fragment služi kao praktično rešenje koje pomaže u
održavanju čitljivosti i organizacije koda, dok istovremeno omogućava fleksibilno grupisanje
elemenata.

Slika 2.1.1 Primer za ReactFragment

PRIKAZ DINAMIČKOG SADRŽAJA
Objašnjenje prikaza dinamičkog sadržaja
Do sada je u svim primerima sadržaj koji je vraćen bio statičan. Na primer, sadržaj poput
<p>Hello World!</p> predstavlja statičan sadržaj koji se nikada ne menja; uvek će
prikazivati paragraf sa tekstom "Hello World!".
Ovaj primer tehnički još uvek proizvodi statičan izlaz, jer se mojeIme nikada ne menja;
međutim, već se može uočiti sintaksa za prikazivanje dinamičkog sadržaja kao deo JSX koda.
Otvorene i zatvorene vitičaste zagrade {…} koriste se za ubacivanje JavaScript izraza (kao
što je ime promenljive ili konstante, kao u ovom slučaju) unutar JSX -a.
Unutar tih vitičastih zagrada možete staviti bilo koji validan JavaScript izraz. Na primer,
možete pozvati funkciju (npr. {getMojeIme()}) ili izvesti jednostavne inline kalkulacije (npr.
{1 + 1}).

11

Poglavlje 2 JSX

Međutim, ne mogu se koristiti složeni izrazi poput petlji ili if između tih vitičastih zagrada.
I ovde se primenjuju standardna JavaScript pravila: prikazuje se (potencijalno) dinamička
vrednost, stoga je dozvoljeno sve što proizvodi jednu vrednost na tom mestu.

Slika 2.1.2 Prikaz dinamičkog sadržaja

2.1 Primer JSX vs JavaScript
PRIMER: JSX VS JAVASCRIPT
Prikaz razlike između JSX i JavaScripta
JSX kod:

Slika 2.2.1 JSX kod u Reactu

JavaScript kod:

Slika 2.2.2 JSX sa slike 3.1 preveden u JavaScript

PRIMER: JSX VS JAVASCRIPT OBJAŠNJENJE
Pojašnjenje primera iz prethodne sekcije
12

Poglavlje 2 JSX

Pošto se sav JSX kod na kraju transformiše u nativne JavaScript metode, moguće je graditi
React aplikacije i korisničke interfejse koristeći React bez upotrebe JSX-a. Iako je JSX često
preferirani način zbog svoje intuitivne i čitljive sintakse, nije obavezno koristiti ga. Umesto
toga, moguće je direktno pisati React kod koristeći JavaScript metode, poput
React.createElement(), kako bi se kreirale komponente i struktura korisničkog interfejsa. Ovaj
pristup pruža veću kontrolu i fleksibilnost, iako može biti manje čitljiv i intuitivan u poređenju
sa JSX-om.

Iako je moguće koristiti React bez JSX -a, JSX se i dalje preferira zbog svoje čitljivosti i sličnosti
sa standardnim HTML-om, što ga čini intuitivnijim i lakšim za održavanje. JSX dodaje sloj
apstrakcije koji značajno pojednostavljuje razvoj aplikacija, omogućavajući programerima da
pišu kod koji je lako razumljiv i organizovan. Ispod haube, JSX se prevodi u JavaScript kod
koji React koristi za manipulaciju DOM-om, ali ovaj dodatni sloj apstrakcije omogućava brži
i efikasniji razvoj, bez potrebe za upravljanjem kompleksnostima koje dolaze sa direktnim
korišćenjem JavaScript metoda.

Zbog toga React programeri obično koriste JSX. To je izuzetna funkcionalnost koja čini
izgradnju korisničkih interfejsa sa React-om znatno prijatnijom i efikasnijom. Ipak, važno je
razumeti da JSX nije ni HTML ni obična JavaScript funkcionalnost. Umesto toga, predstavlja
neku
vrstu
sintaktičkog
šlaga
koji
se
u
pozadini
transformiše
u
pozive
React.createElement(...).

JSX omogućava da kod bude čitljiviji i bliži onome što bi se očekivalo u HTML-u, čime se
značajno pojednostavljuje razvoj i održavanje kompleksnih korisničkih interfejsa. Iako React
može funkcionisati i bez JSX-a, u većini slučajeva JSX će biti preferirani izbor jer značajno
poboljšava iskustvo razvoja, omogućavajući brži i intuitivniji rad.

13

Poglavlje 3
Kombinovanje komponenti
VIŠESTRUKO ISKORISTIVE KOMPONENTE I PROPS
Jedna od glavnih prednosti pristupa korišćenjem komponenti je da se
jednom napisane komponente mogu više puta koristiti
Kada se piše običan HTML kod, koriste se ponovo upotrebljivi HTML elementi koji se
konfigurišu sa različitim sadržajem ili atributima. Na primer, postoji jedan HTML element <a>,
ali zahvaljujući atributu href i sadržaju unutar elementa, može se izgraditi neograničen broj
različitih anchor elemenata koji vode ka različitim resursima.
Ukoliko napravimo komponentu Student možemo joj kroz atribute ime, prezime i brojIndeksa
proslediti koristeći props parametar. Props parametar je specijalna vrednost koju sam React
prosleđuje u svaku funkciju komponente
Za ime parametra komponente, može biti izabrano i neko drugo ime, ali props se standardno
koristi jer je to uobičajena praksa i ime koncepta. Da bi se razumeo ovaj koncept, važno je
znati da te funkcije komponente ne poziva programer direktno u svom kodu, već ih React
poziva umesto njega. Kada React poziva te funkcije, može im proslediti dodatne argumente
tokom pozivanja.
Jedan od tih dodatnih argumenata je props. React prosleđuje ovaj argument svakoj funkciji
komponente, bez obzira na to da li je programer definisao taj parametar u funkciji
komponente. Međutim, ako parametar props nije definisan u funkciji komponente, podaci iz
props objekta neće biti dostupni u toj komponenti. Argument props uvek će sadržati objekat,
jer React prosleđuje objekat kao vrednost za ovaj argument.

14

Poglavlje 3 Kombinovanje komponenti

Slika 3.1 Višestruko iskoristiva komponenta Student

CHILDREN PROP
Specijalni prop koji prosleđuje sadržaj komponente
Specijalni children prop je dodatno svojstvo koje React automatski dodaje u props objekat
kada ga prosleđuje funkcijama komponente.

Svojstvo children obuhvata sadržaj koji se nalazi između otvorenog i zatvorenog taga
komponente. U ranijim primerima, gde su komponente bile samozatvorene, poput <Student
ime="…" prezime="…" />, sadržaj između oznaka komponente nije bio prisutan, a svi podaci
su bili prosleđeni putem atributa.
Način prosleđivanja children najbolje se vidi na primeru desno. Ovde se podaci koji su pre
bili prosleđeni kao atributi student komponenti prosleđuju kao zasebne komponete. Svaka
od ovih komponenti može se nalaziti u zasebnom fajlu i na taj način značajno rasteretiti
komponentu Student. Takođe, slika studenta sada više nije neraskidivi deo studenta već se
veoma jednostavno može uključiti u neku drugu komponentu ili projekat na taj način zančajno
urzavajući razvoj i uniformnost interfejsa.

Ne postoji strogo pravilo koje određuje koje komponente treba da koriste props, a koje ne.
Ovo zavisi od iskustva i specifične uloge komponente.

15

Poglavlje 3 Kombinovanje komponenti

Na primer, može postojati opšta komponenta Header koja prikazuje statičan zaglavlje sa
logoom, naslovom i slično.

Slika 3.2 Primer za children prop

PROSLEĐIVANJE PROPSA
Detaljniji opis mogućnosti prosleđivanja
function Link({children}) {
return <a target="_blank" rel="noopener noreferrer">{children}</a>;
}

Gde ova komponenta Link dodaje specifične atribute (target="_blank" i rel="noopener
noreferrer") na standardni <a> element, ali istovremeno omogućava prosleđivanje sadržaja
kroz children, Link komponente. Link bi u ovom slučaju bila tzv. HOC ( Higher Order
Component - komponenta višeg nivoa)
Ako bi kasnije bilo potrebno da se proslede dodatni atributi ili props na <a> element. Na
primer, da se doda href atribut ili neki drugi. U takvoj situaciji, spread operater dolazi do
izražaja. Umesto da ručno navodi svaki prop koji želi da prosledi, može se koristiti spread
operter na props-ovima kako bi automatski prosledio sve dodatne props-ove koji su definisani
na Link komponenti direktno na <a> element:

16

Poglavlje 3 Kombinovanje komponenti

function Link({children, ...props}) {
return <a {...props} target="_blank" rel="noopener noreferrer">{children}</a>;
}

Iz do sada izloženog jasno je da je moguće podatke kroz props prosleđivati kroz celo stablo
komponenti koje može imati nekada i desetine nivoa. ovo međutim nije dobra praksa. U
takvim slučajevima se umesto propsa koristi globano stanje. O ovome će biti više reči u nekoj
od narednih lekcija.

17

Poglavlje 4
Pokazne vežbe
POKAZNA VEŽBA
Pokazna vežba - Komponente u React-u
Na vežbama Asistent prikazuje proces rada sa React komponentama. Prvo je potrebno
napraviti projekat u kojem se zatom unose komponente.
Potrebno je pozvati ostale komponente iz App komponente i demonstrirati kako se radi sa
komponentama.
import Pozdrav from './components/Pozdrav';
import Student from './components/Student';
import Omotac from './components/Omotac';
import Lista from './components/Lista';
import Dugme from './components/Dugme';
import StilizovaniDiv from './components/StilizovaniDiv';
import './App.css'
function App() {
return(
<>
<Pozdrav />
{/*1. Dodajte studenta sa vašim imenom i prezimenom*/}
{/*2. Dodajte broj indeksa u komponentu Student*/}
<Student ime="Petar" prezime="Petrović" />
<Student ime="Ana" prezime="Jovanović" />
<Omotac>
<h2>Unutar Omotaca</h2>
<p>Ovo je paragraf unutar omotača.</p>
</Omotac>
<ul>
<Lista />
</ul>
<Dugme tekst="Klikni me!" />
<Dugme tekst="Pritisni me!" />
<StilizovaniDiv stil={{ color: 'red', fontSize: '20px' }} />
<StilizovaniDiv stil={{ color: 'blue', fontSize: '15px' }} />
</>)

18

Poglavlje 4 Pokazne vežbe

}
export default App

POKAZNA VEŽBA - KOMPONENTE
Komponente koje treba pozvati u glavnoj App komponenti
function Dugme(props) {
return <button>{props.tekst}</button>;
}
export default Dugme;
function Lista() {
return (
<>
<li>Jabuka</li>
<li>Banana</li>
<li>Kruška</li>
</>
);
}
export default Lista;
function Omotac(props) {
return <div>{props.children}</div>;
}
export default Omotac;
function Pozdrav() {
return <h1>Zdravo, dobrodošli u React!</h1>;
}
export default Pozdrav;
function StilizovaniDiv(props) {
return <div style={props.stil}>Ovo je stilizovan div!</div>;
}
export default StilizovaniDiv;
function Student(props) {
return <p>{props.ime} {props.prezime}</p>;
}

19

Poglavlje 4 Pokazne vežbe

export default Student;

20

Poglavlje 5
Zaključak
REZIME
• React koristi komponente: To su višekratno upotrebljivi građevinski blokovi koji se
kombinuju kako bi definisali konačni korisnički interfejs.
• Komponente moraju vraćati renderabilni sadržaj: To je obično JSX kod koji definiše HTML
kod koji će na kraju biti prikazan.
• React obezbeđuje mnogo ugrađenih komponenti: Pored posebnih komponenti kao što je
<>...</>, postoje komponente za sve standardne HTML elemente. JSX nije ni HTML ni
standardna JavaScript funkcionalnost: To je sintaktički dodatak koji omogućavaju build
workflow-ovi koji su deo svih React projekata. JSX kod može se zameniti pozivima
React.createElement(...): Međutim, to dovodi do znatno nečitljivijeg koda, pa se obično
izbegava.
• JSX elementi ne smeju biti susedni na mestima gde se očekuju pojedinačne vrednosti: Na
primer, direktno posle return ključne reči mora biti samo jedan JSX element.
• JSX elementi moraju biti samozatvarajući ako nemaju sadržaj između otvarajuće i
zatvarajuće oznake. Dinamički sadržaj može se prikazati pomoću vitičastih zagrada: Na
primer, <p>{Text}</p>.
• UI kod u većini React projekata je podeljen na mnoge komponente: Ove komponente se
eksportuju i importuju kako bi se ponovo kombinovale u složenije interfejse.

LITERATURA
1. React key concepts: Consolidate your knowledge of React’s core features. Schwarzmuller,
M. . Packt Publishing Ltd. (2022)

21

Događaji i stanje u React-u
Oznaka predmeta:
Naziv predmeta:
Predavanje:
Predavači:
Školska godina:

IT354
Veb sistemi 1
#4
Doc. dr Mladen Opačić - Beograd
Msc. Nikola Dimitrijević - Niš
2024/2025. jesenji semestar

Događaji u Reactu
Događaji su sastavni deo React biblioteke, oni su takođe i sastavni deo običnog
JavaScript-a.
Razlika između događaja u JavaScriptu i događaja u Reactu ogleda se u tome što
je React događaj napravljen tako da koristi takozvane sintetičke događaje (eng.
Syntetic Event).
Za razliku od običnog događaja koji zavisi od konkretnog internet pregledača
sintetički događaji su omotači oko nativnih događaja što im omogućuje da
funkcionišu isto u svim internet pregledačima.
Takođe, React koristi pooling za optimizaciju performansi. Što znači da se nakon
što se događaj završi, objekat događaja može resetovati i ponovo koristiti, čime
se smanjuje broj instanci događaja koje se kreiraju.

2
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Događaji u Reactu #2
Biće obrađen JSX, specifičan sintaksni dodatak za JavaScript, koji omogućava
jednostavnije i intuitivnije kreiranje komponenti.
Detaljno je opisano kako treba da se koriste komponente i JSX, kako bi se
postavili temelji za izradu, osnovnih React aplikacija.
Studenti će biti osposobljeni da kreiraju funkcionalne i prilagodljive korisničke
interfejse koristeći React.
Sintaksa korišćenja događaja je veoma slična sintaksi običnog JavaSctipt
događaja.

<input placeholder="Vaš imejl" type="email" onBlur={evaluateEmail} />

3
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Događaji u Reactu #3
Razlika u odnosu na JavaScript event je u tome što se za React event koristi tzv.
camelCase pa je onblur iz JavaScripta postao onBlur u Reactu. Njemu je
dodeljena funkcija koja će obraditi događaj sa ={evaluateEmail}

4
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer događaja detaljno
Ono što se prvo primeti je onBlur događaj. onBlur je događaj u Reactu (i
JavaScriptu) koji se aktivira kada element izgubi fokus.
Kada korisnik klikne van elementa ili se prebacuje na drugi element u okviru
aplikacije, onBlur će se trigerovati.
onBlur se najčešće koristi u formama ili input poljima, gde je važno obraditi
situacije kada korisnik završi unos i prelazi na drugi element.
onBlur prop je dodat ugrađenom input elementu.
Ovaj prop je dostupan u React-u, baš kao što su svi osnovni HTML elementi
(poput <input> i <p>) dostupni kao komponente u React-u.

5
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer događaja detaljno #2
<input> element je polje za unos email-a. Ima placeholder tekst "Vaš imejl"
tip email
onBlur={evaluateEmail} označava da će se funkcija evaluateEmail pozvati kad
korisnik napusti polje za unos.
<p> element prikazuje sadržaj errorMessage.
Ako postoji poruka o grešci, biće prikazana ispod polja za unos email-a.
Ako je errorMessage prazan string, <p> element neće prikazivati ništa.

6
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer događaja detaljno #3
Funkcija evaluateEmail se poziva kada korisnik napusti (onBlur) polje za unos
email adrese.
Funkcija dobija vrednost unetog email-a (enteredEmail) iz događaja event.
Funkcija proverava da li je uneseni email prazan (enteredEmail.trim() === ‘‘)
da li sadrži karakter @ koji je neophodan za validan email
(!enteredEmail.includes(‘@‘)).

7
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Događaj sa parametrima
Ukoliko je eventu potrebno proslediti neki parametar poziv se mora obaviti preko anonimne
funkcije kako se funkcija ne bi automatski izvršila:
<input placeholder="Vaš imejl" type="email" onBlur={ () => evaluateEmail("Moj parametar")} />
Na ovaj način smo prosledili strind "Moj parametar" ali smo i zaklonili event objekat koji se po
default-u prosleđuje, pa je ako želimo da mu pristupimo moramo ga proslediti ručno sa:

<input placeholder="Vaš imejl" type="email" onBlur={ (event) => evaluateEmail(event,"Moj
parametar")} />

8
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Više događaja na jednom elementu
Sintaksa za upravljanje događajima je
lako čitljiva kada je više od jednog
događaja dodeljeno elementu.
Ponekad su dva ili tri dodeljena jednom
elementu.

Imperativni kod je teško koristiti čak i za
jedan upravljač događajima (eng. handler), a
kamoli za nekoliko njih.
Kada elementu treba više upravljača, to je
samo još jedan atribut u JSX-u.

9
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Inline upravljanje događajima
Tipičan pristup dodeljivanju upravljača
događajima svojstvima JSX-a je korišćenje
imenovane funkcije kao na prošlim
primerima.
Ponekad je jednostavnije da se koristi inline
funkcija, gde se funkcija definiše kao deo
samog JSX-a.
Glavna svrha inline definisanja događaja na
ovaj način je kada postoji nepromenljiva
vrednost parametra koju treba da proslediti
drugoj funkciji.
U ovom primeru, poziva se console.log sa
stringom "kliknuto".
10
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje syntetic event objekata
Kada dodelite funkciju osluškivača događajima DOM elementu koristeći nativnu
funkciju addEventListener, povratna funkcija (callback) će primiti argument
događaja (event).
Funkcije osluškivača događaja u React-u takođe dobijaju argument događaja, ali
to nije standardna instanca događaja.
Ona naziva SyntheticEvent i predstavlja jednostavan omotač za nativne instance
događaja.
Sintetički događaji imaju dve svrhe u React-u:
• Obezbeđuju konzistentan interfejs događaja, normalizujući razlike među
pretraživačima
• Sadrže informacije neophodne da bi propagacija događaja funkcionisala
11
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje syntetic event objekata #2
Kada DOM element, koji je deo React komponente, aktivira događaj, React će
obraditi taj događaj zato što postavlja svoje sopstvene osluškivače za njih.
Zatim će ili kreirati novi sintetički događaj ili iskoristiti jedan iz svog pula
sintetičkih događaja.
Objekat događaja u React-u ima svojstva i metode slične onima u nativnim
JavaScript događajima.

12
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

SynteticEvent Objekat - metode
SyntheticEvent objekat u React-u pruža skup standardnih metoda i svojstava koja
olakšavaju rad sa događajima na konzistentan način, bez obzira na pretraživač.
Metode:
preventDefault() – sprečava podrazumevano ponašanje (slanje forme)
stopPropagation() – sprečava propagaciju kroz DOM
persist() – čuva podatka o događaju
isDefaultPrevented() – true ako je sprečeno podrazumevano ponašanje
isPropagationStopped() – true ako je sprečena propagacija
isTrusted – true ako je event pokrenuo korisnik ili false ako je sistem pokrenuo

13
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

SynteticEvent Objekat – metode primer

14
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

SynteticEvent Objekat – atributi
target - Element na kojem je događaj pokrenut
type - Tip događaja, npr. 'click', 'submit', 'change'
currentTarget - Trenutni element koji aktivno obrađuje događaj
nativeEvent - Pruža pristup nativnom DOM događaju koji je React presreo i
enkapsulirao u SyntheticEvent.
bubbles - Vraća true ako događaj podržava bubbling (širenje prema gore kroz
DOM hijerarhiju).
defaultPrevented - Vraća true ako je pozvana metoda preventDefault() na tom
događaju.
timestamp - Vreme kada je događaj kreiran (u milisekundama).
15
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

SynteticEvent Objekat – atributi primer

16
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Razumevanje event pooling-a
Jedan od izazova obuhvatanja nativnih instanci događaja je to što može
prouzrokovati probleme sa performansama. Svaki sintetički omotač događaja
koji se kreira moraće u nekom trenutku biti očišćen od strane garbage
collector-a, što može biti skupo u smislu procesorske snage.
Ako aplikacija obrađuje samo nekoliko događaja, ovo nije previše važno.
Ako aplikacija ima mnogo događaja, postaje problematično ako React mora
stalno da kreira nove sintetičke instance događaja.

17
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Razumevanje event pooling-a #2
React rešava ovaj problem korišćenjem pula instanci sintetičkih događaja
(instance pool).
Kada se događaj pokrene, uzima se instanca iz pula i popunjavaju se njena
svojstva.
Kada upravljač događajima završi sa izvršavanjem, sintetička instanca događaja se
vraća nazad u pul.
Ovaj pristup sprečava da garbage collector često radi kada se pokreće mnogo
događaja.
React reciklira već korišćene instance sintetičkih događaja pa tako ne mora da
stalo pravi nove i ne mora da se pokreće garbage collector.

18
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stanje u React-u #1
Koncept stanja ključni je koncept u React razvojnom okviru pa će mu zato biti
posvećeno puno pažnje. U primeru sa početka lekcije u kojem su obrađeni
događaji mogla se videti sledeća linija koda:
const [errorMessage, setErrorMessage] = useState(’’);
U ovoj liniji se vidi korišćenje useState hook-a.
Hook-ovi (eng. Hook - kuka, udica)

19
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stanje u React-u #2
Hook-ovi predstavljaju funkcije koje postoje van komponenti, a koje su povezane
sa virtuelnim DOM-om.
Virtuelni DOM je obavešten o svakoj promeni poruke o grešci i ponovo će se
izrenderovati kada god se stanje promeni.
Poziv funkcije sa prosleđenom početnom vrednošću useState(‘‘)
Povratna vrednost funkcije se dodeljuje dvema konstantama errorMessage i
setErrorMessage putem destruktuiranja niza koji se dobija kao povratna
vrednost useState funkcije.
errorMessage je reaktivno stanje, a setErrorMessage je funkcija koja se koristi za
njegovo menjanje.

20
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stanje u React-u #3
Ove vrednosti mogu biti i drugačije nazvane, ali je konvencija da se funkciji koja
menja stanje uvek dodaje set ispred.
Ako bi imali promenljivu stanje onda bi za nju napisali:
const [stanje, setStanje] = useState('Početno stanje’);
Razlog zašto je to ovako napravljeno je u tome što React mora biti obavešten kad
god postoji stanje koje utiče na promene u korisničkom interfejsu (UI)
U suprotnom, vidljivi korisnički interfejs se uopšte ne menja, čak i u slučajevima
kada bi trebalo.
21
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stanje u React-u #4
React ne prati obične promenljive i promene njihovih vrednosti, pa one nemaju
uticaj na stanje korisničkog interfejsa.
Funkcija za ažuriranje stanja koju React izlaže (drugi element niza koji vraća
useState()) pokreće unutrašnji efekat ažuriranja korisničkog interfejsa.
Ova funkcija ne samo da postavlja novu vrednost, već i obaveštava React da je
vrednost stanja promenjena i da korisnički interfejs (virtuelni DOM) možda
treba da se ažurira.
React ne samo da ažurira vrednost koju skladišti interno, već i proverava
korisnički interfejs i ažurira ga kad je potrebno.
Ažuriranja korisničkog interfejsa mogu uključivati bilo šta, od jednostavnih
promena teksta do potpunog uklanjanja i dodavanja različitih DOM elemenata.
22
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stanje u React-u #5
Važno je shvatiti i imati na umu da će React ponovo izvršiti (re-evaluirati (ponovo
napraviti objekat)) funkciju komponente ako je funkcija za ažuriranje stanja
pozvana u funkciji komponente ili u funkciji neke roditeljske komponente.
Vrednost stanja vraćena od useState() (tj. prvi element niza) zato može biti
konstanta, iako možete dodeliti nove vrednosti pozivanjem funkcije za
ažuriranje stanja (drugi element niza).
Pošto se cela funkcija komponente ponovo izvršava, useState() se takođe ponovo
poziva (jer se sav kod funkcije komponente ponovo izvršava) i zato React vraća
novi niz sa dva nova elementa.
Prvi element niza je i dalje trenutna vrednost stanja.

23
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stanje u React-u #6
Mogu se skladištiti i ažurirati vrednosti referenci, kao što su objekti i nizovi.
Možete se čak i promeniti tip vrednosti u toku izvršavanja (kao što može i u
običnom JavaScript-u).
Sasvim je u redu da skladišteni broj kao početna vrednost stanja kasnije postane
string.
Kao i u običnom JavaScript-u, treba osigurati da program pravilno rukuje ovim
ponašanjem, iako nema tehnički nikakvih prepreka u promeni tipova.

24
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rad sa više vrednosti stanja
Za bilo šta osim veoma jednostavnih veb aplikacija ili korisničkih interfejsa, biće
potrebno više vrednosti stanja.
Korisnici mogu uneti ne samo svoj email, već i napr. korisničko ime ili adresu i sl.
Postoji mnogo vrednosti koje se često menjaju i čije promene treba da se odraze
u korisničkom interfejsu

25
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rad sa više vrednosti stanja
Na sledećem primeru prikazana je
komponenta koja treba da upravlja i
vrednošću unetom od strane
korisnika u polje za email i vrednošću
unetom u polje za lozinku.
Pošto dva polja za unos koja sadrže
različite vrednosti, ima i dve
vrednosti stanja: uneti email i uneta
lozinku.

26
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rad sa više vrednosti stanja #2
Postoje dva glavna načina upravljanja višestrukim vrednostima stanja.
Korišćenje više delova stanja (više vrednosti stanja): Za svaki zaseban deo stanja
može se koristiti zaseban useState() Hook. Na primer, može postojati jedan
useState() za email i jedan za lozinku.
Korišćenje jednog velikog objekta stanja: Alternativno, može se koristiti jedan
useState() Hook sa objektom koji sadrži više atributa. Svaki atribut objekta
predstavlja jedan deo stanja.

27
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje više delova stanja
U React-u se može upravljati
višestrukim vrednostima stanja
jednostavnim pozivanjem
useState() više puta u funkciji
komponente.
U ovom primeru, dva dela stanja se
kreiraju pozivanjem useState()
dva puta. Na taj način, React
interno registruje i upravlja dve
vrednosti stanja. Ove dve
vrednosti mogu se čitati i ažurirati
nezavisno jedna od druge.

28
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje više delova stanja #2
Može se registrovati neograničen broj delova stanja u jednoj komponenti.
Prednosti i mane ovog pristupa:
• Prednost upravljanja višestrukim vrednostima stanja na ovaj način je ta što se
mogu ažurirati nezavisno. Ako korisnik unese novu email adresu, potrebno je
samo ažurirati tu vrednost stanja za email.
• Nedostatak može biti u tome što više delova stanja i samim tim više useState()
poziva može dovesti do mnogo linija koda, što bi moglo opteretiti
komponentu. Kao što je već pomenuto, trebalo bi da pokušati da se velike
komponente podele u više manjih komponenti kako bi kod bio lakši za
održavanje.

29
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje objekta stanja
Umesto pozivanja useState() za svaki
deo stanja, može se koristiti jedan
veliki objekt stanja koji kombinuje sve
različite vrednosti stanja.
U ovom primeru, useState() se poziva
samo jednom, a početna vrednost
koja se prosleđuje useState() je
JavaScript objekat. Ovaj objekat sadrži
dva svojstva: email i password.

30
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje objekta stanja #2
useState() i dalje vraća niz sa tačno dva elementa.
Prvi element vraćenog niza je sada samo objekat umesto stringa (kao što je bio u
ranijim primerima).
Kao što je već pomenuto, bilo koji validan JavaScript tip vrednosti može se
koristiti sa useState().
Prednosti i mane objedinjavanja stanja u jedan objekat:
• Prednost ovog pristupa je u tome što se centralizuju svi relevantni podaci u
jednom objektu, što može olakšati rad sa višestrukim povezanim vrednostima.
• Nedostatak je taj što ažuriranje jednog svojstva u objektu zahteva da se
ponovo postavi ceo objekat.

31
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje stanjem zasnovano na prethodnom stanju
Jedan od ključnih principa
upravljanja stanjem u
React-u je ispravno
ažuriranje stanja kada se
nova vrednost zasniva na
prethodnom stanju.
Ovo je važno jer, u složenijim
React aplikacijama, može
doći do istovremenih
ažuriranja stanja,
potencijalno pokrenutih iz
različitih izvora u različitim
trenucima.
32
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje stanjem zasnovano na prethodnom stanju
Ukoliko se ne koristiti preporučeni pristup, redosled ažuriranja stanja možda neće
biti očekivan, što može dovesti do grešaka u aplikaciji.
Kada se ažurira stanje koje zavisi od prethodnog stanja, preporučuje se da se
funkcija koja ažurira stanje (setState) poziva sa funkcijom kao argumentom.
Ta funkcija će primiti prethodno stanje kao argument, omogućavajući da se novo
stanje pravilno izračuna, kao na primeru desno.
U ovom primeru, setCounter prima funkciju kao argument. Ova funkcija prima
prethodnu vrednost brojača (prevCounter) i vraća novu vrednost (prevCounter
+ 1). React automatski poziva ovu funkciju i ažurira stanje na osnovu povratne
vrednosti.

33
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Dvosmerno povezivanje ("Two-Way Binding") u React-u
Dvosmerno povezivanje je koncept koji
se koristi kada imate izvor unosa
(obično <input> element) koji postavlja
neko stanje na osnovu korisničkog
unosa (na primer, pri promeni
događaja) i istovremeno prikazuje taj
unos.
U ovom primeru, NewsletterField
komponenta ne samo da čuva
korisnički unos (pri događaju
onChange), već i prikazuje unesenu
vrednost u <input> elementu putem
propa value.
34
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Dvosmerno povezivanje ("Two-Way Binding") u React-u #2
Dvosmerno povezivanje može izgledati kao da bi moglo izazvati beskonačnu
petlju, ali React to obrađuje i osigurava da se to ne dogodi.
Suština dvosmernog povezivanja je u tome da se vrednost i postavlja i čita iz istog
izvora.
Dvosmerno povezivanje je moćna tehnika koja omogućava da sinhronizaciju
stanja i korisničkog interfejsa na način koji obezbeđuje doslednost i ispravnost
koda.
To je posebno korisno u situacijama gde se vrednosti stanja mogu menjati iz više
izvora, i osigurava da korisnički interfejs uvek reflektuje trenutno stanje
aplikacije.

35
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izvođenje novih vrednosti iz postojećeg stanja
Često se postojeće vrednosti stanja
koriste kao osnova za izvođenje
nove, često složenije, vrednosti.
Na primer, može se izračunati
broj unetih karaktera i prikazati
te informacije korisniku, kao na
primeru desno.
U ovom primeru, dodata je nova
konstanta numChars, koja je
izvedena iz stanja userInput
pristupom svojstvu length na
stringu koji je sačuvan u
userInput stanju.
36
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izvođenje novih vrednosti iz postojećeg stanja
Kada se pozove funkcija za ažuriranje stanja (u ovom slučaju setUserInput), React
će ponovo evaluirati komponentu kojoj stanje pripada.
To znači da će funkcija komponente CharCounter ponovo biti pozvana od strane
React-a.
Sav kod unutar te funkcije će se zato ponovo izvršiti. Ovo objašnjava zašto je
numChars konstanta van inputHandler funkcije.
Pri svakom ponovnom renderovanju komponente, vrednost numChars će biti
ponovo izračunata na osnovu najnovijeg stanja userInput.
Ovo omogućava da se najnoviji broj karaktera pravilno prikaže svaki put kada se
stanje ažurira, bez potrebe za dodatnim pozivima ili komplikacijama unutar
inputHandler funkcije.
37
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Podizanje stanja
Podizanje stanja je često rešenje
kada postoje dve ili više
komponenti u React aplikaciji,
gde promena u jednoj
komponenti treba da utiče na
stanje u drugoj.
Ovo se postiže tako što se stanje
"podigne" do najbliže zajedničke
nadkomponente, koja zatim
upravlja tim stanjem i deli ga
putem props sa komponentama
koje ga koriste.

38
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Podizanje stanja
U primeru, Overview komponenta bi trebalo da prikaže uneti termin za pretragu,
ali taj termin je zapravo unet u drugoj komponenti SearchBar.
Da bi Overview mogla da prikaže termin za pretragu, mora da dobije pristup
stanju koje se nalazi u SearchBar.
Da bi se ovo rešilo, stanje je premešteno u zajedničku nadkomponentu, koja je u
ovom slučaju App. Na taj način, obe komponente (SearchBar i Overview) mogu
deliti isto stanje putem props.

39
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba

40
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Zadaci za rad kod kuće
Kreirajte komponentu s dva input polja (korisničko ime i lozinka) i postavi
zasebno stanje za svaki unos koristeći useState.
Kreirajte input polje sa onChange događajem koje ažurira stanje i prikazuje
uneseni tekst uživo.
Implementirajte funkcionalnost sa onMouseOver događajem koja će prikazati
dodatne informacije kada korisnik pređe preko elementa.
Kreirajte formu sa dva input polja (ime i prezime) i koristi jedan useState objekat
za upravljanje stanjem oba polja.
Kreirajte brojač klikova koji će povećavati broj u stanju svaki put kada korisnik
klikne na dugme.

41
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Zadaci za rad kod kuće
Napravite funkciju koja menja veličinu teksta kada se klikne na dugme, koristeći
stanje za čuvanje veličine.
Kreirajte komponentu koja koristi podizanje stanja da bi dve komponente delile
isto stanje kroz nadkomponentu.
Napravite komponentu sa više delova stanja (npr. ime, email, telefon) gde svaki
deo koristi zaseban useState poziv.
Implementirajte funkcionalnost za klik i dupli klik – Koristi dva različita događaja
na istom elementu: jedan za onClick i drugi za onDoubleClick, pri čemu svaki
izvršava različitu funkciju.
Implementiraj prebrojavanje karaktera unosa – Prikaži broj preostalih karaktera
do ograničenja, kao u aplikacijama za tekstualne poruke.
42
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stilizovanje u React-u
Oznaka predmeta:
Naziv predmeta:
Predavanje:
Predavači:
Školska godina:

IT354
Veb sistemi 1
#5
Doc. dr Mladen Opačić - Beograd
Msc. Nikola Dimitrijević - Niš
2024/2025. jesenji semestar

Kratka rekapitulacija događaja u Reactu
Događaji su sastavni deo React biblioteke, oni su takođe i sastavni deo običnog
JavaScript-a.
Razlika između događaja u JavaScriptu i događaja u Reactu ogleda se u tome što
je React događaj napravljen tako da koristi takozvane sintetičke događaje (eng.
Syntetic Event).
Za razliku od običnog događaja koji zavisi od konkretnog internet pregledača
sintetički događaji su omotači oko nativnih događaja što im omogućuje da
funkcionišu isto u svim internet pregledačima.
Takođe, React koristi pooling za optimizaciju performansi. Što znači da se nakon
što se događaj završi, objekat događaja može resetovati i ponovo koristiti, čime
se smanjuje broj instanci događaja koje se kreiraju.

2
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Događaji u Reactu #3
Razlika u odnosu na JavaScript event je u tome što se za React event koristi tzv.
camelCase pa je onblur iz JavaScripta postao onBlur u Reactu. Njemu je
dodeljena funkcija koja će obraditi događaj sa ={evaluateEmail}

3
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Više događaja na jednom elementu
Sintaksa za upravljanje događajima je
lako čitljiva kada je više od jednog
događaja dodeljeno elementu.
Ponekad su dva ili tri dodeljena jednom
elementu.

Imperativni kod je teško koristiti čak i za
jedan upravljač događajima (eng. handler), a
kamoli za nekoliko njih.
Kada elementu treba više upravljača, to je
samo još jedan atribut u JSX-u.

4
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

SynteticEvent Objekat - metode
SyntheticEvent objekat u React-u pruža skup standardnih metoda i svojstava koja
olakšavaju rad sa događajima na konzistentan način, bez obzira na pretraživač.
Metode:
preventDefault() – sprečava podrazumevano ponašanje (slanje forme)
stopPropagation() – sprečava propagaciju kroz DOM
persist() – čuva podatka o događaju
isDefaultPrevented() – true ako je sprečeno podrazumevano ponašanje
isPropagationStopped() – true ako je sprečena propagacija
isTrusted – true ako je event pokrenuo korisnik ili false ako je sistem pokrenuo

5
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

SynteticEvent Objekat – metode primer

6
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

SynteticEvent Objekat – atributi
target - Element na kojem je događaj pokrenut
type - Tip događaja, npr. 'click', 'submit', 'change'
currentTarget - Trenutni element koji aktivno obrađuje događaj
nativeEvent - Pruža pristup nativnom DOM događaju koji je React presreo i
enkapsulirao u SyntheticEvent.
bubbles - Vraća true ako događaj podržava bubbling (širenje prema gore kroz
DOM hijerarhiju).
defaultPrevented - Vraća true ako je pozvana metoda preventDefault() na tom
događaju.
timestamp - Vreme kada je događaj kreiran (u milisekundama).
7
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

SynteticEvent Objekat – atributi primer

8
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Razumevanje event pooling-a
Jedan od izazova obuhvatanja nativnih instanci događaja je to što može
prouzrokovati probleme sa performansama. Svaki sintetički omotač događaja
koji se kreira moraće u nekom trenutku biti očišćen od strane garbage
collector-a, što može biti skupo u smislu procesorske snage.
Ako aplikacija obrađuje samo nekoliko događaja, ovo nije previše važno.
Ako aplikacija ima mnogo događaja, postaje problematično ako React mora
stalno da kreira nove sintetičke instance događaja.

9
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Razumevanje event pooling-a #2
React rešava ovaj problem korišćenjem pula instanci sintetičkih događaja
(instance pool).
Kada se događaj pokrene, uzima se instanca iz pula i popunjavaju se njena
svojstva.
Kada upravljač događajima završi sa izvršavanjem, sintetička instanca događaja se
vraća nazad u pul.
Ovaj pristup sprečava da garbage collector često radi kada se pokreće mnogo
događaja.
React reciklira već korišćene instance sintetičkih događaja pa tako ne mora da
stalo pravi nove i ne mora da se pokreće garbage collector.

10
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kratka rekapitulacija stanja u React-u #1
Koncept stanja ključni je koncept u React razvojnom okviru pa će mu zato biti
posvećeno puno pažnje. U primeru sa početka lekcije u kojem su obrađeni
događaji mogla se videti sledeća linija koda:
const [errorMessage, setErrorMessage] = useState(“”);
U ovoj liniji se vidi korišćenje useState hook-a.
Hook-ovi (eng. Hook - kuka, udica)

11
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stanje u React-u #2
Hook-ovi predstavljaju funkcije koje postoje van komponenti, a koje su povezane
sa virtuelnim DOM-om.
Virtuelni DOM je obavešten o svakoj promeni poruke o grešci i ponovo će se
izrenderovati kada god se stanje promeni.
Poziv funkcije sa prosleđenom početnom vrednošću useState(‘‘)
Povratna vrednost funkcije se dodeljuje dvema konstantama errorMessage i
setErrorMessage putem destruktuiranja niza koji se dobija kao povratna
vrednost useState funkcije.
errorMessage je reaktivno stanje, a setErrorMessage je funkcija koja se koristi za
njegovo menjanje.

12
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stanje u React-u #3
Ove vrednosti mogu biti i drugačije nazvane, ali je konvencija da se funkciji koja
menja stanje uvek dodaje set ispred.
Ako bi imali promenljivu stanje onda bi za nju napisali:
const [stanje, setStanje] = useState('Početno stanje’);
Razlog zašto je to ovako napravljeno je u tome što React mora biti obavešten kad
god postoji stanje koje utiče na promene u korisničkom interfejsu (UI)
U suprotnom, vidljivi korisnički interfejs se uopšte ne menja, čak i u slučajevima
kada bi trebalo.
13
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stanje u React-u #4
React ne prati obične promenljive i promene njihovih vrednosti, pa one nemaju
uticaj na stanje korisničkog interfejsa.
Funkcija za ažuriranje stanja koju React izlaže (drugi element niza koji vraća
useState()) pokreće unutrašnji efekat ažuriranja korisničkog interfejsa.
Ova funkcija ne samo da postavlja novu vrednost, već i obaveštava React da je
vrednost stanja promenjena i da korisnički interfejs (virtuelni DOM) možda
treba da se ažurira.
React ne samo da ažurira vrednost koju skladišti interno, već i proverava
korisnički interfejs i ažurira ga kad je potrebno.
Ažuriranja korisničkog interfejsa mogu uključivati bilo šta, od jednostavnih
promena teksta do potpunog uklanjanja i dodavanja različitih DOM elemenata.
14
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stanje u React-u #5
Važno je shvatiti i imati na umu da će React ponovo izvršiti (re-evaluirati (ponovo
napraviti objekat)) funkciju komponente ako je funkcija za ažuriranje stanja
pozvana u funkciji komponente ili u funkciji neke roditeljske komponente.
Vrednost stanja vraćena od useState() (tj. prvi element niza) zato može biti
konstanta, iako možete dodeliti nove vrednosti pozivanjem funkcije za
ažuriranje stanja (drugi element niza).
Pošto se cela funkcija komponente ponovo izvršava, useState() se takođe ponovo
poziva (jer se sav kod funkcije komponente ponovo izvršava) i zato React vraća
novi niz sa dva nova elementa.
Prvi element niza je i dalje trenutna vrednost stanja.

15
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rad sa više vrednosti stanja
Na sledećem primeru prikazana je
komponenta koja treba da upravlja i
vrednošću unetom od strane
korisnika u polje za email i vrednošću
unetom u polje za lozinku.
Pošto dva polja za unos koja sadrže
različite vrednosti, ima i dve
vrednosti stanja: uneti email i uneta
lozinku.

16
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rad sa više vrednosti stanja #2
Postoje dva glavna načina upravljanja višestrukim vrednostima stanja.
Korišćenje više delova stanja (više vrednosti stanja): Za svaki zaseban deo stanja
može se koristiti zaseban useState() Hook. Na primer, može postojati jedan
useState() za email i jedan za lozinku.
Korišćenje jednog velikog objekta stanja: Alternativno, može se koristiti jedan
useState() Hook sa objektom koji sadrži više atributa. Svaki atribut objekta
predstavlja jedan deo stanja.

17
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Podizanje stanja
Podizanje stanja je često rešenje
kada postoje dve ili više
komponenti u React aplikaciji,
gde promena u jednoj
komponenti treba da utiče na
stanje u drugoj.
Ovo se postiže tako što se stanje
"podigne" do najbliže zajedničke
nadkomponente, koja zatim
upravlja tim stanjem i deli ga
putem props sa komponentama
koje ga koriste.

18
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Podizanje stanja
U primeru, Overview komponenta bi trebalo da prikaže uneti termin za pretragu,
ali taj termin je zapravo unet u drugoj komponenti SearchBar.
Da bi Overview mogla da prikaže termin za pretragu, mora da dobije pristup
stanju koje se nalazi u SearchBar.
Da bi se ovo rešilo, stanje je premešteno u zajedničku nadkomponentu, koja je u
ovom slučaju App. Na taj način, obe komponente (SearchBar i Overview) mogu
deliti isto stanje putem props.

19
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Uvod u stilizovanje
React.js je biblioteka za frontend razvoj u JavaScript-u, što znači da je primarno
usmerena na izgradnju korisničkih interfejsa (UI)
U prethodnim lekcijama je detaljno obrađeno kako se React može koristiti za
dodavanje interaktivnosti veb aplikaciji.
React aplikacije zahtevaju odgovarajuće stilizovanje. Kada se radi sa veb
tehnologijama, jezik izbora za stilizovanje je CSS (Cascading Style Sheets).
Ova lekcija ima za cilj da studente nauči kako da kombinuju CSS kod sa JSX-om i
React konceptima kao što su stanje (state) i (props).

20
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kako se CSS dodaje u React
Stilovi se dodaju kao u aplikacijama koje nisu bazirane na React-u.

Mogu se dodati CSS stilovi i klase JSX elementima na isti način kao običnim HTML elementima.
U CSS kodu mogu se koristiti sve funkcionalnosti i selektori koji postoje u CSS-u.
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';
ReactDOM.createRoot(document.getElementById('root')).render(
<React.StrictMode>
<App />
</React.StrictMode>,
);
21
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kako se dodaje CSS u React
CSS kod koji se piše je potpuno nezavisan od činjenice da se koristiti React u
aplikaciji.
Linija import ‘./index.css‘; dovodi do uvoza CSS datoteke i primene definisanog
CSS koda u renderovanu veb stranicu.
Ovo nije standardno ponašanje JavaScript-a. Ne mogu uvoziti CSS datoteke u čist
JavaScript.
Ovo funkcioniše u React aplikacijama zato što se kod transpajlira pre nego što se
učita u pregledaču.

22
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje inline stilova
U ovom primeru, prop style je dodat <li> elementu (svi JSX elementi podržavaju prop
style), a svojstva boje i veličine teksta postavljena su putem CSS-a.
Razlika je u tome što prop style očekuje da dobije JavaScript objekat koji sadrži stilove, a
ne običan string.
Pošto je objekat style objekat, a ne običan string, on se prosleđuje kao vrednost unutar
zagrada kao što bi se niz, broj ili bilo koja druga vrednost koja nije string morala
postaviti unutar zagrada.
function TodoItem() {
return <li style={{color: 'red', fontSize: '18px'}}>Learn React!</li>
};

23
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje stilova
Unutar objekta style, mogu se postaviti bilo koja CSS svojstva koja podržava
odgovarajući DOM element.
Imena svojstava su ona koja su definisana za HTML element.
Kada se postavljaju stilovi u JavaScript kodu (kao što je prikazano sa prop-om
style gore), moraju se koristiti imena CSS svojstava za JavaScript.
Ta imena su slična imenima CSS svojstava koja se koriste u CSS kodu, ali nisu
potpuno ista.
Razlike se javljaju kod imena svojstava koja se sastoje od više reči (npr. font-size).
Kada se koriste takva svojstva u JavaScript-u, mora se koristiti camelCase
notacija (fontSize umesto font-size), jer JavaScript svojstva ne mogu sadržati
crte.
24
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Postavljanje stilova putem CSS klasa
Korišćenje inline stilova se obično ne preporučuje, pa su CSS stilovi definisani u
CSS datotekama (ili između <style> tagova u odeljku <head> dokumenta)
poželjniji.
Umesto da se stilizuju svi <li> elementi na stranici, cilj bi mogao biti da se stilizuju
samo <li> elementi koji su deo određene liste.
Ovaj problem se obično rešava uz pomoć CSS klasa i selektora klase.
Kao što je prikazano dole, umesto se koristi class kao prop, treba koristiti
className. class je rezervisana reč u JS !
<ul>
<li className="goal-item">Learn React!</li>
<li className="goal-item">Master React!</li>
</ul>
25
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Postavljanje stilova dinamički
Često postoje neki elementi
koji bi trebalo da budu
stilizovani dinamički ili
uslovno.
Postavljanje stilova dinamički
je jednostavno.

function ColoredText() {
const [enteredColor, setEnteredColor] = useState('');
function updateTextColorHandler(event) {
setEnteredColor(event.target.value);
};
return (
<>
<input type="text" onChange={updateTextColorHandler}/>
<p style={{color: enteredColor}}>Boja teksta se menja<p>
</>
);
};

26
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Uslovni stilovi
function TextInput({isValid, isRecommended, inputConfig})
Ovom primeru, izrađuje se omotavajuća {
komponenta oko standardnog <input>
let cssClass = 'input-default';

elementa. Glavna svrha ove
omotavajuće komponente je da
postavi neke podrazumevane stilove
za obmotani <input> element.

if (isRecommended) {
cssClass = 'input-recommended';
}
if (!isValid) {
cssClass = 'input-invalid';
}
return <input className={cssClass} {...inputConfig} />
};

27
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kombinovanje više dinamičkih CSS klasa
Postoje situacije kada treba spojiti više dinamički izvedenih CSS klasa i dodati ih
elementu. Ovde su dve CSS klase dodate <p> elementu jednostavnim
kombinovanjem u jedan string.
function ExplanationText({children, isImportant}) {
const defaultClasses = 'text-default text-expl';
return <p className={defaultClasses}>{children}</p>;
}

28
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kombinovanje više dinamičkih CSS klasa
Ako text-important treba da bude dodat kao klasa uz text-default i text-exp može
se jednostavno spojiti više klasa u jedan string. Postoji nekoliko različitih načina
za to kao na primerima ispod:
cssClasses = cssClasses + ' text-important';
cssClasses = `${cssClasses} text-important`;
cssClasses = [cssClasses, 'text-important'].join(' ');

29
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kombinovanje više inline stilova
Kada se radi sa inline stilovima, umesto sa CSS klasama, takođe može se spojiti
više objekata sa stilovima.
Glavna razlika je u tome što ne dobija string sa svim vrednostima, već objekat sa
svim kombinovanim vrednostima stilova.
Najpopularnija tehnika uključuje korišćenje spread operatora:
function ExplanationText({children, isImportant}) {
let defaultStyle = { color: 'black' };
if (isImportant) {
defaultStyle = { ...defaultStyle, backgroundColor: 'red' };
}
return <p style={defaultStyle}>{children}</p>;
}
30
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Komponente sa izmenjivim stilovima
Obmotavajuća komponenta prihvata prop className koji se spaja sa
podrazumevanom CSS klasom (btn)
Ako se koristi na ovaj način, finalni <button> element bi primio i klasu btn kao i
btn-alert klase.

function Button({children, config, className}) {
return <button {...config} className={`btn ${className}`}>{children}</button>;
}
<Button config={{onClick: doSomething}} className="btn-alert">Click me!</Button>

31
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Komponente sa izmenjivim stilovima
Pored propova kao što su
className ili style, koji se mogu
spojiti sa drugim stilovima
definisanim unutar funkcije
komponente, mogu se takođe
napraviti komponente koje
primenjuju različite stilove ili
imena klasa na osnovu drugih
vrednosti propa.

function TextBox({children, mode}) {
let cssClasses;
if (mode === 'alert') {
cssClasses = 'box-alert';
} else if (mode === 'info') {
cssClasses = 'box-info';
}
return <p
className={cssClasses}>{children}</p>;
}

32
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stilovi ograničenog dosega
Stilovi iz različitih komponenti mogli bi se sukobiti i prepisati jedni druge zato što
stilovi nisu ograničeni na specifičnu komponentu.
CSS stilovi su uvek globalni, osim ako se koriste inline stilovi (koji se, kao što je
ranije pomenuto, ne preporučuju)
Kada se radi sa bibliotekama zasnovanim na komponentama, kao što je React,
ovaj nedostatak ograničenja stilova je čest problem.
Kako se sve više komponenti dodaje u React aplikaciju, lako je napisati sukobljene
stilove.
Zbog toga su članovi React zajednice razvili različita rešenja za ovaj problem:
• CSS Modules
• Styled components
33
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Ograničeni stilovi sa CSS Modules
CSS Modules je naziv za pristup gde se pojedinačne CSS datoteke povezuju sa
specifičnim JavaScript datotekama i komponentama definisanim u tim
datotekama.
Ova veza se uspostavlja transformacijom imena CSS klasa, tako da svaka
JavaScript datoteka dobije svoja jedinstvena imena CSS klasa.
Ova transformacija se automatski izvodi kao deo procesa bildovanja koda.
Postavka projekta mora podržavati CSS Modules
Projekti kreirani pomoću Vite podržavaju CSS Modules

34
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Ograničeni stilovi sa CSS Modules
CSS Modules su omogućeni i koriste se tako što se CSS datoteke imenuju sa:
<ime>.module.css.
<ime> može biti bilo koja vrednost po izboru programera, ali deo .module ispred
ekstenzije datoteke je obavezan, jer signalizira da ovu CSS datoteku treba
transformisati prema pristupu CSS Modules
Stoga, CSS datoteke imenovane na ovaj način moraju se uključivati u
komponente na specifičan način:
import classes from './file.module.css’;
Ova sintaksa za uvoz je različita od sintakse za uvoz prikazane na početku lekcije
za index.css:
import './index.css';
35
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Ograničeni stilovi sa CSS Modules
Kada se umesto toga koriste CSS Modules (prvi isečak koda), imena CSS klasa
definisanih u uvezenoj CSS datoteci se transformišu tako da su jedinstvena za JS
datoteku koja uvozi CSS datoteku.
Pošto su imena CSS klasa transformisana i stoga više ne odgovaraju imenima
klasa koja su definisana u CSS datoteci, iz CSS datoteke se uvozi objekat (classes
u prethodnom primeru)
Ovaj objekat izlaže sve transformisane nazive CSS klasa pod ključevima koji
odgovaraju CSS imenima klasa definisanim u CSS datoteci.

36
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer za css module
Ako pogledamo source videćemo ime klase
_alert_h1slj_1 koje ne postoji u kodu
To je zato što je ime klase transformisano
u trenutku bildovanja da bi bilo jedinstveno
u aplikaciji.

import classes from './TextBox.module.css';
function TextBox({ children, mode }) {
let cssClasses;
if (mode === 'alert') {
cssClasses = classes.alert;
} else if (mode === 'info') {
cssClasses = classes.info;
}
return <p
className={cssClasses}>{children}</p>;
}
export default TextBox;

37
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Biblioteka styled-components
Biblioteka styled-components predstavlja takozvano rešenje za CSS u JavaScript-u
(CSS-in-JS)
Ova rešenja teže da uklone razdvajanje između CSS koda i JavaScript koda tako
što ih spajaju u istu datoteku.
Stilovi komponenata se definišu odmah pored logike komponente.
Biblioteka styled-components u suštini pruža obmotavajuće komponente oko
svih ugrađenih osnovnih komponenti (kao što su <p>, <a>, <button>, <input> i
tako dalje).

38
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer styled-components
komponenta koja uvozi i koristi styledcomponents za postavljanje i ograničavanje
stilova
Ova komponenta nije funkcija komponente,
već konstanta koja skladišti vrednost
vraćenu izvršavanjem označenog šablona
styled.button.
Stilovi prosleđeni putem označenog šablona
(tj. unutar template literala) primenjuju se
na taj vraćeni dugme element.

import styled from 'styled-components';
const Button = styled.button`
background-color: #370566;
color: white;
border: none;
padding: 1rem;
border-radius: 4px;
`;
export default Button;

39
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Biblioteka styled-components
Biblioteka styled-components primenjuje stilove na element tako što izdvaja
definicije stilova iz template literala i ubacuje ih u <style> element u odeljku
<head> dokumenta.
Ubačeni stilovi se zatim primenjuju putem selektora klase koja je generisana (i
imenovana) od strane biblioteke styled-components.
Na kraju, automatski generisano ime CSS klase se dodaje elementu (u ovom
slučaju <button>) od strane biblioteke.
Komponente koje izlaže biblioteka styled-components prenose sve dodatne
propove koji se proslede komponenti na omotanu osnovnu komponentu.
Bilo koji sadržaj umetnut između otvarajućih i zatvarajućih tagova takođe se
umeće između tagova omotane komponente.
40
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Biblioteka styled-components
Prethodno kreirano dugme može
koristiti kao na primeru desno,
bez dodavanja dodatne logike.

import Button from './components/button';
function App() {
function clickHandler() {
console.log('This button was clicked!');
}
return <Button onClick={clickHandler}>Click
me!</Button>;
}
export default App;

41
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Tailwind CSS
Tailwind CSS je framework za stilizovanje koji omogućava brzu izradu korisničkog
interfejsa koristeći korisne utility klase.
Za razliku od tradicionalnih CSS framework-ova poput Bootstrap-a, Tailwind ne
dolazi s unapred definisanim stilovima za komponente kao što su dugmad ili
kartice.
Umesto toga, nudi skup malih, generičkih CSS klasa (tzv. "utility" klase) koje vam
omogućavaju da brzo stilizujete komponente po vašem izboru.
Ovaj pristup omogućava izradu dizajna bez potrebe za pisanjem prilagođenog
CSS-a za svaku komponentu.
<button className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
Klikni ovde
</button>
42
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Struktura Tailwind Utility Klasa
Tailwind klase se mogu grupisati prema različitim CSS svojstvima:
Boje pozadine: bg-{boja}, npr. bg-blue-500, bg-red-600.
Tekst: text-{boja} {veličina}, npr. text-white text-xl, text-gray-700.
Margin i Padding: m-{n}, p-{n}, npr. m-4, p-2, gde {n} predstavlja vrednost u
Tailwind skali.
Flexbox i Grid: flex, grid, items-center, justify-between.
<div className="bg-green-200 p-6 rounded-lg shadow-lg">
<h1 className="text-2xl font-bold text-green-800">Naslov Komponente</h1>
<p className="text-green-600 mt-4">Ovo je primer Tailwind CSS stilizovane komponente.</p>
</div>

43
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Responsive Stilizovanje sa Tailwind CSS-om
Jedna od najvećih prednosti Tailwind CSS-a je lakoća implementacije responsive
dizajna pomoću jednostavnih "breakpoint" prefiksa, kao što su sm:, md:, lg:, xl:.
Omogućava različite stilove za različite veličine ekrana bez potrebe za pisanjem
posebnih media query pravila

<div className="bg-blue-500 p-4 sm:bg-green-500 md:bg-yellow-500 lg:bg-red-500 xl:bg-purple-500">
Promeni boju pozadine prema veličini ekrana
</div>

44
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Tailwind CSS-a u React komponentama
U React-u, Tailwind klase se koriste unutar className atributa komponenti.

45
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prednosti Tailwind CSS-a
Brza izrada prototipa: Tailwind omogućava brzu izradu i vizuelizaciju ideja.
Doslednost u dizajnu: Korišćenjem Tailwind-ovih utility klasa, vaša aplikacija će
izgledati dosledno, a CSS će biti organizovaniji.
Manje pisanja CSS-a: Zbog bogatstva Tailwind klasa, nema potrebe za
prilagođenim CSS-om, što smanjuje količinu koda i održavanje.

46
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba
Napraviti login formular prikazan desno koristeći:
• samo css
• styled components
• tailwind css
Formular treba da ima validaciju
email adrese i lozinke

47
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Liste i uslovni sadržaj u React-u
Oznaka predmeta: IT354
Naziv predmeta: Veb sistemi 1
Predavanje:
#6
Predavači:
Doc. dr Mladen Opačić - Beograd
Msc. Nikola Dimitrijević - Niš
Školska godina:
2024/2025. jesenji semestar

Ciljevi učenja
Prikazivanje dinamičkog sadržaja uslovno
Renderovanje listi podataka i njihovo mapiranje na JSX elemente

Optimizacija za efikasno ažuriranje korisničkog interfejsa
Primeri: Prikaz greške, lista proizvoda, ključevi za ažuriranje
Pored uslovnog sadržaja, mnogi sajtovi takođe prikazuju liste podataka. Možda
to nije uvek odmah očigledno, ali praktično ne postoji sajt koji ne prikazuje
neku vrstu sadržaja u formi liste.

2
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Uvod u uslovno renderovanje
Uslovno renderovanje omogućava prikaz elemenata na osnovu uslova.

Primeri:
1. Učitavajući spinner:
{isLoading && <Spinner />}
2. Prikaz greške:
{hasError && <ErrorOverlay />}
3. Bočna navigacija:
{isMenuOpen && <SideNav />}

3
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Zašto je uslovno renderovanje važno?
Uslovno renderovanje se često koristi za optimizaciju korisničkog interfejsa i
poboljšanje UX-a.
Primeri:
1. Dodatna polja u formi:
{isBusinessUser && <BusinessDetailsForm />}
2. Prilagodljiva navigacija:
{isMobile && <MobileNav />}
3. Prikazivanje rezultata pretrage:
{searchTerm && <SearchResults />}

4
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer osnovne React komponente
Prikazivanje statičke komponente bez uslovnog koda.
Osnovna komponenta koja prikazuje statičan sadržaj.
Primeri:
1. Komponenta sa tekstom:
function WelcomeMessage() {

return <h1>Welcome to our site!</h1>;
}

2. Komponenta sa dugmetom:
function StaticComponent() {
return (
<div>
<button>Click Me</button>
<p>This is a static message.</p>
</div>
);
}
3. Komponenta sa listom proizvoda:
function ProductList() {
return (
<ul>
<li>Product 1</li>
<li>Product 2</li>
</ul>
);
}
5

© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Uslovno prikazivanje sadržaja: Dodavanje stanja
Uslovno prikazivanje se može implementirati dodavanjem stanja koje kontroliše
prikaz elemenata.

Primeri:
1. Dodavanje useState hook-a:
import { useState } from 'react';
function TermsOfUse() {
const [showTerms, setShowTerms] = useState(false);
return (
<div>
<button onClick={() => setShowTerms(!showTerms)}>Toggle Terms</button>
{showTerms && <p>These are the terms of use.</p>}
</div>
);
}

6
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Uslovno prikazivanje sadržaja: Dodavanje stanja
2. Uslovno prikazivanje greške:
const [hasError, setHasError] = useState(false);

return <div>{hasError ? <p>Error occurred!</p> : <p>All is good.</p>}</div>;
3. Prikazivanje dodatnih informacija na klik:
const [showDetails, setShowDetails] = useState(false);
return <div><button onClick={() => setShowDetails(true)}>Show
Details</button>{showDetails && <p>Details...</p>}</div>;

7
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

If uslov u React-u
If uslov se može koristiti za uslovno postavljanje sadržaja.

Primeri:
1. Prikazivanje sa if uslovom:
let message;
if (isLoggedIn) {
message = <p>Welcome back!</p>;
} else {
message = <p>Please log in.</p>;
}
return <div>{message}</div>;

8
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

If uslov u React-u #2
2. Višestruki uslovi:
let status;
if (loading) {
status = <p>Loading...</p>;
} else if (error) {
status = <p>An error occurred!</p>;
} else {

3. Uslov unutar funkcije:
function renderContent() {
if (hasAccess) {
return <p>Access granted.</p>;
}
return <p>Access denied.</p>;
}
return <div>{renderContent()}</div>;

status = <p>Data loaded successfully.</p>;
}

9
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Dinamički JSX elementi
JSX elementi se mogu postaviti kao dinamičke vrednosti unutar promenljivih.
Primeri:
1. Postavljanje JSX elementa u promenljivu:
const paragraph = isVisible ? <p>This is visible text.</p> : null;
return <div>{paragraph}</div>;
2. Korišćenje promenljivih za renderovanje elemenata:
let content;
if (showInfo) {
content = <div>Info content shown here.</div>;
}
return <section>{content}</section>;
3. Spremanje više JSX elemenata u jednu promenljivu:
const elements = showAll ? (<div><p>Element 1</p><p>Element 2</p></div>) : null;
return <div>{elements}</div>;

10
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Praktični primer: Dugme i dodatni sadržaj
Prikazivanje dodatnih elemenata na osnovu korisničke interakcije.

Primeri:
1. Dodavanje sadržaja na klik:
const [isExpanded, setIsExpanded] = useState(false);
return (
<div>
<button onClick={() => setIsExpanded(!isExpanded)}>Toggle Info</button>
{isExpanded && <p>Here is some extra information.</p>}
</div>
);

11
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Praktični primer: Dugme i dodatni sadržaj
2. Prikazivanje formulara po zahtevu:
const [showForm, setShowForm] = useState(false);

return (
<div>
<button onClick={() => setShowForm(true)}>Show Form</button>
{showForm && <form><input type="text" placeholder="Enter details"
/></form>}
</div>
);

12
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Praktični primer: Dugme i dodatni sadržaj
3. Prikazivanje slike po izboru korisnika:
const [showImage, setShowImage] = useState(false);

return (
<div>
<button onClick={() => setShowImage(true)}>Show Image</button>
{showImage && <img src="image.jpg" alt="Example" />}
</div>
);

13
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Ternarni izrazi u React-u
Ternarni operatori omogućavaju jednostavnije uslovno postavljanje sadržaja.
Primeri:
1. Osnovni ternarni izraz:
return <div>{isLoggedIn ? <p>Welcome, user!</p> : <p>Please log in.</p>}</div>;
2. Prikazivanje sa alternativnim sadržajem:
const message = hasPermission ? 'You have access' : 'Access denied';
return <div><p>{message}</p></div>;
3. Uslovno prikazivanje dugmeta:
return (
<div>
{isEditable ? <button>Edit</button> : <button>View</button>}
</div>
);

14
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Ugnježdeni ternarni izrazi
Ugnježdeni ternarni izrazi mogu smanjiti čitljivost koda i treba ih koristiti s oprezom.
Primeri:
1. Jednostavan ugnježdeni ternarni izraz:
const status = isLoggedIn ? (isAdmin ? 'Welcome, Admin' : 'Welcome, User') : 'Please log in';
return <p>{status}</p>;
2. Ugnježdeni izraz sa višestrukim uslovima:
return (
<div>
{hasAccess ? (isPremium ? <p>Premium User</p> : <p>Free User</p>) : <p>No access</p>}
</div>
);
3. Kombinacija logičkih provera i ternarnih izraza:
return <div>{showDetails ? (showInfo ? <p>Details and Info</p> : <p>Details only</p>) : <p>No
details</p>}</div>;

15
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje logičkog operatora &&
Logički operator && omogućava jednostavno uslovno renderovanje bez else slučaja.
Primeri:
1. Prikazivanje poruke:
return <div>{isMember && <p>Welcome, member!</p>}</div>;
2. Prikazivanje dugmeta samo za admine:
return <div>{isAdmin && <button>Admin Settings</button>}</div>;
3. Prikazivanje dodatnih opcija:
return (
<div>
{isLoggedIn && <button>Log Out</button>}
{!isLoggedIn && <button>Log In</button>}
</div>
);

16
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Direktno korišćenje && u JSX-u
Direktna upotreba && unutar JSX koda omogućava jednostavno uslovno
renderovanje.
Primeri:
1. Prikazivanje slike:
return <div>{showImage && <img src='image.jpg' alt='Example' />}</div>;
2. Prikazivanje naslova:
return <div>{hasContent && <h1>Content Loaded</h1>}</div>;
3. Prikazivanje statusne poruke:
return <div>{isOnline && <p>User is currently online</p>}</div>;

17
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Uslovno postavljanje HTML oznaka
Kada je potrebno birati između različitih HTML oznaka na osnovu uslova.
Primeri:
1. Korišćenje promenljive za postavljanje oznake:
function Button({ isButton, config, children }) {
const Tag = isButton ? 'button' : 'a';
return <Tag {...config}>{children}</Tag>;
}
2. Uslovno renderovanje različitih elemenata:
const Element = isImportant ? 'strong' : 'span';
return <Element>{text}</Element>;
3. Prikazivanje različitih tipova polja:
const InputType = isPassword ? 'password' : 'text';
return <input type={InputType} />;

18
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer s funkcijom Button
Uslovno postavljanje JSX oznaka i prilagodljivi elementi.

Primeri:
1. Osnovna funkcija sa uslovnim oznakama:
function CustomTag({ isHeader }) {
const Tag = isHeader ? 'h1' : 'p';
return <Tag>This is a custom element</Tag>;
}

19
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer s funkcijom Button
2. Komponenta koja vraća dugme ili link:
function ActionLink({ isButton, url }) {

const Tag = isButton ? 'button' : 'a';
return <Tag href={isButton ? undefined : url}>Click Me</Tag>;
}

20
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prikazivanje liste podataka #1
Pored uslovnog sadržaja, mnogi sajtovi takođe prikazuju liste podataka. Možda
to nije uvek odmah očigledno, ali praktično ne postoji sajt koji ne prikazuje
neku vrstu sadržaja u formi liste.

• Online prodavnica koja prikazuje mrežu ili listu proizvoda
• Sajt za rezervaciju događaja koji prikazuje listu događaja
• Korpa za kupovinu koja prikazuje listu stavki u korpi
• Stranica sa narudžbinama koja prikazuje listu narudžbina
• Blog koji prikazuje listu blog postova i možda listu komentara ispod blog posta
• Lista navigacionih stavki u zaglavlju
Mogao bi se napraviti beskonačan spisak primera. Zbog toga je važno znati kako
prikazati bilo koju vrstu liste sa bilo kojim vrstama podataka u React korisničkim
interfejsima.

21
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prikazivanje liste podataka #2
Prikazivanje liste korisnika:
const users = ['John', 'Alice', 'Bob'];

return (
<div>
{users.map((user, index) => <p key={index}>{user}</p>)}
</div>
);

22
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prikazivanje liste proizvoda
Prikaz liste proizvoda sa detaljima u JSX formatu.
Primeri:
1. Renderovanje liste sa detaljima:
const products = [
{ id: 1, name: 'TV', description: 'Smart TV 42 inches' },
{ id: 2, name: 'Washing Machine', description: 'Front load' }
];
return (
<ul>
{products.map(product => (
<li key={product.id}>
<h2>{product.name}</h2>
<p>{product.description}</p>
</li>
))}
</ul>
);

23
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prikazivanje liste proizvoda
2. Lista sa dodatnim informacijama:
const items = [
{ id: 'a1', name: 'Item 1', info: 'This is item 1' },
{ id: 'b2', name: 'Item 2', info: 'This is item 2' }
];
return (
<div>
{items.map(item => (
<div key={item.id}>
<h3>{item.name}</h3>
<p>{item.info}</p>
</div>
))}
</div>
);

24
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prikazivanje liste proizvoda
3. Prikaz liste sa cenama:
const prices = [
{ product: 'Chair', cost: 50 },
{ product: 'Table', cost: 150 }
];
return (
<ul>
{prices.map(price => (

<li key={price.product}>{price.product} - ${price.cost}</li>
))}
</ul>
);

25
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Lista sa for petljom
Upotreba for petlje za kreiranje liste JSX elemenata.

Primeri:
1. Generisanje JSX elemenata sa for petljom:
const items = ['One', 'Two', 'Three'];
let itemList = [];
for (let i = 0; i < items.length; i++) {
itemList.push(<li key={i}>{items[i]}</li>);
}
return <ul>{itemList}</ul>;

26
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Lista sa for petljom
2. Petlja za kreiranje tabele:
const rows = [

{ id: 1, name: 'Row 1' },
{ id: 2, name: 'Row 2' }
];
let tableRows = [];
for (let row of rows) {
tableRows.push(<tr key={row.id}><td>{row.name}</td></tr>);
}
return <table><tbody>{tableRows}</tbody></table>;

27
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Lista sa for petljom
3. Iteracija sa dodatnim uslovom:
const data = [10, 20, 30];

let dataList = [];
for (let i = 0; i < data.length; i++) {
if (data[i] > 15) {
dataList.push(<li key={i}>{data[i]}</li>);
}
}
return <ul>{dataList}</ul>;

28
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prikazivanje liste pomoću map() metode
map() metoda je najčešći i daleko najpopularniji način za pretvaranje nizova u
JSX elemente. Gotovo da ne postoji React aplikacija u kojoj nema mapiranja
podataka u listu.
Primeri:
1. Osnovna upotreba map() metode:
const names = ['Alice', 'Bob', 'Charlie'];

return (
<div>
{names.map((name, index) => <p key={index}>{name}</p>)}
</div>
);

29
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prikazivanje liste pomoću map() metode
2. Mapiranje sa dodatnim atributima:
const items = [

{ id: 1, text: 'First' },
{ id: 2, text: 'Second' }
];
return (
<ul>
{items.map(item => (
<li key={item.id}>{item.text}</li>
))}
</ul>

);

30
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prikazivanje liste pomoću map() metode
3. Mapiranje sa složenim JSX strukturama:
const products = [
{ id: 'p1', name: 'Sofa', details: 'Comfortable and modern' },
{ id: 'p2', name: 'Desk', details: 'Spacious working desk' }
];
return (
<div>
{products.map(product => (
<div key={product.id}>
<h2>{product.name}</h2>
<p>{product.details}</p>
</div>
))}
</div>
);

31
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Poređenje for petlje i map() metode
Poređenje ovih pristupa pomaže u razumevanju koja metoda je bolja za
određene scenarije.

1. Upotreba for petlje:
const numbers = [1, 2, 3];
let numberList = [];
for (let number of numbers) {
numberList.push(<li key={number}>{number}</li>);
}
return <ul>{numberList}</ul>;
2. Jednostavnija upotreba sa map() metodom:
const numbers = [1, 2, 3];
return (
<ul>
{numbers.map(number => <li key={number}>{number}</li>)}
</ul>
);
32
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upotreba map() za kreiranje elemenata direktno u JSX-u
Korišćenje map() direktno unutar JSX-a omogućava konciznije i čitljivije kreiranje liste
elemenata.
1. Jednostavna lista:
return (
<ul>
{['Apple', 'Orange', 'Banana'].map((fruit, index) => <li key={index}>{fruit}</li>)}
</ul>
);
2. Mapiranje sa dodatnim informacijama:
const data = [{ id: 1, label: 'One' }, { id: 2, label: 'Two' }];
return (
<div>
{data.map(item => <p key={item.id}>{item.label}</p>)}
</div>
);
33
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Uslovi za renderovanje u funkciji
Korišćenje funkcije za uslovno postavljanje sadržaja omogućava modularnost i ponovnu
upotrebu koda.
1. Funkcija za prikaz poruke:
function renderMessage(isVisible) {
return isVisible ? <p>Visible content shown.</p> : null;
}

return <div>{renderMessage(true)}</div>;
2. Funkcija za prikaz greške:
function showError(hasError) {
return hasError ? <p>Error occurred!</p> : <p>All is well.</p>;
}
return <div>{showError(true)}</div>;
34
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Problem sa dodavanjem elemenata u listu
Upotreba metoda koje menjaju originalni niz (npr. push()) može dovesti do problema
sa renderovanjem u React-u.

1. Neispravno ažuriranje niza:
const [items, setItems] = useState(['Item 1', 'Item 2']);
function addItem() {
items.push('Item 3'); // Ovo je pogrešno, neće pokrenuti render
}

35
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Ispravan način ažuriranja stanja liste
Ažuriranje stanja liste treba vršiti na nemutabilan način kako bi React prepoznao promene.
1. Korišćenje funkcionalnog ažuriranja stanja:
setTodos(currentTodos => [...currentTodos, 'New Task']);
2. Upotreba concat() metode:
setTodos(currentTodos => currentTodos.concat('Another Task'));

3. Ažuriranje sa dodatnim uslovima:
function addTask(task) {
if (task) {
setTasks(currentTasks => [...currentTasks, task]);

}
}
36
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Ključevi u listi
React koristi koncept ključeva kada radi sa podacima liste i prikazivanjem stavki liste.
Ključevi su jednostavno jedinstvene ID vrednosti koje mogu (i treba) biti prikačene
JSX elementima prilikom prikazivanja podataka liste.
Ključevi pomažu React-u da identifikuje elemente koji su prethodno prikazani i nisu
se promenili.
Omogućavanjem jedinstvene identifikacije svih stavki liste, ključevi takođe pomažu
React-u da efikasno premešta DOM elemente stavki liste.
Ključevi se dodaju JSX elementima preko posebnog ugrađenog prop-a key koji je
prihvaćen od strane svake komponente:
<li key={todo.id}>{todo.text}</li>
Ovaj specijalni prop može se dodati svim komponentama.
React automatski upravlja sa key propom.
Key prop zahteva vrednost koja je jedinstvena za svaku stavku liste.

37
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Problemi sa ključevima
Razumevanje problema sa nepravilnom upotrebom ključeva može sprečiti greške u React
aplikacijama.
Korišćenje indeksa kao ključeva može dovesti do problema kada se redosled menja.
Duplicirani ključevi:
const duplicateItems = ['Item 1', 'Item 1', 'Item 2'];
Ključevi moraju biti unikatni da bi React ispravno pratio elemente.

38
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kako React koristi ključeve
Ključevi pomažu React-u da identifikuje elemente i efikasno ažurira DOM.
1. Identifikacija elemenata za ažuriranje:
const list = [{ id: 1, name: 'Item 1' }, { id: 2, name: 'Item 2' }];
return (

<div>{list.map(item => <div key={item.id}>{item.name}</div>)}</div>
);
2. Praćenje promene redosleda:
const fruits = ['Apple', 'Orange', 'Grape'];
return (
<ul>{fruits.map(fruit => <li key={fruit}>{fruit}</li>)}</ul>
);
3. Ažuriranje sa ključevima sprečava nepotrebno rerenderovanje elemenata.

39
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Praktični primer sa ažuriranjem liste
Prikazivanje kako se ključevi koriste pri ažuriranju liste elemenata.

1. Ažuriranje liste sa novim stavkama:
const [items, setItems] = useState(['Task 1', 'Task 2']);
function addItem() {
setItems(prevItems => [...prevItems, 'Task 3']);
}
return (
<div>
<button onClick={addItem}>Add Task</button>
<ul>{items.map((item, index) => <li key={index}>{item}</li>)}</ul>
</div>
);
2. Brisanje stavki sa ispravnim ključevima:
const [tasks, setTasks] = useState([{ id: 't1', task: 'Learn React' }, { id: 't2', task: 'Practice coding' }]);
function removeTask(id) {
setTasks(prevTasks => prevTasks.filter(task => task.id !== id));
}

40
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kako pronaći dobre ključeve
Uputstva za odabir pravih ključeva za liste elemenata.
1. Upotreba jedinstvenih ID-ova:

const users = [{ id: 'u1', name: 'John' }, { id: 'u2', name: 'Alice' }];
return (
<ul>{users.map(user => <li key={user.id}>{user.name}</li>)}</ul>
);

2. Generisanje ključeva pomoću biblioteka kao što je uuid:
import { v4 as uuidv4 } from 'uuid';
const items = ['Item 1', 'Item 2'];
return (
<ul>{items.map(item => <li key={uuidv4()}>{item}</li>)}</ul>
);

41
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje vrednosti kao ključeva
Vrednosti elemenata se mogu koristiti kao ključevi, ali samo ako su unikatne.
Primeri:
1. Prikaz liste hobija:
const hobbies = ['Running', 'Swimming', 'Cycling'];
return (
<ul>{hobbies.map(hobby => <li key={hobby}>{hobby}</li>)}</ul>
);
2. Upotreba imena kao ključeva (samo ako su jedinstvena):
const users = ['Mike', 'Anna', 'Bob'];
return (
<div>{users.map(user => <p key={user}>{user}</p>)}</div>;
);
3. Prikaz liste knjiga sa naslovima kao ključeva:
const books = ['React for Beginners', 'Advanced JavaScript'];
return (
<ul>{books.map(book => <li key={book}>{book}</li>)}</ul>
);

42
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kada koristiti indekse kao ključeve
Indeksi se mogu koristiti kao ključevi samo u specifičnim slučajevima.

1. Statističke liste:
const colors = ['Red', 'Green', 'Blue'];
return (
<ul>{colors.map((color, index) => <li key={index}>{color}</li>)}</ul>
);
2. Liste koje se ne menjaju:
const steps = ['Step 1', 'Step 2'];
return (
<ol>{steps.map((step, index) => <li key={index}>{step}</li>)}</ol>

);
Problemi sa dinamičkim listama -> Promena redosleda može izazvati greške ako se koristi
indeks kao ključ.
43
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba

44
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba 2

45
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rad sa sporednim efektima u React-u
Oznaka predmeta: IT354
Naziv predmeta: Veb sistemi 1
Predavanje:
#7
Predavači:
Doc. dr Mladen Opačić - Beograd
Msc. Nikola Dimitrijević - Niš
Školska godina:
2024/2025. jesenji semestar

Ciljevi učenja
Prepoznavanje sporednih efekata u React aplikacijama.
Razumevanje i koriđćenje useEffect() Hook-a

Primena različitih funkcija i koncepata vezanenih za useEffect() Hook kako bi se
izbegle greške i optimizovao kod.
Upravljanje sporednim efektima koji su povezani, kao i onima koji nisu povezani
sa promenama stanja.

2
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Šta su sporedni efekti u React-u?
Sporedni efekti su radnje ili procesi koji se dešavaju pored nekog drugog "glavnog
procesa".

U slučaju React komponente, glavni proces bio bi ciklus renderovanja komponente, u
kojem je glavni zadatak komponente da renderuje korisnički interfejs.
React komponenta treba da vrati konačni JSX kod, koji se zatim prevodi u uputstva za
manipulaciju DOM-om.
React smatra promene stanja kao okidač za ažuriranje korisničkog interfejsa.

Slanje HTTP zahteva, nije deo ovog glavnog procesa.
Pošto slanje HTTP zahteva nije deo glavnog procesa (renderovanja korisničkog
interfejsa) koji obavlja funkcija komponente, ono se smatra "sporednim efektom".

3
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Šta su sporedni efekti u React-u? #2
Svaka radnja koja se započne prilikom izvršavanja funkcije React komponente
predstavlja sporedni efekat ako ta radnja nije direktno povezana sa glavnim
zadatkom renderovanja korisničkog interfejsa komponente.
Primeri sporednih efekata:

• Slanje HTTP zahteva (kao što je prikazano ranije)
• Čuvanje podataka u skladište pretraživača ili preuzimanje podataka iz njega
(npr. putem ugrađenog objekta localStorage)

• Postavljanje tajmera (pomoću setTimeout()) ili intervala (pomoću
setInterval())

• Beleženje podataka u konzolu putem console.log()

4
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer sporednog efekta
U ovom primeru, console.log(…) je sporedni
efekat, jer se izvršava kao deo svakog
izvršavanja funkcije komponente i ne
utiče na renderovani korisnički interfejs.
Sporedni efekti nisu nužno problem.
Međutim, često će biti i sporednih efekata
koji mogu da naprave problem ili izazovu
beskonačnu petlju re-renderovanja.
Za upravljanje sporednim efektima koristi
se Hook useEffect.

function ControlCenter() {
function startHandler() {
// uradi nešto ...
}
console.log('Komponenta se renderuje!');
// ovo je sporedni efekat!
return (
<div>
<p>Pritisni dugme da započneš proces
pregleda</p>
<button
onClick={startHandler}>Start</button>
</div>
);
}
5

© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Problemi sa sporednim efektima
Zašto sporedni efekti mogu postati problematični?
Beskonačne petlje: Promene stanja mogu uzrokovati ponovno izvršavanje efekta, što vodi u
beskonačni ciklus.
Neočekivana ponašanja: Izvršavanje efekta u pogrešnim trenucima može dovesti do grešaka.

Izazovi u debagovanju: Teško je uočiti greške kada efekti nisu pravilno upotrebljeni.

useEffect(() => {
setCount(count + 1);
}, [count]); // Beskonačno ažurira stanje

6
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Sintaksa i upotreba useEffect()
Funkcija efekta: Izvršava se nakon renderovanja komponente.
Niz zavisnosti: Određuje kada će se efekat ponovo izvršiti.
useEffect(() =>
{ // Logika efekta}
, [zavisnosti]);
Tri scenarija sa nizom zavisnosti:
Bez niza zavisnosti: Efekat se izvršava nakon svakog renderovanja.
Prazan niz zavisnosti: Efekat se izvršava samo jednom, pri montaži komponente.
Sa zavisnostima: Efekat se izvršava samo kada se zavisnosti promene.

7
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje sporednim efektima uz pomoć useEffect() Hook-a #1
import { useState, useEffect } from 'react';
import classes from './BlogPosts.module.css';
async function fetchPosts() {
const response = await
fetch('https://jsonplaceholder.typicode.com/posts');
const blogPosts = await response.json();
return blogPosts;
}
function BlogPosts() {
const [loadedPosts, setLoadedPosts] = useState([]);
useEffect(function () {
fetchPosts().then((fetchedPosts) =>
setLoadedPosts(fetchedPosts));
}, []);
return (
<ul className={classes.posts}>
{loadedPosts.map((post) => (
<li key={post.id}>{post.title}</li>
))}
</ul>
);
8
}
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje sporednim efektima uz pomoć useEffect() Hook-a #2
Na primeru useEffect() Hook je importovan i korišćen da bi se kontrolisao sporedni efekat
(zato se ovaj Hook i zove useEffect(), jer se bavi sporednim efektima u React
komponentama).
Kao što je prikazano u prethodnom isječku koda, useEffect(), kao i svi React Hook-ovi, se
izvršava kao funkcija unutar funkcije komponente (u ovom slučaju, BlogPosts).
Međutim, za razliku od useState(), useEffect() ne vraća vrednost, ali prima jedan argument (ili,
zapravo, dva argumenta), poput drugih Hook-ova.

Prvi argument je uvek funkcija. U ovom slučaju, funkcija prosleđena useEffect() je anonimna
funkcija, kreirana pomoću ključne reči function.
Prvi argument prosleđen useEffect() mora biti funkcija. Ne sme biti nijedna druga vrsta
vrednosti.
Drugi argument mora biti niz, ali njegovo prosleđivanje je opciono.

9
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje sporednim efektima uz pomoć useEffect() Hook-a #3
Na snimku ekrana desno može se videti lista
fiktivnih blog postova sa adrese:
https://jsonplaceholder.typicode.com/posts
Na ovom sajtu mogu se pronaći fiktivni podaci
za vežbanje učitavanja podataka preko http
protokola.
Ukoliko se želi postići da se sporedni efekat
učitavanja blog postova dogodi samo jednom
kao drugi argument funkcije useEffect()
prosleđuje se prazan niz.

10
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje sporednim efektima uz pomoć useEffect() Hook-a #4

Prvi argument useEffect() je funkcija koju React izvršava.
Ona se izvršava nakon svakog ciklusa renderovanja komponente (tj. nakon
svakog izvršavanja funkcije komponente).
U prethodnom primeru, ako se prosledi samo ovaj prvi argument, a izostavi
drugi, stvorila bi se beskonačna petlja.

11
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje sporednim efektima uz pomoć useEffect() Hook-a #5
Izvlačenje sporednih efekata iz funkcija React komponenti je glavni zadatak useEffect()a, pa je samo prvi argument (funkcija koja sadrži kod sporednog efekta) obavezan.
Drugi argument služi da kontroliše učestalost sa kojom će se kod efekta izvršavati.
Drugi parametar koji useEffect() prima je uvek niz.
Ovaj niz određuje zavisnosti funkcije efekta.
Svaka zavisnost navedena u ovom nizu, kada se promeni, izazvaće ponovno izvršavanje
funkcije efekta.

Ako niz nije naveden (tj. ako je drugi argument izostavljen), funkcija efekta će se
ponovo izvršiti pri svakom izvršavanju funkcije komponente.

12
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje sporednim efektima uz pomoć useEffect() Hook-a #5

U prethodnom primeru je prazan niz.
Ovo informiše React da ova funkcija efekta nema zavisnosti.

Funkcija efekta se neće ponovo izvršavati tj. biće izvršena samo jednom, kada se
komponenta prvi put renderuje.
Niz prosleđen useEffect() funkciji treba da sadrži sve varijable, konstante ili
funkcije koje se koriste unutar funkcije efekta.

13
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kontrola učestalosti efekata
Korišćenjem niza zavisnosti (dependencies array), moguće je precizno odrediti
kada će se efekat ponovo izvršiti.
Tri ključne opcije za niz zavisnosti:
Bez niza:
Efekat se izvršava nakon svakog renderovanja komponente.Koristi se u retkim
situacijama.
Prazan niz ([]):

Efekat se izvršava samo jednom, prilikom prve montaže komponente.Idealno za
inicijalizaciju, kao što je preuzimanje podataka.
Sa zavisnostima:
Efekat se izvršava samo kada se neka od zavisnosti promeni.

useEffect(() => {
console.log('Broj je ažuriran:', count); }, [count]);
// Izvršava se samo kada se `count` promeni
14
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Funkcije za čišćenje u useEffect()
Šta su funkcije za čišćenje?
Funkcije koje se izvršavaju pre nego što se efekat ponovo izvrši ili pre nego što se
komponenta ukloni iz DOM-a.
Neophodne za upravljanje resursima, poput tajmera ili pretplata.
Kako rade?
Definišu se unutar funkcije efekta i vraćaju se
useEffect(() => {
const timer = setTimeout(() => {
console.log('Tajmer istekao');
}, 2000);
return () => {
clearTimeout(timer); // Čišćenje pre novog izvršenja
;}
, []);
15
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

}

Problemi sa nedostatkom funkcija za čišćenje
Šta može da se desi bez funkcija za čišćenje?
Curenje memorije: Neosnovano zadržavanje resursa, poput tajmera ili pretplata.

Neočekivana ponašanja: Efekti nastavljaju da rade čak i kada komponenta više
nije potrebna.
useEffect(() => {
const interval = setInterval(() => { console.log('Interval radi’);
}, 1000);}, []); // Nedostaje funkcija za čišćenje
Rešenje:
Uvek uključite funkciju za čišćenje kada koristite tajmere, intervale ili pretplate:
return () => clearInterval(interval);
Funkcije za čišćenje poboljšavaju performanse i sprečavaju greške.

16
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rad sa više efekata
React njje ograničen na samo jedan poziv po komponenti.

Može se pozivati useEffect() onoliko puta koliko je
potrebno i stoga registrovati onoliko funkcija efekata
koliko je potrebno.
Jedan pristup bio bi da se funkcije efekata podele
zavisnostima. Ako jedan sporedni efekat zavisi od stanja
A, a drugi sporedni efekat zavisi od stanja B, mogu se
staviti u zasebne funkcije efekata.

function Demo() {
const [a, setA] = useState(0);
const [b, setB] = useState(0);

useEffect(function() {
console.log(a);
}, [a]);

Najbolji pristup je da se funkcije efekata podele prema
logici.

useEffect(function() {
console.log(b);
}, [b]);
// return some JSX code ...
}

17
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rad sa više efekata
Kada koristiti više efekata?
Ako različiti efekti zavise od različitih vrednosti.
Bolje upravljanje logikom i čitljivost koda.
useEffect(() => { console.log('Email ažuriran:', email);}, [email]);
useEffect(() => { console.log('Lozinka ažurirana:', password);}, [password]);
Kombinovanje efekata:
Ako su zavisnosti povezane, mogu se staviti u isti efekat:
useEffect(() => {

console.log('Email:', email, 'Lozinka:', password);}
, [email, password]);
Odvojite efekte kada je to logički opravdano.

18
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Funkcije kao zavisnosti
Jedna uobičajena vrsta zavisnosti su funkcije.

Svaki put kada se izvrši kod koji sadrži definiciju funkcije, kreira se novi objekat funkcije i
skladišti u memoriji.
Kada se funkcija pozove, izvršava se upravo taj specifični objekat funkcije u memoriji.
Moguće je da više objekata zasnovanih na istom kodu funkcije postoji u memoriji.
U praksi ovo znači da ako funkciji useEffect prosledimo funkciju svaki put kad se
komponenta re-renderuje stvoriće se novi objekat iste funkcije koji će biti skladišten po
referenci i samim time aktiviraće se useEffect.
Ako se ne pazi može dovesti do veoma čudnih ponašanja interfejsa i neretko do kreiranja
beskonačne petlje ponovnih renderovanja.

19
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izbegavanje nepotrebnih izvršenja efekta
Funkcija validateEmail() zatim obavlja validaciju
email adrese i, ako je adresa nevažeća, beleži
poruku u konzolu.
validateEmail() se izvršava uz pomoć
useEffect().
Problem sa ovim kodom je taj što će se funkcija
efekta izvršiti svaki put kada se validateEmail
promeni, jer je, ispravno, validateEmail
dodata kao zavisnost.

validateEmail će se promeniti svaki put kada se
funkcija komponente ponovo izvrši. To se ne
dešava samo kod promene stanja
enteredEmail, već i svaki put kada se
enteredPassword promeni iako ta vrednost
stanja uopšte nije korišćena unutar
validateEmail

…
function validateEmail() {
if (!enteredEmail.includes('@')) {
console.log('Invalid email!');
}
}
useEffect(function () {
validateEmail();
}, [validateEmail]);

return (
…

20
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izbegavanje nepotrebnih izvršenja efekta
Nepotrebno izvršavanje efekta može se izbeći raznim rešenjima:
Premeštanjem koda iz validateEmail direktno u funkciju efekta. Tada bi
enteredEmail bila jedina zavisnost efekta, čime bi se izbeglo izvršavanje efekta
pri promeni drugih stanja.
Izbegavanjem korišćenja useEffect() uopšte, jer bi se mogla obaviti validacija
email adrese unutar updateEmailHandler. Imati console.log() tamo bi bilo
prihvatljivo, jer ne bi izazvalo nikakvu štetu.

21
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izbegavanje nepotrebnih izvršenja pomoću useCallback

useCallback(), kao i svi React Hook-ovi, je funkcija koja se izvršava direktno
unutar funkcije komponente.

Kao i useEffect(), prima dva argumenta: drugu funkciju (može biti anonimna ili
imenovana funkcija) i niz zavisnosti.
Za razliku od useEffect(), useCallback() ne izvršava primljenu funkciju. Umesto
toga, useCallback() osigurava da se funkcija ponovo kreira samo ako se neka od
specificiranih zavisnosti promeni.
Podrazumevano ponašanje JavaScript-a da kreira novi objekat funkcije svaki put
kada se okolni kod ponovo izvrši je onemogućeno.

22
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

import { useState, useEffect, useCallback } from 'react’;
…
const validateEmail = useCallback(function () {
if (!enteredEmail.includes('@')) {
console.log('Invalid email!');
}
}, [enteredEmail]);
useEffect(function () {
validateEmail();
}, [validateEmail]);
// return JSX code ...
}
export default Alert;

23
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izbegavanje nepotrebnih izvršenja pomoću useCallback

useCallback() vraća najnoviji sačuvani objekat funkcije.
Stoga se ta vraćena vrednost (koja je funkcija) čuva u promenljivoj ili konstanti

Pošto se funkcija umotana u useCallback() sada menja samo kada se neka od
zavisnosti promeni
Vraćena funkcija može se koristiti kao zavisnost za useEffect() bez da uzrokuje
izvršavanje efekta za sve vrste promena stanja ili ažuriranja komponente.
U prehtodnom primeru, funkcija efekta se izvršava samo kada se enteredEmail
promeni, jer je to jedina promena koja će dovesti do stvaranja novog objekta
funkcije validateEmail.

24
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Sporedni efekti sa funkcijama
Funkcije kao zavisnosti:
Funkcije u JavaScript-u su objekti i mogu se menjati pri svakom renderovanju.
Ako funkcija zavisi od stanja ili props, mora biti dodata u niz zavisnosti.
Problemi sa funkcijama:
Svaki put kada se funkcija ponovo kreira, efekat će se ponovo izvršiti.

Rešenje:
Korišćenje useCallback() - useCallback() sprečava nepotrebno kreiranje novih funkcija.
Primer:

const memorisanaFunkcija = useCallback(() => {
console.log(email);
}, [email]); // Funkcija se menja samo ako se `email` promeni
25
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upotreba objekata kao zavisnosti
Slično kao kod funkcija objekti su u JavaScript-u takođe referentni tipovi
podataka.

Dodatna neželjena izvršenja mogu se pojaviti, jer re-evaluacija komponente
proizvodi potpuno nove JavaScript objekte.
Čak i ako se vrednosti svojstava tih objekata nisu promenile, tehnički, JavaScript
kreira potpuno novi objekat u memoriji.
Pošto efekat zavisi od celog objekta, React samo "vidi" da postoji nova verzija
tog objekta i stoga ponovo izvršava efekat.

26
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upotreba objekata kao zavisnosti
Najbolji način da se izbegne
nepotrebno izvršavanje efekata
kada su objekti zavisnosti u
pitanju je da se jednostavno
destrukturira objekat kako bi se
prosledila samo ona svojstva
objekta koja su potrebna
efektu kao zavisnosti.
Čak i ako se objekat ponovo
kreira, jedino što je važno je
vrednost atributa
Ako se ne promeni, funkcija
efekta neće se ponovo
izvršavati.

function Error(props) {
const { message } = props;
// destrukturirajte kako biste izdvojili
potrebna svojstva

useEffect(function () {
console.log('An error occurred!');
console.log(message);
}, [message]); // koristite samo potrebne
zavisnosti
return <p>{message}</p>;
}
27

© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Problemi sa objektima kao zavisnostima
Zašto su objekti problematični?

• Objekti se ponovo kreiraju pri svakom renderovanju, čak i ako njihova svojstva nisu
promenjena.

• Ovo može izazvati nepotrebno ponovno izvršavanje efekata.
useEffect(() => {
console.log('Poruka greške:', props.message);
}, [props]); // Efekat se izvršava pri svakom renderovanju
Rešenje: Destrukturiranje objekataKoristite destrukturiranje da biste izdvojili samo potrebne
vrednosti:
function Error({ message }) {
useEffect(() => {
console.log('Poruka greške:', message);
}, [message]); // Samo relevantna svojstva su zavisnosti}

28
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Asinhroni kod u efektima
Neki efekti se izvršavaju asinhroni kodom (na primer, slanje HTTP zahteva).
Kada se izvršava asinhroni kod u funkcijama efekta, postoji jedno važno pravilo koje
morate da se poštuje, a to je da funkcija efekta ne sme biti asinhrona i ne sme vraćati
promise.
Da bi koristili async/await, može se kreirati zasebna omotačku funkcija unutar funkcije
efekta, koja se zatim izvršava u efektu. Kao na primeru desno.
Na taj način, funkcija efekta sama po sebi nije asinhrona (ne vraća promise), ali i dalje
može koristiti async/await.

useEffect(function () {
async function loadData() {
const fetchedPosts = await fetchPosts();
setLoadedPosts(fetchedPosts);
}
loadData();
}, []);

29
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje asinhronim efektima
Asinhroni zadaci u useEffect-u:
Slanje HTTP zahteva, preuzimanje podataka, pristup API-ju.
Pravila za asinhroni kod:
Ne koristite async direktno u funkciji efekta.Funkcija efekta ne sme vraćati promise.
Koristite interne asinhrone funkcije:
useEffect(() => {
async function fetchData() {
const response = await fetch('https://api.example.com/data’);
const data = await response.json();

setData(data);
}
fetchData();
}, []);

30
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje asinhronim efektima
Alternativa bez async/await
Korišćenje promise sa .then() metodom:
useEffect(() => {
fetch('https://api.example.com/data’)
.then(response => response.json())
.then(data => setData(data));
}, []);

31
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prikaz statusa učitavanja podataka
Kako upravljati statusom učitavanja sa useEffect()?
Prikazivanje indikatora učitavanja dok se podaci preuzimaju:

useEffect(() => {
setLoading(true);
fetch('https://api.example.com/data')
.then(response => response.json())
.then(data => {
setData(data);
setLoading(false);
});
}, []);

32
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje useEffect() za integraciju sa lokalnim skladištem
Kako koristiti useEffect() za lokalno skladište?
Snimanje učitavanje podataka iz localStorage.
Učitavanje:
useEffect(() => {

const savedTheme = localStorage.getItem('theme');
if (savedTheme) {
setTheme(savedTheme);
}}, []); // Izvršava se samo jednom pri montaži komponente
Snimanje:
useEffect(() => {
localStorage.setItem('theme', theme);

}, [theme]); // Podaci se ažuriraju pri svakoj promeni `theme`
33
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje greškama u efektima
Kako rukovati greškama u asinhronim zadacima?Osigurajte da useEffect() pravilno
obrađuje potencijalne greške tokom asinhronih operacija.

useEffect(() => { async function fetchData() {
try {
const response = await fetch('https://api.example.com/data’);
const data = await response.json();

setData(data);
} catch (error) {
console.error('Greška pri preuzimanju podataka:', error);
}
} fetchData();

}, []);
Uvek obuhvatite asinhroni kod u try/catch blok.
34
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upotreba useEffect() za upravljanje fokusom
Postavljanje fokusa na element:
useEffect() se može koristiti za automatsko postavljanje fokusa na određeni
element nakon renderovanja.
useEffect(() => {
inputRef.current.focus();
}, []); // Fokus se postavlja pri montaži komponente
const inputRef = useRef();
return <input ref={inputRef} type="text" />;

35
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rezime lekcije
Sporedni efekti su radnje koje nisu direktno povezane sa glavnim procesom
funkcije, ali su ključne za dinamičnost aplikacija.

Mogu biti asinhroni (HTTP zahtevi) ili sinhroni (console.log(), lokalno skladište).
Uloga useEffect() Hook-a:

• Omogućava sigurno upravljanje sporednim efektima u React aplikacijama.
• Koristi niz zavisnosti za kontrolisanje učestalosti izvršavanja efekata.
Pravila za zavisnosti:

• Dodajte sve vrednosti koje utiču na efekat.
• Izuzeci uključuju spoljne funkcije, funkcije za ažuriranje stanja i lokalne
promenljive.
Funkcije za čišćenje:

• Neophodne za upravljanje resursima poput tajmera, intervala i pretplata.
• Sprečavaju curenje memorije i poboljšavaju stabilnost aplikacije.
36
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rezime lekcije
Korišćenje useCallback() i destrukturiranja:
Memorisanjem funkcija i objekata smanjuje se nepotrebno izvršavanje efekata.
Destrukturiranje objekata pomaže u izbegavanju problema sa zavisnostima.
Upravljanje asinhronim efektima:
Ne koristite async direktno u useEffect().
Koristite unutrašnje asinhrone funkcije ili promise sa .then() metodom.

Najbolje prakse:
Kombinujte efekte samo kada su logički povezani.
Razdvajajte efekte sa različitim zavisnostima radi bolje organizacije koda.
useEffect() je ključan alat za upravljanje sporednim efektima u React-u. Pravilno
razumevanje i implementacija efekata povećavaju efikasnost i stabilnost aplikacija,
istovremeno omogućavajući dinamično korisničko iskustvo.

37
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Zadaci za vežbu
Kreirajte React komponentu koja prikazuje broj klikova na dugme. Koristite
useEffect() da ispišete u konzoli poruku svaki put kada se broj klikova promeni.

Kreirajte React komponentu koja koristi useEffect() za preuzimanje i prikazivanje
liste korisnika sa API-ja (npr. https://jsonplaceholder.typicode.com/users).
Napravite komponentu koja prikazuje preostalo vreme odbrojavanja od 10
sekundi. Koristite useEffect() za postavljanje tajmera i ažuriranje stanja.
Napravite komponentu koja preuzima podatke sa API-ja i rukuje greškama ako
preuzimanje ne uspe. Prikazujte korisniku odgovarajuću poruku o grešci.

38
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba

39
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Reference u React-u
Oznaka predmeta: IT354
Naziv predmeta: Veb sistemi 1
Predavanje:
#8
Predavači:
Doc. dr Mladen Opačić - Beograd
Msc. Nikola Dimitrijević - Niš
Školska godina:
2024/2025. jesenji semestar

Pojam reference(ref) u React-u?
Postoje scenariji i slučajevi upotrebe u kojima je uprkos korišćenju
React-a, i dalje potrebno da se direktno pristupa DOM elementima.
Na primer, da bi se pročitala vrednost koju je korisnik uneo u polje za
unos ili promenila pozicija novoumetnutog elementa u DOM-u koju je
React automatski odabrao.
React pruža određene funkcionalnosti koje pomažu u upravo ovakvim
situacijama preko portala i referenci.

2
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pojam reference(ref) u React-u? #2
React ima poseban Hook useRef koji se može koristit za
pristup DOM elementima.
Ref je skraćenica za referencu, i to je funkcionalnost koja
omogućava referenciranje elemenata unutar React
komponente.
Hook useRef omogućava kreiranje promenljive reference
koja se održava kroz ponovna renderovanja komponente.
Ovaj hook se često koristi za čuvanje vrednosti ili referenci
koje treba sačuvati između renderovanja, a da se pri tome
ne izazivaju ponovna renderovanja.
Pored toga, useRef se može koristiti za pristup DOM čvoru ili
instanci React komponente.
3
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useRef Hook
useRef Hook se koristi za generisanje objekta reference
Ovaj generisani objekat reference, zatim se može dodeliti bilo kom JSX
elementu.
Ova dodela se vrši putem posebnog prop-a (ref prop-a) koji je
automatski podržan od strane svakog JSX elementa.
Ref prop obezbeđuje React. Ref prop zahteva ref objekat, na primer,
onaj koji je kreiran putem useRef().
Kada se kreira ref objekat i dodeli se, može se koristiti za pristup
povezanom JSX elementu.
Da bi se pristupilo povezanom elementu, to se mora uraditi preko
posebnog current prop-a na kreiranom ref objektu.
Ovo je neophodno, jer React čuva vrednost dodeljenu ref objektu u
ugnježdenom objektu, dostupnom putem current svojstva, kao što je
prikazano na donjem primeru.
4
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useRef Hook
import { useRef } from 'react';
function EmailForm() {
const emailRef = useRef();
// ostali kod ...
};
return (
<form className={classes.form} onSubmit={submitFormHandler}>
<label htmlFor="email">Vaša e-mail adresa</label>
<input
ref={emailRef}
type="email"
function submitFormHandler(event) {
id="email"
event.preventDefault();
/>
const enteredEmail = emailRef.current.value;
// ostali kod ...
// .current je obavezan!
</form>
// ovde bi mogla da se pošalje enteredEmail vrednost na server
};
5
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useRef – primer 1
import React, { useRef } from "react";
export default function App() {
const inputRef = useRef(null);
const focusInput = () => {
inputRef.current.focus(); // Fokusiramo input polje
};

return (
<div>
<h1>useRef Example: DOM Access</h1>
<input ref={inputRef} type="text" placeholder="Type something"
/>
<button onClick={focusInput}>Focus Input</button>
</div>
);
}
6
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useRef – Primer 2 Tajmer
useRef se može koristiti za čuvanje ID tajmera kada koristimo setTimeout ili
setInterval.

7
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

import React, { useRef, useState } from "react";

export default function App() {
const [count, setCount] = useState(0);
const intervalRef = useRef(null);
const startCounter = () => {
intervalRef.current = setInterval(() => {
setCount((prev) => prev + 1);
}, 1000);
};
const stopCounter = () => {
clearInterval(intervalRef.current); // Zaustavljamo tajmer
};
return (
<div>
<h1>useRef Primer: Timer</h1>
<p>Count: {count}</p>
<button onClick={startCounter}>Start</button>
<button onClick={stopCounter}>Stop</button>
</div>
);
}

© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

8

Razlika između useRef i useState
Reference mogu biti vrlo dobra alternativa u slučajevima kao što je onaj prikazan
na primeru, kada je potreban samo pristup za čitanje elementa.

Ovo je vrlo često slučaj kada se radi sa korisničkim unosom.
Generalno, reference mogu zameniti stanje ako se samo pristupa nekoj
vrednosti radi njenog čitanja kada se neka funkcija (na primer, funkcija za
obradu slanja formulara) izvrši.
Čim zatreba promena vrednosti i te promene moraju biti reflektovane u
korisničkom interfejsu, reference više nisu adekvatne.

9
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje Refs-a za više od pristupa DOM-u
Reference nisu samo za povezivanje elemenata, oni su objekti koji se mogu koristiti za
čuvanje svih vrsta vrednosti, ne samo pokazivača na DOM objekte.
const passwordRetries = useRef(0);

Moguće je proslediti početnu vrednost useRef() (0 u ovom primeru) i zatim pristupiti toj
vrednosti ili je promeniti u bilo kom trenutku unutar komponente kojoj referenca pripada:
passwordRetries.current = 1;
I dalje se mora koristiti svojstvo current da bi se čitala i menjala sačuvanu vrednost, jer, kao
što je ranije pomenuto.

React čuva stvarnu vrednost dodeljenu ref objektu u ugnježdenom objektu, dostupnom
putem svojstva current.
Ovo može biti korisno za čuvanje podataka koji bi trebali "preživeti" rerenderovanje
komponente.
React će izvršavati funkcije komponenata svaki put kada se promeni stanje komponente.

Pošto se funkcija ponovo izvršava, bilo koji podaci sačuvani u promenljivama unutar funkcije
biće izgubljeni.

10
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prosleđivanje referenci sa forwardRef
Korišćenje React.forwardRef omogućava prosleđivanje referenci (ref) iz
roditeljskih komponenti ka komponentama koje nisu DOM elementi.
Ovo je korisno kada želite pristupiti ili manipulisati DOM elementima unutar
child komponente.
React.forwardRef() je pomoćna funkcija koja omogućava prosleđivanje referenci
iz roditeljske komponente u funkcionalnu komponentu dete.
U React-u, prosleđivanje referenci roditelja je važno, jer funkcionalne
komponente po defaultu nemaju atribut ref i ne prihvataju referencu roditelja
kao prop.
Prosleđivanje referenci iz roditeljske u funkcionalnu komponentu deteta igra
ključnu ulogu u manipulaciji DOM čvorovima unutar deteta.

const Preferences = forwardRef((props, ref) => {
// kod komponente ...
});
export default Preferences;

11
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prosleđivanje referenci sa forwardRef #2
Da bi se prosledili ref-ove, morate obmotati komponentu koja prima ref (u ovom
primeru Preferences) specijalnom funkcijom koju pruža React: forwardRef().

Ovo izgleda malo drugačije od ostalih komponenti koje smo koristili u primerima,
jer se koristi streličasta(arrow) funkcija umesto ključne reči function.
Uvek se mogu koristiti streličaste funkcije umesto "normalnih funkcija", ali ovde
je korisno prebaciti se, jer olakšava obmotavanje funkcije sa forwardRef().
Alternativno, može se zadržati ključna reč function i obmotati funkciju ovako:
function Preferences(props, ref) {
// kod komponente ...
}
export default forwardRef(Preferences);

12
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prosleđivanje referenci sa forwardRef #3
Zanimljiv deo ovog koda je da funkcija komponente sada prima dva parametra
umesto jednog.

Pored primanja props, što funkcije komponenata uvek rade, sada prima i
specijalan ref parametar.
I ovaj parametar se prima samo zato što je funkcija komponente obmotana sa
forwardRef().
Ovaj ref parametar će sadržati bilo koju ref vrednost koja je postavljena od
strane komponente koja koristi roditeljsku komponentu.

13
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prosleđivanje referenci sa forwardRef #4
React dodaje ref atribut automatski u JSX DOM čvorove.
Ovo se dešava postavljanjem ref atributa na DOM elemente tokom montiranja
komponente.
ref atribut se može ručno dodati i na JSX elemente i na React klase komponenti.
Međutim, funkcionalne komponente u React-u nemaju instance, jer su to
JavaScript funkcije.
Stoga, React funkcionalna komponenta ne može imati dodeljen ref atribut.

Ovo znači da vlasnik vrednosti reference (obično roditeljska komponenta) ne
može povezati vrednost reference sa funkcionalnim komponentama deteta i
bilo kojim JSX čvorom unutar njih.

14
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

import React, { useRef } from "react";
export function Form() {
const inputRef = useRef(null);
const handleClick = () => inputRef.current.focus();
return (
<div className="form">
<Input label="Title" ref={inputRef} />
<button className="button" onClick={handleClick}>
Focus Title Field
</button>
</div>
);
}
export const Input = React.forwardRef((props, inputRef) => {
const { label, ...otherProps } = props;
return (
<div className="form-control">
<label className="form-label">{label}</label>
<input className="form-field" {...otherProps} ref={inputRef} />
</div>
);
});
15
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prosleđivanje referenci sa forwardRef #6
Na primeru na prošlom slajdu se vidi kako Form komponenta prosleđuje
inputRef svojoj komponenti dete Input što zatim omogućava da se klikom na
dugme fokus prebaci na <input> element unutar komponente Input.
Prosleđivanje ref-ova je metoda koja se može koristiti za omogućavanje saradnje
između komponenti Form i Input.
Iako na prvi pogled može izgledati kao elegantno rešenje, to ne bi trebalo da
bude podrazumevana metoda za rešavanje ovakvih problema.
Korišćenje prosleđivanja ref-ova, kao što je prikazano u prethodnom primeru,
dovodi do više imperativnog koda.
To je imperativni kod, jer umesto da se definiše željeno stanje korisničkog
interfejsa putem JSX-a (što bi bilo deklarativno), u JavaScript se dodaju
pojedinačne instrukcije korak po korak.

16
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Custom dugme sa prosleđenom referencom
Koristi se forwardRef da bi roditeljska komponenta mogla pristupiti
DOM elementu button unutar child komponente CustomButton.
Roditeljska komponenta može izvršiti akcije na dugmetu, kao što su
simulacija klika (click() metoda), promena stila ili
omogućavanje/disabling dugmeta.
import React, { useRef, forwardRef } from "react";
const CustomButton = forwardRef((props, ref) => {
return (
<button ref={ref} {...props}>
{props.children}
</button>
);
});
17
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Custom dugme sa prosleđenom referencom
function ForwardRefButton() {
const buttonRef = useRef(null);
const clickButton = () => {
buttonRef.current.click(); // Simuliramo klik na dugme
};
return (
<div>
<h1>Custom Button with Forward Ref</h1>
<CustomButton ref={buttonRef} onClick={() => alert("Button
clicked!")}>
Click Me
</CustomButton>
<button onClick={clickButton}>Trigger Click</button>
</div>
);

}
18
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Upravljanje višestrukim referencama
Može se koristiti forwardRef da bi svako input polje u formi imalo svoju
referencu, što omogućava roditeljskoj komponenti da upravlja svakim poljem
zasebno.
Kod složenih formi, ovo omogućava fleksibilno upravljanje pojedinačnim poljima
(fokus, validacija, resetovanje) bez potrebe za dodatnim stanjima u
komponenti.
import React, { useRef, forwardRef } from "react";
const FormField = forwardRef(({ label, ...props }, ref) =>
{
return (
<div>
<label>{label}</label>
<input ref={ref} {...props} />
</div>
);
});

19
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

function MultipleRefs() {
const nameRef = useRef(null);
const emailRef = useRef(null);
const focusEmail = () => {
emailRef.current.focus(); // Fokus na email polje
};
return (
<div>
<h1>Form with Multiple Forward Refs</h1>
<FormField ref={nameRef} label="Name:" placeholder="Enter your
name" />
<FormField ref={emailRef} label="Email:" placeholder="Enter your
email" />
<button onClick={focusEmail}>Focus Email</button>
</div>
);

}

20
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kontrolisane i nekontrolisane komponente
Kada se koriste ref-ovi za čitanje ili manipulaciju podacima, kao što je prikazano
u prethodnim slajdovima, kreiraju se takozvane nekontrolisane komponente.

Komponente se smatraju "nekontrolisanim", jer React direktno ne kontroliše
stanje korisničkog interfejsa.
Umesto toga, vrednosti se čitaju iz drugih komponenti ili DOM-a.
Trebalo bi pokušati da se minimizira upotreba nekontrolisanih komponenti.
Sasvim je u redu koristiti ref-ove za uštedu koda ako samo trebate prikupiti neke
unete vrednosti.
Čim logika korisničkog interfejsa postane složenija (na primer, ako želite da
obrišete korisnički unos), trebalo bi da se pređe na kontrolisane komponente.
Prelazak na kontrolisane komponente je prilično jednostavan: komponenta
postaje kontrolisana čim React počne da upravlja stanjem.

Smatra se dobrom praksom da se u većini slučajeva koriste kontrolisane
komponente.

21
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Portali u Reactu #1
Još jedna važna React funkcionalnost koja omogućava indirektnu
interakciju sa DOM-om su Portali.
U nekim scenarijima, možda postoji razlog da se uslovni DOM
element umetne na drugo mesto u DOM-u. Na primer, kada se
radi sa modalima kao što su dijalozi grešaka.
Portal u React-u je funkcionalnost koja omogućava da se
specificira gde React treba da ubaci DOM element na drugo
mesto u DOM-u umesto mesta gde bi to normalno uradio.

22
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Portali u Reactu #2
Funkcionalnost portala može se koristiti da React ne ubaci
elemente <dialog> greške i <div> pozadine unutar <form>
elementa, već da umesto toga umetne te elemente na kraj
<body> elementa.
<body>
<noscript>You need to enable JavaScript to run this
app.</noscript>
<div id="root"></div>
<div id="dialogs"></div>
</body>
23
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Portali u Reactu #3
Da bi se koristila ovu funkcionalnost portala, prvo se mora definisati mesto u
koje se elementi mogu umetnuti (mesto za "injekciju").

Ovo se može uraditi u HTML fajlu koji pripada React aplikaciji (tj.
public/index.html). Tamo se može dodati novi element (na primer, <div>
element) na kraju <body> elementa.

24
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

import { createPortal } from 'react-dom';
import classes from './ErrorDialog.module.css';
function ErrorDialog({ onClose }) {
return createPortal(
<>
<div className={classes.backdrop}></div>

<dialog className={classes.dialog} open>
<p>
Ova forma sadrži pogrešne vrednosti. Molimo vas da ispravite te greške pre nego što
ponovo pošaljete formu!
</p>

<button onClick={onClose}>U redu</button>
</dialog>
</>,
document.getElementById('dialogs')
);
}
25

export default ErrorDialog;

© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Portali u Reactu #5
U ovom slučaju, element <div id="dialogs"> je dodat na kraj
<body> elementa kako bi se osiguralo da sve komponente
(i njihovi stilovi) umetnuti u taj element budu poslednji
evaluirani.
To će osigurati da njihovi stilovi imaju veći prioritet i da
elementi umetnuti u <div id=„dialogs"> ne budu prekriveni
drugim sadržajem koji dolazi ranije u DOM-u.
Sa ovako prilagođenim index.html fajlom, može se uputiti
React da renderuje određene JSX elemente (tj.
komponente) u određenom mestu za injekciju putem
createPortal() funkcije iz react-dom paketa

26
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Portali u Reactu #6
Unutar komponente ErrorDialog, koja se uslovno renderuje unutar druge komponente
(npr. EmailForm), vraćeni JSX kod je obmotan funkcijom createPortal(). createPortal()
prima dva argumenta: JSX kod koji treba biti renderovan u DOM-u i pokazivač na
element u index.html gde sadržaj treba biti umetnut.
Novododati <div id="dialogs"> je izabran putem document.getElementById(‘dialogs‘).
Stoga, createPortal() osigurava da se JSX kod generisan od strane ErrorDialog renderuje
na tom mestu u HTML dokumentu.

27
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: Modalni prozor
import React, { useState } from "react";
import ReactDOM from "react-dom";
function ModalPortal({ isOpen, onClose, children }) {
if (!isOpen) return null;
return ReactDOM.createPortal(
<div style={styles.overlay}>
<div style={styles.modal}>
<button onClick={onClose}
style={styles.closeButton}>Close</button>
{children}
</div>
</div>,
document.getElementById("modal-root")
);
}

28
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

import ModalPortal from "./ModalPortal";
import { useState } from 'react'
function ModalParent() {
const [isModalOpen, setModalOpen] = useState(false);
return (
<div>
<h1>React Portals Example</h1>
<button onClick={() => setModalOpen(true)}>Open
Modal</button>
<ModalPortal isOpen={isModalOpen} onClose={() =>
setModalOpen(false)}>
<h2>This is a modal</h2>
<p>Rendered using React Portals!</p>
</ModalPortal>
</div>
);
}

export default ModalParent;

29
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Index.html
<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<link rel="icon" type="image/svg+xml" href="/vite.svg" />
<meta name="viewport" content="width=device-width, initialscale=1.0" />
<title>Vite + React</title>
</head>
<body>
<div id="root"></div>
<div id="modal-root"></div>
<script type="module" src="/src/main.jsx"></script>
</body>
</html>

30
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Projekat
Razviti kompletnu web aplikaciju koristeći React framework, implementirajući
funkcionalnosti kao što su registracija korisnika, pregled i interakcija sa sadržajem,
uz mogućnost administrativne manipulacije podacima.
Studenti će razviti web aplikaciju na osnovu zadate teme. Asistent dodeljuje teme iz
liste ili student može predložiti sopstvenu temu uz odobrenje asistenta.
Svaki projekat treba da ima dva aktora i bar tri entiteta. Na primer za prodavnicu to
će biti Korisnik i Administrator. A entiteti Korisnici, Artikli … itd.
Asistent takođe studentu zadaje jednu posebnu funkcionalnost tako da svaki student
dobije poseban projekat. Takođe, za najvišu ocenu zadaje korišćenje biblioteke
koja nije rađena na času. Npr. bilioteka yup za validaciju inputa.
Ocenjivanje:
Kompletan projekat urađen u tehnologijama sa časa bez posebne funkcionalnost
nosi 15 poena.
Urađena posebna funkcionalnost donosi još 5 poena.
Korišćena eksterna biblioteka donosi još 5 poena što u zbiru donosi maksimalnih 25

31
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primeri tema:
• Online biblioteka za razmenu knjiga.
• Aplikacija za praćenje troškova.

• Sistem za upravljanje rezervacijama sportskih termina.
• Portal za planiranje putovanja.
• Blog platforma sa administrativnim panelom.
Aplikacija mora da radi i sadrži osnovne funkcionalnosti prema odabranoj temi.

32
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Aktivnosti koje treba realizovati i zatim dokumentovati u
izveštaju koji se predaje zajedno sa kodom
Planiranje i dizajn sistema:
• Definisati funkcionalne i nefunkcionalne zahteve sistema.

• Kreirati use-case dijagrame za korisnike i administratore.
• Definisati arhitekturu aplikacije, uključujući strukturu React komponenti i način
upravljanja stanjem.

33
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Razvoj korisničkog interfejsa (UI):
• Koristiti React za frontend.
• Stilizaciju realizovati koristeći jednu od sledećih tehnologija:

CSS (moduli, običan CSS ili Sass).
Styled Components.
Tailwind CSS.
Bilo koja druga biblioteka po izboru.

34
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Aplikacija treba da sadrži sledeće stranice:
Početnu stranicu.
Stranicu za registraciju i prijavu korisnika.

Stranicu za pregled podataka (listu predmeta, rezervacija, aktivnosti itd., u
zavisnosti od teme).
Stranicu za detaljan prikaz jednog elementa sa mogućnošću interakcije.
Administrativni panel za manipulaciju podacima.

35
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Implementacija funkcionalnosti
• Korisničke funkcionalnosti:
Registracija i prijava korisnika.

Zaštita ruta, neregistrovani korisnik ne može da pristupi rutama registrovanog
korisnika, registrovani korisnik ne može da pristupi rutama administratora.
Pregled lista podataka sa detaljnim prikazom svakog elementa.
Dodavanje i brisanje ili ažuriranje podataka (u zavisnosti od teme).
• Administratorske funkcionalnosti:
Kreiranje, ažuriranje i brisanje podataka.
Pregled korisničkih aktivnosti ili unosa

36
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Podaci i simulacija backend-a:
• Backend funkcionalnosti simulirati korišćenjem json-server alata.

• Studenti koji poznaju neku drugu backend tehnologiju (Node.js, Django,
Laravel, itd.) mogu je koristiti po sopstvenom izboru
• Aplikacija MORA koristiti sledeće biblioteke:
React (za komponentnu arhitekturu).
react-dom (za renderovanje na web-u).
react-router (za upravljanje rutama).
• Backend mora biti povezan sa aplikacijom i omogućiti dinamičku manipulaciju
podacima.

37
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pravila za predaju projekta:
• Projekat se predaje u formi React aplikacije na GitHub repozitorijumu.

• Dokument urađen prema zahtevima za izradu projektnog rada
Rok za predaju:
• Projekat treba predati najkasnije do kraja 15. nedelje nastave.
Dodatne napomene:
• Aplikacija mora da funkcioniše kako bi bila ocenjena.
• Studenti koji predaju projekat pre roka dobijaju dodatne poene za aktivnost.
• Odbrana projekta podrazumeva demonstraciju funkcionalnosti i odgovore na
pitanja asistenta.

38
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Optimizacija u React-u
Oznaka predmeta: IT354
Naziv predmeta: Veb sistemi 1
Predavanje:
#9
Predavači:
Doc. dr Mladen Opačić - Beograd
Msc. Nikola Dimitrijević - Niš
Školska godina:
2024/2025. jesenji semestar

Ažuriranje interfejsa u React-u detaljnije

2
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Uvod
U dosadašnjim lekcijama naučili smo dovoljno React-a da možemo da napravimo
poprilično kompleksne interfejse.

Sa ovom kompleksnošću počinju da u prvi plan dolaze teme kao što su
optimizacija i preformanse aplikacije.
Ova lekcija omogućava dublje razumevanje kako neki od internih mehanizama
React-a funkcionišu.
Biće pokazano kako React izračunava potrebna ažuriranja DOM-a i kako
osigurava da ta ažuriranja budu izvršena bez negativnog uticaja na
performanse.
Govori se i o raznim ugrađenim funkcijama i konceptima koji se modu koristiti za
dalju optimizaciju performansi aplikacije.

3
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Evaluacija i ažuriranje komponenti
Funkcije komponenti se izvršavaju kad god se promeni njihovo unutrašnje stanje
ili kad se ponovo izvrši funkcija roditeljske komponente.

Kada se pozove funkcija roditeljske komponente, njen ceo JSX kod (koji sadrži i
poziv dete komponente) se ponovo evaluira.
Sve funkcije komponenti koje su referencirane u tom JSX kodu se stoga takođe
ponovo pozivaju.

4
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

function Roditelj() {
console.log('<Roditelj /> je pozvana.');
const [counter, setCounter] = useState(0);
function incCounterHandler() {
setCounter((prevCounter) => prevCounter + 1);
}
return (
<div id="roditelj">
<p>Komponenta, ugnježdena u App,
koja sadrži drugu komponentu (Dete).</p>
<p>Brojač: {counter}</p>
<button onClick={incCounterHandler}>Povećaj</button>
<Dete />
</div>
);
}
function Dete() {
console.log('<Dete /> je pozvana.');
return (
<div id="dete">
<p>Komponenta, renderovana unutar druge komponente, koja
sadrži još jednu komponentu.</p>
<DetetovoDete />
</div>
);
}
function DetetovoDete() {
console.log('<DetetovoDete /> je pozvana.');
return <p id="detetovo-dete">Komponenta, duboko ugnježdena u stablo
komponenti.</p>;
}
5
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer pozivanja komponenti
U ovoj strukturi, Roditelj komponenta renderuje <div> sa dva paragrafa,
dugmetom i još jednom komponentom: Dete komponentom.
Ta komponenta, zauzvrat, renderuje <div> sa paragrafom i još jednom
komponentom: DetetovoDete
Roditelj komponenta takođe upravlja stanjem brojača, koje se menja kad god se
klikne na dugme.
Sve tri komponente ispisuju poruku putem console.log(), jednostavno da bi se
videlo svaki put kada komponenta bude pozvana od strane React-a.
Na slici se jasno vidi da će nakon svakog klika na dugme sve tri komponente biti
pozvane ponovo.

6
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

7
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer pozivanja komponenti objašnjenje
Na prethodnoj slici može se videti ne samo kako su komponente ugnježdene jedna u
drugu, već i kako ih sve React poziva kada se klikne na dugme Povećaj.

Dete i DetetovoDete komponente su pozvane iako ne upravljaju niti koriste bilo kakvo
stanje.
Pošto su one dete ili potomak Roditelj komponente, koja je primila promenu stanja,
funkcije ugnježdenih komponenti se takođe pozivaju.
Razumevanje ovog toka izvršavanja funkcija komponenti je važno, jer ovaj tok implicira
da svako pozivanje funkcije komponente takođe utiče na njene potomke.

8
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer pozivanja komponenti objašnjenje #2
Takođe, pokazuje koliko često React može pozivati funkcije komponenti i
koliko funkcija komponenti može biti pogođeno jednom promenom
stanja.
Šta se dešava sa stvarnim DOM-om stranice, sa učitanim i renderovanim
veb-sajtom u pretraživaču, kada se pozove jedna ili više funkcija
komponente?
Da li se DOM ponovo kreira?
Da li se ažurira renderovani UI?

9
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer pozivanja komponenti objašnjenje #3
Kad god se izvrši funkcija komponente, React procenjuje da li je potrebno
ažuriranje renderovanog korisničkog interfejsa (tj. DOM-a učitane stranice).

React procenjuje da li je ažuriranje potrebno. Poziv dakle ne znači automatski da
će se DOM ažurirati.
React ne odbacuje trenutni DOM i zamenjuje ga novim DOM-om (koji implicira
JSX kod), samo zato što je izvršena funkcija komponente.
React prvo proverava da li je ažuriranje potrebno. Ako je potrebno, samo delovi
DOM-a koji treba da se promene se zamenjuju ili ažuriraju.
Za određivanje da li je ažuriranje potrebno (i gde), React koristi koncept pod
nazivom virtuelni DOM.

10
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Virtuelni DOM vs. Realni DOM
React upoređuje trenutnu strukturu DOM-a sa strukturom koju implicira JSX kod vraćen
iz izvršenih funkcija komponenti.

Ako postoji razlika, DOM se ažurira u skladu s tim; u suprotnom, ostaje netaknut.
Kao što je manipulacija DOM-om relativno intenzivna za performanse, isto tako je i
čitanje DOM-a.
Čak i bez promene bilo čega u DOM-u, pristupanje DOM-u, prelazak kroz DOM elemente
i izvlačenje strukture iz njega je nešto što obično želite smanjiti na minimum.

11
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Virtuelni DOM vs. Realni DOM
Ako se više funkcija komponenti izvrši i svaka pokrene proces u kojem se
čitaju i upoređuju renderovani DOM elementi sa JSX strukturom koju
impliciraju pozvane funkcije komponenti, DOM će biti podvrgnut
višestrukim operacijama čitanja u vrlo kratkom vremenskom okviru.
Za veće React aplikacije koje se sastoje od desetina, stotina ili čak hiljada
komponenti postoji velika verovatnoća da bi se veb aplikacija korisniku činila
sporom ili "zaglavljenom".
Zbog toga React ne koristi pravi DOM da bi odredio da li su potrebna
ažuriranja korisničkog interfejsa.
Umesto toga, on interno konstruiše i upravlja virtualnim DOM-om
reprezentacijom DOM-a u memoriji, koja se renderuje u pretraživaču.
Virtualni DOM nije funkcija pretraživača, već funkcija React-a.

12
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Virtuelni DOM vs. Realni DOM
React upravlja ovim virtualnim DOM-om jer je upoređivanje ovog virtualnog
DOM-a sa očekivanim stanjem korisničkog interfejsa mnogo manje intenzivno
za performanse nego pristupanje realnom DOM-u.
Kad god se pozove funkcija komponente, React upoređuje vraćeni JSX kod sa
odgovarajućim čvorovima virtualnog DOM-a uskladištenim u virtualnom
DOM-u.
Ako se otkriju razlike, React će odrediti koje promene su potrebne da bi se
DOM ažurirao.
Nakon što se potrebna prilagođavanja izvedu, te promene se primenjuju i na
virtualni i na realni DOM.
Ovo osigurava da realni DOM odražava očekivano stanje korisničkog interfejsa
bez potrebe da se konstantno pristupa ili ažurira.

13
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izbegavanje nepotrebnih evaluacija

14
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izbegavanje nepotrebnih evaluacija child
komponenti sa memo()
Kao što je objašnjeno u prvom delu ovog predavanja kad god se funkcija
komponente pozove bilo koje ugnježdene funkcije komponenti će takođe biti
pozvane.
Često se dešava da te ugnježdene komponente zapravo ne moraju ponovo da se
evaluiraju.
One možda ne zavise od vrednosti stanja koje se promenilo u roditeljskoj
komponenti, a možda čak ni od bilo koje vrednosti roditeljske komponente.

15
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

function Form() {
const [enteredEmail, setEnteredEmail] = useState('');
const [errorMessage, setErrorMessage] = useState();

function updateEmailHandler(event) {
setEnteredEmail(event.target.value);
}
function submitHandler(event) {
event.preventDefault();
if (!enteredEmail.endsWith('.com')) {
setErrorMessage('Email mora završavati sa .com.');
}
}

}

return (
<form className={classes.form} onSubmit={submitHandler}>
<div className={classes.control}>
<label htmlFor="email">Email</label>
<input
id="email"
type="email"
value={enteredEmail}
onChange={updateEmailHandler}
/>
</div>
<Error message={errorMessage} />
<button>Registruj se</button>
</form>
);
16
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer bez memo()
function Error({ message }) {
if (!message) {
return null;
}
return <p className={classes.error}>{message}</p>;
}

17
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer bez memo()
Error komponenta se oslanja na prop message, koji je postavljen na
vrednost koja se čuva u stanju errorMessage komponente Form.
Form komponenta takođe upravlja stanjem enteredEmail, koje se ne
koristi (niti prima putem props-a) od strane Error komponente.
Promene u stanju enteredEmail će uzrokovati ponovno izvršavanje Error
komponente, iako toj komponenti ta vrednost nije potrebna.
Funkcija Error komponente izvršava se pri svakom pritisku tastera na
polju za unos
React nudi još jednu ugrađenu funkciju koja se može koristiti za kontrolu
(i sprečavanje) ovakvog ponašanja: funkciju memo().

18
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

memo() funkcija u React-u
Korišćenjem memo(), React može da izbegne nepotrebna ponovno pozivanja funkcija
child komponenti, čime se poboljšavaju performanse aplikacije i izbegavaju nepotrebna
poređenja u virtualnom DOM-u.
Kada želite da zaštitite komponentu od nepotrebnih ponovnih evaluacija koje su inicirane
od strane roditeljske komponente, možete obaviti funkciju te komponente unutar
memo().

import { memo } from 'react';
import classes from './Error.module.css';
function Error({ message }) {
console.log('<Error /> component function is executed.');
if (!message) {
return null;
}
return <p className={classes.error}>{message}</p>;
}
export default memo(Error);
19
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

memo() funkcija u React-u
Ovo uzrokuje da React proveri da li su se props vrednosti te komponente
promenile u poređenju sa poslednjim pozivanjem funkcije
komponente.
Ako su props vrednosti iste, funkcija komponente se ne izvršava ponovo.
Dodavanjem memo() funkcije izbegavaju se nepotrebna pozivanja
funkcije komponente, kao što je prikazano u prethodnom primeru.
Poruke više nisu ispisane u konzoli, što pokazuje da su nepotrebna
pozivanja funkcije komponente izbegnuta.

20
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

memo() funkcija u React-u
Funkcija memo() takođe prihvata opcioni drugi argument koji može biti korišćen
za dodavanje vaše logike kojom će se odrediti da li su props vrednosti
promenjene ili ne.
Ovo može biti korisno se radi sa složenijim props vrednostima.
Opcioni drugi argument prosleđen memo() mora biti funkcija koja automatski
prima objekat prethodnih props i objekat sledećih props.
Funkcija zatim mora vratiti true ako komponenta treba ponovo da se evaluira i
false ako ne treba.
Često, drugi argument nije potreban jer podrazumevano ponašanje memo() (gde
se svi props porede po nejednakosti) je upravo ono što vam treba.

21
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

memo() funkcija u React-u
Može biti primamljivo obaviti svaku React funkciju komponente unutar memo().
Međutim to ne treba raditi zato što izbegavanje nepotrebnih ponovnih
evaluacija komponente korišćenjem memo() dolazi po ceni: poređenje props
vrednosti (starih i novih) takođe zahteva određeno izvršavanje koda.
Zbog toga memo() zaista ima smisla samo ako imate relativno jednostavne props
(tj. props bez duboko ugnježdenih objekata koje morate ručno porediti
pomoću funkcije za poređenje) i većina promena stanja roditeljske
komponente ne utiče na te props vrednosti child komponente.

Odlično mesto za korišćenje memo() je komponenta koja je relativno blizu vrha
stabla komponenti. Ako uspete da izbegnete nepotrebna izvršenja te jedne
komponente putem memo(), implicitno izbegavate i nepotrebna izvršenja svih
ugnježdenih komponenti ispod te jedne komponente.

22
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useMemo() Hook
Za situacije u kojima imate komponentu koja zahteva puno resursa i koja mora
biti ponovo izvršena, jer je neka vrednost prop promenjena koristi se
useMemo().
U takvim slučajevima, korišćenje memo() neće sprečiti ponovno izvršavanje
funkcije komponente. Ali prop koji se promenio možda nije potreban za
zadatak koji zahteva puno resursa, a koji se obavlja kao deo komponente.

23
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useMemo() Hook primer pre optimizacije
function sortItems(items) {
console.log('Sorting');
return items.sort(function (a, b) {
if (a.id > b.id) {
return 1;
} else if (a.id < b.id) {
return -1;
}
return 0;
});
}

function List({ items, maxNumber }) {
const sortedItems = sortItems(items);
const listItems = sortedItems.slice(0, maxNumber);
return (
<ul>
{listItems.map((item) => (
<li key={item.id}>
{item.title} (ID: {item.id})
</li>
))}
</ul>
);
}
export default List;
24
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useMemo() Hook primer pre optimizacije
List komponenta prima dve prop vrednosti: items i maxNumber. Ona zatim
poziva sortItems() da sortira stavke po id.

Nakon toga, sortirana lista se ograničava na određeni broj stavki (definisan sa
maxNumber).
Kao poslednji korak, sortirana i skraćena lista se prikazuje na ekranu pomoću
map() funkcije u JSX kodu.
U zavisnosti od broja stavki prosleđenih List komponenti, sortiranje može
potrajati značajno vreme (za vrlo duge liste, čak i do nekoliko sekundi).
To definitivno nije operacija koju želite da obavljate nepotrebno ili prečesto.
Lista treba da bude sortirana kada se items promeni, ali ne bi trebalo da se
sortira ako se promeni maxNumber—jer to ne utiče na stavke u listi (tj. ne
utiče na redosled).
Sa prikazanim kodom, sortItems() će se izvršiti kad god se promeni bilo koja od
dve prop vrednosti, bez obzira da li je to items ili maxNumber.

25
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useMemo() Hook primer
Funkcija memo() ovde neće pomoći, jer funkcija List komponente treba (i hoće)
da se izvrši kad god se promene items ili maxNumber. memo() ne pomaže u
kontroli delimičnog izvršavanja koda unutar funkcije komponente.
Za to možete koristiti drugu funkciju koju nudi React: useMemo() Hook.
useMemo() se može koristiti da obavi operaciju koja zahteva puno resursa. Da bi
ispravno funkcionisala, takođe morate definisati listu zavisnosti koje bi trebalo
da uzrokuju ponovno izvršavanje operacije.
To je slično useEffect() (koji takođe obuhvata operaciju i definiše listu
zavisnosti), ali ključna razlika je u tome što se useMemo() izvršava u isto vreme
kada i ostatak koda u funkciji komponente, dok useEffect() izvršava
obuhvaćenu logiku nakon što se izvršavanje funkcije komponente završi.
useMemo() postoji da bi kontrolisao izvršavanje zadataka koji zahtevaju puno
resursa.

Kako se koristi videćemo na sledećem slajdu.

26
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useMemo() Hook primer nakon optimizacije
import { useMemo } from 'react';
function List({ items, maxNumber }) {
const sortedItems = useMemo(
function () {
console.log('Sorting');
return items.sort(function (a, b) {
if (a.id > b.id) {
return 1;
} else if (a.id < b.id) {
return -1;
}
return 0;
});
},
[items]
);

}

const listItems = sortedItems.slice(0, maxNumber);
return (
<ul>
{listItems.map((item) => (
<li key={item.id}>
{item.title} (ID: {item.id})
</li>
))}
</ul>
);

export default List;

© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

27

useMemo() Hook primer nakon optimizacije
Ovim pristupom, sortItems() funkcija će se sada izvršiti samo kada se promeni
items vrednost.

Kada se promeni maxNumber, sortirana lista će se samo skratiti bez ponovnog
sortiranja što značajno poboljšava performanse u slučajevima kada je lista
dugačka.

28
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izbegavanje nepotrebnog ponovnog kreiranja
funkcija

29
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje useCallback()
U prethodnom predavanju pomenuli smo useCallback(). Kao što se useMemo()
može koristiti za "skupa" računanja, useCallback() se može koristiti za
izbegavanje nepotrebnog ponovnog kreiranja funkcija.
U kontekstu ove lekcije, useCallback() može biti koristan jer, u kombinaciji sa
memo() ili useMemo(), može pomoći da izbegnete nepotrebno izvršavanje
koda.
Može vam pomoći u slučajevima kada se funkcija prosleđuje kao prop (tj. kada
možete koristiti memo()), ili se koristi kao zavisnost u nekoj "skupoj" operaciji
(tj. možda rešeno putem useMemo()).
Na sledećem primeru se useCallback() može kombinovati sa memo() da bi se
izbeglo nepotrebno izvršavanje funkcija komponenata

30
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

function Form() {
const [enteredEmail, setEnteredEmail] = useState('');
const [errorMessage, setErrorMessage] = useState();
function updateEmailHandler(event) {
setEnteredEmail(event.target.value);
}
function submitHandler(event) {
event.preventDefault();
if (!enteredEmail.endsWith('.com')) {
setErrorMessage('Email mora završavati sa .com.');
}
}
const clearErrorHandler = useCallback(() => {
setErrorMessage(null);
}, []);
return (
<form className={classes.form} onSubmit={submitHandler}>
<div className={classes.control}>
<label htmlFor="email">Email</label>
<input
id="email"
type="email"
value={enteredEmail}
onChange={updateEmailHandler}
/>
</div>
<Error message={errorMessage}
onClearError={clearErrorHandler} />
<button>Registruj se</button>
</form>
31
);
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

}

useCallback()
Error komponenta je obavijena funkcijom memo() i zato će se izvršavati samo
ako se neka od prosleđenih prop vrednosti promeni. Error komponenta se
koristi u drugoj komponenti, Form, na način kao u na prethodnom slajdu.
Error komponenta prima pokazivač na funkciju clearErrorHandler (kao vrednost
za onClearError prop).
Sada, sa primerom i pokazivačem funkcije clearErrorHandler prosleđenim u
Error, memo() od ranije nažalost više ne bi sprečio izvršavanje funkcije
komponente.

Pošto se novi objekat funkcije kreira za svaku promenu stanja, clearErrorHandler
je tehnički drugačija vrednost za svako izvršavanje Form komponente.
Obavijanjem funkcije clearErrorHandler sa useCallback(), sprečava se ponovno
kreiranje funkcije, tako da se novi objekat funkcije ne prosleđuje Error
komponenti.

Tako memo() može detektovati jednakost između stare i nove vrednosti
onClearError propa i ponovo sprečava nepotrebna izvršavanja funkcija
komponenata.
32
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izbegavanje nepotrebnog preuzimanja koda

33
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izbegavanje nepotrebnog preuzimanja koda sa lazy
Nije idealno ako posetioci vašeg sajta moraju da preuzmu puno koda koji
možda nikada neće biti izvršen.
Svaki kilobajt JavaScript koda koji mora da se preuzme usporava početno
vreme učitavanja vaše veb stranice.
Zbog toga se puno truda ulaže u smanjenje veličine JavaScript paketa
koda.
React pruža funkciju lazy() koja se može koristiti za uslovno učitavanje koda
komponente (Lazy Loading)
Znači, samo kada je to zaista potrebno (umesto unapred).

34
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

const initialStartDate = new Date();
const initialEndDate = add(initialStartDate, { days: 1 });
function DateCalculator() {
const [startDate, setStartDate] = useState(
format(initialStartDate, 'yyyy-MM-dd')
);
const [endDate, setEndDate] = useState(format(initialEndDate, 'yyyyMM-dd'));
const daysDiff = differenceInDays(parseISO(endDate),
parseISO(startDate));
function updateStartDateHandler(event) {
setStartDate(event.target.value);
}
function updateEndDateHandler(event) {
setEndDate(event.target.value);
}
return (
<div className={classes.calculator}>
<p>Izračunajte razliku (u danima) između dva datuma.</p>
<div className={classes.control}>
<label htmlFor="start">Datum početka</label>
<input id="start" type="date"value={startDate}
onChange={updateStartDateHandler}
/>
</div>
<div className={classes.control}>
<label htmlFor="end">Datum završetka</label>
<input id="end" type="date“ value={endDate}
onChange={updateEndDateHandler}
/>
</div>
<p className={classes.difference}>Razlika: {daysDiff}
dana</p>
35
</div>
);
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izbegavanje nepotrebnog preuzimanja koda sa lazy
U ovom primeru, DateCalculator komponenta koristi nekoliko funkcija iz date-fns
biblioteke za formatiranje datuma i izračunavanje razlike u danima između dva
datuma.
Ako se ova komponenta retko koristi, učitavanje njenog koda unapred može
nepotrebno usporiti inicijalno vreme učitavanja aplikacije.
Ovde lazy() može biti korisna. Korišćenjem lazy() i React.Suspense, možemo
učitati DateCalculator komponentu samo kada je korisnik zaista zatraži,
smanjujući početno vreme učitavanja aplikacije.

36
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer Lazy loading
import { lazy, Suspense, useState } from 'react';
const DateCalculator = lazy(() =>
import('./components/DateCalculator'));
function App() {
const [showDateCalc, setShowDateCalc] = useState(false);
function openDateCalcHandler() {
setShowDateCalc(true);
}

return (
<>
<p>Funkcionalnosti koje će se učitati</p>
<p>
Dugme za otvaranje kalkulatora koji se učitava samo po
potrebi.
</p>
<button onClick={openDateCalcHandler}>Open Calculator</button>
<Suspense fallback={<p>Loading...</p>}>
{showDateCalc && <DateCalculator />}
</Suspense>
</>
);
}
37
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer Lazy loading
Koristimo funkciju lazy() iz React-a, koja omogućava da se komponenta učita samo kada je
zaista potrebna.

Umesto uobičajenog uvoza DateCalculator komponente, koristimo lazy() funkciju koja se
obavija oko dinamičkog import izraza:
import { lazy, useState } from 'react';

const DateCalculator = lazy(() => import('./components/DateCalculator'));

Ovaj kod obezbeđuje da se DateCalculator komponenta učita samo kada se zaista bude
prikazivala u aplikaciji.
Da bi React mogao da prikaže nešto dok se DateCalculator komponenta učitava, obavijamo
njeno uslovno renderovanje unutar Suspense komponente.
Suspense komponenta prima fallback prop, koji određuje šta će se prikazati dok se
dinamički učitana komponenta učitava

38
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer Lazy loading
Kao što ste već naučili, funkcija lazy() u React-u omogućava vam da uslovno
učitavate komponente, što može značajno smanjiti veličinu početnog paketa
JavaScript koda koji se preuzima prilikom prvog učitavanja aplikacije.
Kombinovanjem lazy() sa komponentom Suspense, možete prikazati privremeni
sadržaj (npr. poruku "Loading...") dok se željena komponenta učitava.
Kada koristite lazy(), JavaScript kod se deli na više manjih paketa (bundles).
Paket koji sadrži DateCalculator komponentu preuzima se samo kada je zaista
potreban u ovom slučaju, kada korisnik klikne na dugme.
Ako preuzimanje traje duže, sadržaj definisan u fallback prop-u komponente
Suspense će biti prikazan na ekranu dok se komponenta ne učita.
Tek kada korisnik klikne na dugme za otvaranje kalkulatora, dodatni kod se
preuzima, što optimizuje učitavanje i izvršavanje koda.

39
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba

40
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba
Primeri iz lekcije

41
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rad sa globalnim stanjem u React-u
Oznaka predmeta: IT354
Naziv predmeta: Veb sistemi 1
Predavanje:
#10
Predavači:
Doc. dr Mladen Opačić - Beograd
Msc. Nikola Dimitrijević - Niš
Školska godina:
2024/2025. jesenji semestar

Stanje u više komponenti

2
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Stanje u više komponenti
Stanje (state) je jedan od ključnih pojmova koje morate razumeti (i
koristiti) kako biste efikasno koristili React.
U React aplikacijama, stanje se obično upravlja uz pomoć useState()
Hook-a.
Međutim, kada počnete da gradite složenije React aplikacije, verovatno
ćete se suočiti sa različitim izazovima vezanim za stanje.
Primetićete da rešenja zasnovana samo na useState() postaju složena i
teško razumljiva i održiva.
Zato React nudi dodatne alate—alate kreirane za ovakve vrste
problema, koje ćemo u ovom poglavlju istaknuti i analizirati.

3
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

4
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Struktura aplikacije

5
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Struktura aplikacije #2
BookmarkInformation i BookmarkSummary su duboko ugnježđene.
Da bi im se prosledio props mora pravo da se presledi iz Home u News
Pa onda iz News u InfoSidebar.
Ovo je već poprilično zakomplikovanao
U realnim arlikacijama stablo komponenti može da ima mnogo više
nivoa
U takvim slučajevima aplikacija postaje jako komplikovana za održavanje

6
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

function Home() {
const [articles, setArticles] = useState([
{
id: '1',
title: 'First Article',
content: 'This is the first article content.',
isBookmarked: false
},
{
id: '2',
title: 'Second Article',
content: 'This is the second article content.',
isBookmarked: false
}
])
const toggleBookmark = (articleId) => {
setArticles(articles.map(article =>
article.id === articleId
? { ...article, isBookmarked: !article.isBookmarked }
: article
))
}
const bookmarks = articles.filter(article =>
article.isBookmarked)
//prosleđujemo komponenti News podatke pomoću "prop drillinga"
return (
<main className={styles.main}>
<News articles={articles}
bookmarks={bookmarks}
toggleBookmark={toggleBookmark}
/>
</main>
7
)
}
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

import BookmarkInformation from './BookmarkInformation'
import BookmarkSummary from './BookmarkSummary'
import styles from './info-sidebar.module.css'
function InfoSidebar({ bookmarks }) {
return (
<div className={styles.sidebarContainer}>
<BookmarkInformation bookmarks={bookmarks} />
<BookmarkSummary bookmarks={bookmarks} />
</div>
)
}

export default InfoSidebar;

8
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

import styles from './bookmark-summary.module.css'
function BookmarkSummary({ bookmarks }) {
return (
<div className={styles.card}>
<h3 className={styles.cardTitle}>Bookmark
Summary</h3>
<div className={styles.cardContent}>
<ul className={styles.bookmarkList}>
{bookmarks.map(bookmark => (
<li
key={bookmark.id}>{bookmark.title}</li>
))}
</ul>
</div>
</div>
)
}
export default BookmarkSummary;

9
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Context API

10
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useContext React Hook
U React-u, useContext je React Hook koji omogućava komponentama da
pristupe vrednostima iz Context-a bez potrebe za prosleđivanjem tih vrednosti
kroz props na svakoj nivou komponentnog stabla. Ovo čini deljenje stanja ili
podataka između udaljenih komponenti lakšim i efikasnijim.
Context u React-u omogućava deljenje podataka (kao što su tema, autentifikacija
korisnika, jezik aplikacije) između komponenti bez potrebe za prosleđivanjem
props-a kroz svaki nivo komponente.
useContext se koristi za pristup vrednostima koje je definisao Provider
određenog Context-a. Kada koristite useContext, komponenta će automatski
reagovati na promene u vrednostima Context-a i osvežiti se.

11
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prednosti/mane useContext
• Smanjuje potrebu za props drilling-om (prosleđivanje props-a kroz mnoge
komponente).

• Čini kod čitljivijim i modularnijim.
• Automatski osvežava komponente kada se promeni vrednost Context-a.
• useContext ne treba koristiti za globalno stanje aplikacije koje se jako često
menja. U takvim slučajevima, bolje je koristiti specijalizovane biblioteke za
upravljnje globalnim stanjem (Redux).

• Korišćenje useContext za veliki broj promenljivih može dovesti do čestih
ponovnih renderovanja komponenti.

12
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Context
React-ova context funkcionalnost omogućava kreiranje vrednosti koja
može biti lako podeljena između više komponenti, bez potrebe za
korišćenjem props-a.
Korišćenje context API-ja je višestepeni proces, a koraci su sledeći:
Potrebno je kreirati context vrednost koja će biti deljena.
Context mora biti obezbeđen u roditeljskoj komponenti komponenti
koje treba da pristupe context objektu.
Komponente koje trebaju pristup (bilo za čitanje ili pisanje) moraju se
pretplatiti na context.
React automatski upravlja context vrednošću (i njenim promenama)
interno i distribuira je svim komponentama koje su se pretplatile na
context.
import { createContext } from 'react';
createContext('Hello Context'); // context sa inicijalnom string
vrednošću
createContext({}); // context sa inicijalnim (praznim) objektom
kao
13
vrednošću
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kreiranje Context-a
Ova funkcija prihvata inicijalnu vrednost koja treba biti podeljena. Ta vrednost
može biti bilo koja vrsta podataka (npr. string ili broj), ali obično je to objekat.
Sve ove stavke se zatim grupišu u jedan context objekat.
Naravno, inicijalna context vrednost može biti i prazna (npr. null, undefined, prazan
string, itd.) ako je potrebno.

Funkcija createContext() takođe vraća vrednost: context objekat koji bi trebalo
da se skladišti u promenljivu (ili konstantu) sa velikim početnim slovom jer
sadrži ugnježđeno svojstvo koje je React komponenta

import { createContext } from 'react';
createContext('Hello Context'); // context sa inicijalnom string vrednošću
createContext({}); // context sa inicijalnim (praznim) objektom kao vrednošću

14
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje createContext()
import { createContext } from 'react';
const BookmarkContext = createContext({
bookmarkedArticles: []
});
export default BookmarkContext; // omogućava dostupnost
izvan ovog fajla

15
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje createContext()
Ovaj kod se obično postavlja u poseban fajl za context kod, koji je često
smešten u folder pod nazivom store ili context
Ovo je prvi od tri koraka da bi koristili context u aplikaciji
Sledeći korak je obezbeđivanje context-a.

16
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Obezbeđivanje i upravljanje context vrednostima
Da biste koristili context vrednosti u drugim komponentama, prvo
morate obezbediti tu vrednost. To se radi korišćenjem vrednosti
vraćene od createContext().
Ta funkcija vraća objekat koji sadrži ugnježđeno Provider svojstvo.
To svojstvo sadrži React komponentu koja treba da obuhvati sve ostale
komponente koje trebaju pristup context vrednosti.
Provider komponenta očekuje value prop, koji bi trebao da sadrži
trenutnu context vrednost koja treba da se distribuira zainteresovanim
komponentama.

17
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Obezbeđivanje i upravljanje context vrednostima
import Articles from '../Articles/Articles';
import InfoSidebar from '../InfoSidebar/InfoSidebar';

import BookmarkContext from '../../store/bookmark-context';
function News() {
const bookmarkCtxValue = {
bookmarkedArticles: []
}; // za sada, ista vrednost kao što je korišćena ranije za početni context
return (
<BookmarkContext.Provider value={bookmarkCtxValue}>

<Articles />
<InfoSidebar />
</BookmarkContext.Provider>
);

}

18
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Obezbeđivanje i upravljanje context vrednostima
Ovim kodom, objekat sa listom označenih članaka se distribuira
zainteresovanim naslednim komponentama.
Lista je i dalje statična, ali to se može promeniti pomoću alata koji već
poznajete: useState() Hook. Unutar News komponente, možete
koristiti useState() Hook za upravljanje listom označenih članaka, na
sledeći način:

19
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

import { useState } from 'react';

import Articles from '../Articles/Articles';
import InfoSidebar from '../InfoSidebar/InfoSidebar';
import BookmarkContext from '../../store/bookmark-context';
function News() {
const [savedArticles, setSavedArticles] = useState([]);
const bookmarkCtxValue = {
bookmarkedArticles: savedArticles // sada koristimo stanje kao vrednost!
};
return (
<BookmarkContext.Provider value={bookmarkCtxValue}>
<Articles />
<InfoSidebar />
</BookmarkContext.Provider>
);
}
20
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Obezbeđivanje i upravljanje context vrednostima
Sa ovom promenom, context prelazi iz statičkog u dinamički.
Kad god se promeni savedArticles stanje, menja se i vrednost context-a.
Stoga, ovo je nedostajući deo kada je u pitanju obezbeđivanje context-a.
Ako context treba da bude dinamičan vrednost context-a treba takođe da
uključuje pokazivač na funkciju koja pokreće ažuriranje stanja.

21
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

function News() {
const [savedArticles, setSavedArticles] = useState([]);
function addArticle(article) {
setSavedArticles((prevSavedArticles) => [...prevSavedArticles, article]);
}
function removeArticle(articleId) {
setSavedArticles((prevSavedArticles) =>
prevSavedArticles.filter((article) => article.id !== articleId)
);
}
const bookmarkCtxValue = {
bookmarkedArticles: savedArticles,
bookmarkArticle: addArticle,
unbookmarkArticle: removeArticle
};
return (
<BookmarkContext.Provider value={bookmarkCtxValue}>
<Articles />
<InfoSidebar />
</BookmarkContext.Provider>
);
}

22
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Svojstva koja ukazuju na ove funkcije dodata su bookmarkCtxValue: bookmarkArticle i
unbookmarkArticle. Funkcija addArticle dodaje novi članak (koji treba da se označi)
u stanje savedArticles.
Korišćena je funkcionalna forma ažuriranja vrednosti stanja, jer nova vrednost stanja
zavisi od prethodne vrednosti stanja
Funkcija removeArticle uklanja članak sa liste savedArticles filtriranjem postojeće
liste, zadržavajući sve stavke osim one koja ima odgovarajući id.
Bilo koje komponente ugnježdene unutar Articles ili InfoSidebar komponenti (ili
njihovih naslednih komponenti) moći će da pristupe ovoj dinamičkoj context
vrednosti, kao i bookmarkArticle i unbookmarkArticle metodama u context objektu,
bez potrebe za "prop drilling"-om.

23
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

import { useContext } from 'react';
import BookmarkContext from '../../store/bookmark-context';
import classes from './BookmarkSummary.module.css';

function BookmarkSummary() {
const bookmarkCtx = useContext(BookmarkContext);
const numberOfArticles =
bookmarkCtx.bookmarkedArticles.length;

}

return (
<>
<p className={classes.summary}>{numberOfArticles}
articles bookmarked</p>
<ul className={classes.list}>
{bookmarkCtx.bookmarkedArticles.map((article) => (
<li key={article.id}>{article.title}</li>
))}
</ul>
</>
);

export default BookmarkSummary;
24
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje context-a u ugnježdenim komponentama
Da bi context vrednost bila dostupna komponentama ugnježdenim unutar
context-ove Provider komponente (u prethodnom primeru,
BookmarkContext.Provider), React nudi useContext() Hook koji se može
koristiti.
useContext() zahteva jedan argument: context objekat koji je kreiran pomoću
createContext(), tj. vrednost vraćena tom funkcijom. useContext() zatim vraća
vrednost prosleđenu Provider komponenti (putem njenog value prop-a).
useContext() prima BookmarkContext vrednost, koja je importovana iz
store/bookmark-context.js fajla. Zatim vraća vrednost koja je sačuvana u
context-u, što je bookmarkCtxValue iz prethodnog primera.
Kao što možete videti u tom isečku koda, bookmarkCtxValue je objekat sa tri
svojstva: bookmarkedArticles, bookmarkArticle (metod) i unbookmarkArticle
(takođe metod).

25
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje context-a u ugnježdenim komponentama
Kad god se context vrednost promeni (zbog izvršavanja funkcije za ažuriranje
stanja setSavedArticles u News komponenti), React će ponovo izvršiti
BookmarkSummary komponentu, i tako će bookmarkCtx sadržati najnoviju
vrednost stanja.
Na kraju, u BookmarkSummary komponenti, svojstvo bookmarkedArticles se
pristupa na bookmarkCtx objektu. Ova lista članaka se zatim koristi za
izračunavanje broja označenih članaka, prikazivanje kratkog rezimea i prikaz
liste na ekranu.

26
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izmeštanje Context logike u posebne komponente
News komponenta je korišćena za obezbeđivanje context-a i upravljanje njegovom
(dinamičkom, na stanju zasnovanom) vrednošću.

Komponente mogu postati nepotrebno složene ako moraju da se bave upravljanjem
context-om.
Kreiranje posebne, namenski komponente za to može dovesti do koda koji je lakši za
razumevanje i održavanje.
unutar store/bookmark-context.js fajla, možete kreirati BookmarkContextProvider
komponentu koja izgleda kao na sledećem slajdu
Ona kreira istu context vrednost kao i ranije. BookmarkContextProvider komponenta radi
jednu dodatnu stvar. Koristi poseban children prop kako bi obuhvatila sve što je
prosleđeno između BookmarkContextProvider oznaka komponenti sa
BookmarkContext.Provider.

27
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

export function BookmarkContextProvider({ children }) {
const [savedArticles, setSavedArticles] = useState([]);
function addArticle(article) {
setSavedArticles((prevSavedArticles) => [...prevSavedArticles,
article]);
}
function removeArticle(articleId) {
setSavedArticles((prevSavedArticles) =>
prevSavedArticles.filter((article) => article.id !== articleId)
);
}
const bookmarkCtxValue = {
bookmarkedArticles: savedArticles,
bookmarkArticle: addArticle,
unbookmarkArticle: removeArticle,
};
return (
<BookmarkContext.Provider value={bookmarkCtxValue}>
{children}
</BookmarkContext.Provider>
);
}

28
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izmeštanje Context logike u posebne komponente
Ovo omogućava korišćenje BookmarkContextProvider komponente u News
komponenti na sledeći način:
import { BookmarkContextProvider } from
'../../store/bookmark-context';
function News() {
return (
<BookmarkContextProvider>
<Articles />
<InfoSidebar />
</BookmarkContextProvider>
);
}
export default News
Ovo olakšava razdvajanje logike upravljanja context-om od same strukture
komponente, što dovodi do boljeg organizovanog i održivog koda.
29
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kombinovanje više Context-a
U većim i funkcionalno bogatijim React aplikacijama, vrlo je moguće (i
verovatno) da ćete morati raditi sa više context vrednosti

Možete kreirati, upravljati, obezbediti i koristiti onoliko context vrednosti koliko
je potrebno.
Možete obezbediti više context-a u istoj komponenti ili u različitim
komponentama.

30
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useReducer() Hook u Reactu

31
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useReducer Hook
useReducer je React hook koji se koristi za upravljanje
složenijim stanjima u komponentama. To je alternativa za
useState kada aplikacija zahteva složeniju logiku ažuriranja
stanja, često sa više akcija ili međuzavisnih promena stanja.
useReducer se zasniva na reducer funkciji, koja određuje
kako će se stanje promeniti na osnovu određene akcije.
Reducer funkcija prima dva argumenta:
• trenutno stanje (current state)
• akciju (action) koja opisuje šta treba da se promeni

32
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useReducer Hook
const [state, dispatch] = useReducer(reducer, initialState);

reducer: Funkcija koja definiše kako se stanje menja.
initialState: Početno stanje.
state: Trenutno stanje.
dispatch: Funkcija koja pokreće akcije.
Kada koristiti useReducer?

• Kada imate kompleksno stanje koje zavisi od različitih akcija.
• Kada želite da razdvojite logiku za ažuriranje stanja od same komponente.
• Kada je teško pratiti promene stanja koristeći samo useState.

33
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer useReducer 1/2
import React, { useReducer } from 'react';
const initialState = { count: 0 };
function reducer(state, action) {
switch (action.type) {
case 'increment':
return { count: state.count + 1 };
case 'decrement':
return { count: state.count - 1 };
case 'reset':
return { count: 0 };
default:
throw new Error('Unknown action type');
}
}

34
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer useReducer 2/2
function Counter() {
const [state, dispatch] = useReducer(reducer, initialState);

return (
<div>
<p>Count: {state.count}</p>
<button onClick={() => dispatch({ type: 'increment' })}>
Increment </button>
<button onClick={() => dispatch({ type: 'decrement' })}>
Decrement </button>
<button onClick={() => dispatch({ type: 'reset' })}> Reset
</button>
</div>
);
}
export default Counter;

35
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useReducer detaljnije
U kontekstu useReducer() Hook-a, funkcija reduktora je funkcija koja prima dva
parametra: Trenutnu vrednost stanja Akciju koja je pokrenuta (dispatched)

Pored primanja argumenata, funkcija reduktora mora vratiti vrednost: novo
stanje.
Naziva se funkcija reduktora jer "smanjuje" staro stanje (u kombinaciji sa
akcijom) na novo stanje. Na sledećem slajdu je još jedan primer kako se
useReducer() koristi zajedno sa funkcijom reduktora.

36
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

const initialHttpState = {
data: null,
isLoading: false,
error: null,
};
function httpReducer(state, action) {
if (action.type === 'FETCH_START') {
return {
...state, // kopiranje postojećeg stanja
isLoading: state.data ? false : true,
error: null,
};
}
if (action.type === 'FETCH_ERROR') {
return {
data: null,
isLoading: false,
error: action.payload,
};
}
if (action.type === 'FETCH_SUCCESS') {
return {
data: action.payload,
isLoading: false,
error: null,
};
}
return initialHttpState; // podrazumevana vrednost za nepoznate
akcije
}
function App() {
useReducer(httpReducer, initialHttpState);
// ostatak koda komponente, koji nije relevantan 37za ovaj isečak
}
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Objašnjenje primera 1/2
Kao što možete videti na dnu ovog isečka, useReducer() se poziva unutar
funkcije komponente App
Kao i svi React Hook-ovi, mora se pozivati unutar funkcija komponente ili
drugih Hook-ova.
Takođe možete videti dva pomenuta argumenta (funkciju reduktora i
početnu vrednost stanja) koji se prosleđuju useReducer().
httpReducer je funkcija reduktora. Ova funkcija prima dva argumenta
(state, koje je staro stanje, i action, koja je pokrenuta akcija) i vraća
različite objekte stanja za različite tipove akcija.
Funkcija reduktora se brine o svim mogućim ažuriranjima stanja.
Cela logika ažuriranja stanja je stoga premeštena iz komponente

38
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Opjašnjenje primera 2/2
const [httpState, dispatch] = useReducer(httpReducer, initialHttpState);
Prvi element u vraćenom nizu (httpState, u ovom slučaju) je vrednost stanja koju
vraća funkcija reduktora.
Ažurira se kad god se funkcija reduktora ponovo izvrši.
Element se naziva httpState u ovom primeru jer sadrži vrednost stanja koja se
odnosi na HTTP zahtev u ovom slučaju.
Drugi element (dispatch, u primeru) je funkcija. To je funkcija koja se može
pozvati za pokretanje ažuriranja stanja (tj. za ponovno izvršenje funkcije
reduktora).
Kada se izvrši, funkcija dispatch mora primiti jedan argument a to je vrednost
akcije koja će biti dostupna unutar funkcije reduktora.
dispatch({ type: 'FETCH_START' });

39
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Payload
U kontekstu React-a, payload je termin koji se često koristi u vezi sa akcijama u
useReducer ili Redux-u. Označava dodatne podatke koji se prenose zajedno s
akcijom kako bi se izvršila određena logika promene stanja.
Payload je korisni sadržaj akcije koji pruža informacije potrebne za ažuriranje
stanja.
To je ključ unutar objekta akcije koji obično sadrži vrednosti ili informacije koje
reducer koristi da odluči kako da ažurira stanje.
Akcija je obično objekat koji ima najmanje dva ključna elementa:
type: Opisuje tip akcije (npr. 'increment', 'add_item’).
payload: Sadrži podatke potrebne za izvršenje te akcije.

40
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

{ type: 'add_item', payload: { id: 1, name: 'Apple', price: 100 } } // objekat koji prosleđujemo
const initialState = {
cart: []
};

// Reducer funkcija
function reducer(state, action) {
switch (action.type) {
case 'add_item':
return {
...state,
cart: [...state.cart, action.payload] // Dodajemo novi
predmet u korpu
};
case 'remove_item':
return {
...state,
cart: state.cart.filter(item => item.id !==
action.payload.id) // Uklanjamo predmet po ID-u
};
default:
throw new Error('Unknown action type');
}
41
}
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

function ShoppingCart() {
const [state, dispatch] = useReducer(reducer, initialState);
const addItemToCart = () => {
const newItem = { id: 1, name: 'Apple', price: 100 };
dispatch({ type: 'add_item', payload: newItem });
};
const removeItemFromCart = () => {
dispatch({ type: 'remove_item', payload: { id: 1 } });
};

}

return (
<div>
<h2>Shopping Cart</h2>
<button onClick={addItemToCart}>Add Apple</button>
<button onClick={removeItemFromCart}>Remove Apple</button>
<ul>
{state.cart.map(item => (
<li key={item.id}>{item.name} - ${item.price}</li>
))}
</ul>
</div>
);

export default ShoppingCart;

42
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Objašnjenje
Akcija add_item:
payload sadrži objekat novog predmeta ({ id: 1, name: 'Apple', price: 100 }).
Reducer dodaje taj predmet u niz cart.
Akcija remove_item:
payload sadrži ID predmeta koji treba ukloniti ({ id: 1 }).
Reducer filtrira niz cart kako bi iz njega uklonio predmet sa datim ID-jem.
dispatch:Poziva se sa objektom akcije, npr. { type: 'add_item', payload: newItem }
Zašto je payload koristan?
Omogućava slanje dodatnih podataka uz akcije.
Čini reducer funkciju fleksibilnijom i ponovo upotrebljivom.
Pomaže u rukovanju kompleksnijim stanjima bez potrebe za dodatnim funkcijama ili
logikom.
Payload je ključan za dinamične aplikacije, jer omogućava razmenu podataka između
komponenti i reducera na strukturiran i predvidiv način.
43
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useReducer i context
Kombinovanje useReducer sa useContext je odličan način za centralizovano
upravljanje stanjem u React aplikaciji. Ovo je često korisno za složenije
aplikacije gde je potrebno upravljati više stanja na strukturalno jednostavan
način.

44
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useReducer i context
import React, { createContext, useReducer } from 'react';
// Kreiraj Context
const CounterContext = createContext();
// Definiši reducer funkciju
const counterReducer = (state, action) => {
switch (action.type) {
case 'increment':
return { count: state.count + 1 };
case 'decrement':
return { count: state.count - 1 };
case 'reset':
return { count: 0 };
default:
throw new Error(`Unknown action type: ${action.type}`);
}
};
45
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useReducer i context
const CounterProvider = ({ children }) => {
const [state, dispatch] = useReducer(counterReducer, { count: 0 });
return (
<CounterContext.Provider value={{ state, dispatch }}>
{children}
</CounterContext.Provider>
);
};
export { CounterProvider, CounterContext };

46
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

import React, { useContext } from 'react';
import { CounterContext } from './CounterContext';
const CounterDisplay = () => {
const { state } = useContext(CounterContext);
return <h1>Current Count: {state.count}</h1>;

};
const CounterButtons = () => {
const { dispatch } = useContext(CounterContext);
return (
<div>
<button onClick={() => dispatch({ type: 'increment'
})}>Increment</button>
<button onClick={() => dispatch({ type: 'decrement'
})}>Decrement</button>
<button onClick={() => dispatch({ type: 'reset'
})}>Reset</button>
</div>
);
};
47
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje u aplikaciji
import React from 'react';
import { CounterProvider } from './CounterContext';
import CounterDisplay from './CounterDisplay';
import CounterButtons from './CounterButtons';
const App = () => {
return (
<CounterProvider>
<CounterDisplay />
<CounterButtons />
</CounterProvider>
);
};
export default App;

48
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kako ovo funkcioniše?
Reducer: Upravljanje stanjem (state) se obavlja putem useReducer.
Context: Koristi se za deljenje stanja i dispatch funkcije između
komponenti.
Provider: Omogućava globalno dostupno stanje i dispatch.
Komponente: Kroz useContext, komponente mogu da pristupe
trenutnom stanju i da šalju akcije putem dispatch.

49
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Prednosti ove kombinacije
Centralizovano upravljanje stanjem: Smanjuje potrebu za "props
drilling"-om.
Čist kod: Reducer funkcija razdvaja logiku od komponenata.
Lako proširivo: Dodavanje novih akcija ili stanja je jednostavno

50
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Šta ako je aplikacija baš kompleksna?
Specijalizovane biblioteke za upravljanje globalnim stanjem:

• Redux
• Recoil
• MobX
• Zustand
• Jotai
• Itd…

51
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba

52
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba
Primeri iz lekcije

53
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korisnički definisani Hookovi u React-u
Oznaka predmeta: IT354
Naziv predmeta: Veb sistemi 1
Predavanje:
#11
Predavači:
Doc. dr Mladen Opačić - Beograd
Msc. Nikola Dimitrijević - Niš
Školska godina:
2024/2025. jesenji semestar

Kreiranje sopstvenih hook-ova

2
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Podsetnik: Šta su Hookovi?
Hookovi su ugrađene funkcije u React-u koje omogućavaju korišćenje
stanja i drugih React funkcionalnosti u funkcionalnim komponentama.
Do sada smo se upoznali za mnogim hookovima:
useState – za rad sa stanjem.
useEffect – za rad sa sporednim efektima.
useRef – za rad sa referencama.
useContext – za pristup kontekstu.

3
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Podsetnik: Korišćenje ugrađenih Hook-ova
import React, { useState, useEffect } from 'react';
function Counter() {
const [count, setCount] = useState(0);
useEffect(() => {
console.log(`Count value: ${count}`);
}, [count]);

}

return (
<div>
<p>Count: {count}</p>
<button onClick={() =>
setCount(prevCount => prevCount + 1)}>Increase</button>
</div>
);

4
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Razlozi za sopstvene hookove?
Hook-ovi pokreću skoro sve osnovne funkcionalnosti i koncepte koje
React nudi
Od upravljanja stanjem unutar jedne komponente do pristupa stanju
koje se deli među više komponenti (context).
Omogućavaju vam pristup JSX elementima putem referenci (refs) i
omogućavaju upravljanje neželjenim efektima unutar funkcija
komponenata (useRef i useEffect).
Do sada smo upoznali i koristili samo ugrađene hook-ove.
Međutim, možemo napraviti i sopstvene hook-ove.
U ovoj lekciji ćemo naučiti kako i zašto se to radi.

5
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Potreba za Custom Hookovima
Kada koristimo isti kod u više komponenti, dolazi do ponavljanja logike.
To čini kod:
• Težim za održavanje.
• Sklonim greškama.
Korisnički definisani Hookovi rešavaju ovaj problem tako što
omogućavaju izdvajanje i ponovnu upotrebu logike.
Najčešći elementi logike koji se stalno ponavaljaju:
Rad sa API pozivima.
Upravljanje lokalnim skladištem.

6
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Šta su tačno korisnički definisani hook-ovi?

7
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Definicija Custom Hookova
Custom Hookovi su JavaScript funkcije koje:
Uvek počinju prefiksom use (npr. useFetch).
Koriste postojeće React hookove kao što su useState i useEffect.
Omogućavaju enkapsulaciju logike specifične za aplikaciju.
React prepoznaje custom hookove po njihovom prefiksu i obezbeđuje
njihovu ispravnu upotrebu u funkcionalnim komponentama.
Vraćaju nešto što nije samo JSX

8
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Definicija Custom Hookova detaljnije
U React aplikacijama, prilagođeni hook-ovi su obične JavaScript funkcije
koje zadovoljavaju sledeće uslove:
Naziv funkcije počinje sa "use" (kao što svi ugrađeni hook-ovi počinju sa
"use": useState(), useReducer(), itd.).
Funkcija ne vraća samo JSX kod (inače bi u suštini bila React komponenta
sa neobičnim imenom funkcije), iako može vratiti neki JSX kod, pod
uslovom da to nije jedina vrednost koja se vraća.
Ako funkcija ispunjava ova dva uslova, može da se naziva custom
(prilagođenim) hook-om.

9
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje
Prilagođeni hook-ovi su posebni zato što možete pozvati druge ugrađene
i prilagođene React hook-ove unutar njihovih tela funkcija.
React hook-ovi (bilo ugrađeni ili prilagođeni) mogu se pozivati samo
unutar funkcija komponenti.
Ako pokušate da pozovete hook na nekom drugom mestu dobićete
grešku.
React hook-ovi, bilo da su prilagođeni ili ugrađeni, moraju se pozivati
isključivo unutar funkcija komponenti.
Ugrađeni hook-ovi se mogu pozivati unutar prilagođenih hook-ova. Ova
funkcionalnost je izuzetno važna, jer znači da možete izgraditi ponovo
upotrebljive funkcije koje nisu komponente.

10
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kada koristiti Custom Hookove?
Kada imate ponovljivu logiku u različitim komponentama.
Kada želite da:
• Razdvojite poslovnu logiku od prikazne logike.
• Smanjite duplikaciju koda.
• Povećate čitljivost i lakoću održavanja aplikacije.
Primeri:
• Rad sa podacima iz API-ja.
• Upravljanje stanjem u lokalnom skladištu.
• Praćenje veličine prozora ili pozicije skrolovanja.

11
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Razlika između custom hookova i komponenti
• mogu sadržati logiku stanja (preko useState() ili useReducer()).
• upravljati sporednim efektima unutar vaših prilagođenih hook
funkcija (preko useEffect()).
• mogu koristiti bilo koji drugi React hook.
Dok su React komponente ponovo upotrebljivi UI blokovi su prilagođeni
hook-ovi su ponovo upotrebljivi delovi logike koji mogu biti korišćeni u
funkcijama komponenti.

12
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje custom hook-ova u aplikaciji

13
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Struktura Custom Hooka
Custom (prilagođeni) hook je JavaScript funkcija koja koristi React
hookove za enkapsulaciju logike.
Prefiks use u nazivu.
Korišćenje drugih React hookova (useState, useEffect, itd.).
Može da prihvata argumente i vraća vrednosti.
function useCounter(initialValue = 0) {
const [count, setCount] = useState(initialValue);
const increment = () => setCount(prev => prev + 1);
const decrement = () => setCount(prev => prev - 1);
}

return { count, increment, decrement };

14
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer counter
useCounter je obična JavaScript funkcija.
Naziv funkcije počinje sa "use", i React zbog toga tretira ovu funkciju kao
prilagođeni hook
Unutar useCounter() funkcije, stanje counter se upravlja preko
useState().
Stanje se menja preko dve ugnježdene funkcije (increment i decrement),
a stanje, kao i funkcije, vraćaju se iz useCounter funkcije (grupisane
zajedno u JavaScript objektu).
Ovaj prilagođeni hook može biti smešten u zaseban fajl (npr. u folder
hooks unutar React projekta, kao što je src/hooks/useCounter.js).

15
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje Custom Hookova
Custom hookovi se koriste unutar funkcionalnih komponenti.
Potrebno je importovati hook pa ga zatim pozvati unutar komponente.
function Counter() {
const { count, increment, decrement } = useCounter(10);

}

return (
<div>
<p>Count: {count}</p>
<button onClick={increment}>+</button>
<button onClick={decrement}>-</button>
</div>
);

16
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: usePair
Recimo da imamo jedan par vrednosti koje čuvamo u dva različita
useState stanja
first – prva vrednost
second – druga vrednost
usePair će izgledati ko na sledećem slajdu

17
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: usePair

import { useState } from "react";
function usePair(initialFirstValue, initialSecondValue) {
const [first, setFirst] = useState(initialFirstValue);
const [second, setSecond] = useState(initialSecondValue);
}

return [first, second, setFirst, setSecond];

export default usePair;

18
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer usePair

import React from "react";
import usePair from "../hooks/usePair";
function PairComponent() {
// Pozivamo usePair prvi put
const [first1, second1, setFirst1, setSecond1] = usePair(0, "A");
// Pozivamo usePair drugi put
const [first2, second2, setFirst2, setSecond2] = usePair(100, "B");

19
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: usePair
Na prethodnom slajdu vidimo dva nezavisna poziva usePair Hook-a
Prvi poziv usePair:
initialFirstValue = 0
initialSecondValue = "A„
Ovo kreira stanje za prvi par: first1 i second1.
Drugi poziv usePair:
initialFirstValue = 100
initialSecondValue = "B„
Ovo kreira stanje za drugi par: first2 i second2.
Svaki poziv usePair hooka ima svoja zasebna stanja!
20
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

return (
<div>
<h1>Demonstracija Custom Hook-a</h1>

{/* Prvi par stanja */}
<div>
<h2>Prvi par stanja</h2>
<p>First: {first1}</p>
<p>Second: {second1}</p>
<button onClick=
{() => setFirst1((prev) => prev + 1)}>Increment First</button>
<button onClick=
{() => setSecond1((prev) => prev + "X")}>Update Second</button>
</div>

}

{/* Drugi par stanja */}
<div>
<h2>Drugi par stanja</h2>
<p>First: {first2}</p>
<p>Second: {second2}</p>
<button onClick={
() => setFirst2((prev) => prev + 10)}>Increment First</button>
<button onClick=
{() => setSecond2((prev) => prev + "Y")}>Update Second</button>
</div>
</div>
);
21
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

export default PairComponent;

22
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: usePair objašnjenje
Kada se pokrene ovaj kod:
Klikom na dugmiće za prvi par (Increment First i Update Second),
vrednosti first1 i second1 će se promeniti.
Klikom na dugmiće za drugi par (Increment First i Update Second),
vrednosti first2 i second2 će se promeniti.
Stanja prvog i drugog para će ostati nezavisna jedno od drugog!

23
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer useLocalStorage
Custom hook useLocalStorage jedan je od najkorisnijih i veoma često se
koristi, jer komponente veoma često žele da pristupe nečemu što je
zapisano u LocalStorage browsera kao na primer podaci o tome da li je
tema svetla ili tamna i sl.

24
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Local Storage
Local Storage je mehanizam u modernim browserima koji omogućava skladištenje
podataka na strani klijenta u obliku ključeva i vrednosti. Ovo je deo Web Storage
API-ja, koji takođe uključuje i Session Storage. Local Storage ima sledeće
karakteristike:
Osnovne karakteristike Local Storage-a:
Kapacitet:
Većina browsera omogućava skladištenje do 5–10 MB podataka po domenu.
Persistencija podataka:
Podaci u Local Storage-u ostaju sačuvani i nakon zatvaranja browsera, pa čak i nakon
ponovnog pokretanja računara.Ovi podaci se čuvaju sve dok ih korisnik ili aplikacija
ne obrišu ručno.
Oblast dostupnosti:
Local Storage je specifičan za određeni domen. To znači da podaci sačuvani na
jednom domenu nisu dostupni na drugom.
Pristup:
Local Storage je dostupan putem JavaScript-a i omogućava jednostavno čuvanje i
preuzimanje podataka pomoću metoda poput localStorage.setItem
i
25
localStorage.getItem.
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: useLocalStorage

function useLocalStorage(key, initialValue) {
const [storedValue, setStoredValue] = useState(() => {
try {
const item = window.localStorage.getItem(key);
return item ? JSON.parse(item) : initialValue;
} catch (error) {
console.error(error);
return initialValue;
}
});
const setValue = value => {
try {
setStoredValue(value);
window.localStorage.setItem(key, JSON.stringify(value));
} catch (error) {
console.error(error);
}
};
}

return [storedValue, setValue];

© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

26

Primer: useLocalStorage
import useLocalStorage from "../hooks/useLocalStorage";
function NameSaver() {
const [name, setName] = useLocalStorage('name', '');

}

return (
<div>
<input
type="text"
value={name}
onChange={e => setName(e.target.value)}
/>
<p>Your name is: {name}</p>
</div>
);

export default NameSaver

27
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: useFetch
function useFetch(url) {
const [httpState, dispatch] = useReducer(httpReducer,
initialHttpState);

const fetchPosts = useCallback(async function fetchPosts() {
dispatch({ type: 'FETCH_START' });
try {
const response = await fetch(url);
if (!response.ok) {
throw new Error('Neuspešno preuzimanje postova.');
}
const posts = await response.json();
dispatch({ type: 'FETCH_SUCCESS', payload: posts });
} catch (error) {
dispatch({ type: 'FETCH_ERROR', payload: error.message });
}
}, [url]);
useEffect(() => {
fetchPosts();
}, [fetchPosts]);
}

return httpState;

28
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: useFetch
Pošto je useCallback() obmotan oko funkcije za preuzimanje (da bi se
sprečile beskonačne petlje u useEffect()), sve spoljašnje vrednosti koje
se koriste unutar useCallback() moraju biti dodate u njegov niz
zavisnosti.
Pošto je url spoljašnja vrednost (što znači da nije definisana unutar
ugnježdene funkcije), mora biti dodata.
Ovo takođe ima smisla logički: ako se vrednost url promeni (tj. ako je
komponenta koja koristi useFetch promeni), treba poslati novi HTTP
zahtev.
Ova verzija useFetch hook-a sada može biti korišćena u svim
komponentama za slanje HTTP zahteva na različite URL adrese i
korišćenje vrednosti HTTP stanja prema potrebi u komponentama.

29
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: useFetch
Potrebno je prvo uključiti sve ugrađene hook-ove iz reacta
Zatim se postavlja početno stanje http objekta
import { useReducer, useEffect, useCallback } from "react";
const initialHttpState = {
data: null,
isLoading: false,
error: null,
};

U zavisnosti od dispečovane akcije reduktorska funkcija menja http
objekat kao na sledećem slajdu.

30
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: useFetch
function httpReducer(state, action) {
if (action.type === 'FETCH_START') {
return {
...state,
isLoading: state.data ? false : true,
error: null,
};
}
if (action.type === 'FETCH_ERROR') {
return {
data: null,
isLoading: false,
error: action.payload,
};
}
if (action.type === 'FETCH_SUCCESS') {
return {
data: action.payload,
isLoading: false,
error: null,
};
}
}

return initialHttpState;

31
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: useFetch
Hook useFetch se zatim koristi u komponenti FetchWithHook na sledeći način:
import BlogPosts from './BlogPosts';
import useFetch from '../hooks/useFetch';
function FetchWithHook() {
const { data, isLoading, error } =
useFetch('https://jsonplaceholder.typicode.com/post
s');
return (
<>

}

);

</>

<header>
<h1>Blog sa složenim stanjem</h1>
</header>
{isLoading && <p>Učitavanje...</p>}
{error && <p>{error}</p>}
{data && <BlogPosts posts={data} />}

export default FetchWithHook;

© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

32

Primer: useFetch

33
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba

34
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba
Primeri iz lekcije

35
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Rutiranje u React-u
Oznaka predmeta: IT354
Naziv predmeta: Veb sistemi 1
Predavanje:
#12
Predavači:
Doc. dr Mladen Opačić - Beograd
Msc. Nikola Dimitrijević - Niš
Školska godina:
2024/2025. jesenji semestar

Uvod u React Router

2
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Šta je React Router?
React Router je biblioteka za React koja omogućava navigaciju između različitih
delova aplikacije bez osvežavanja stranice tj. ponovnog učitavanja.

Koristi se u aplikacijama od jedne strane (SPA) za simulaciju tradicionalne
navigacije između stranica.
import { BrowserRouter, Routes, Route } from 'react-router-dom';
function App() {
return (
<BrowserRouter>
<Routes>
<Route path="/" element={<Home />} />
<Route path="/about" element={<About />} />
</Routes>
</BrowserRouter>
);
}

3
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Ubacivanje React Router-a u aplikaciju 1/2
Instalacija React Router-a:

npm install react-router-dom

4
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Ubacivanje React Router-a u aplikaciju 2/2
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Home from './components/Home';
import About from './components/About';
import Contact from './components/Contact';
function App() {
return (
<BrowserRouter>
<Routes>
<Route path="/" element={<Home />} />
<Route path="/about" element={<About />} />
<Route path="/contact" element={<Contact />} />
</Routes>
</BrowserRouter>
);
}
export default App;

5
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Komponenta <BrowserRouter>
<BrowserRouter> je omotač koji omogućava React Router-u da upravlja URLovima.
Mora obuhvatiti sve komponente koje koriste React Router funkcionalnosti.
Bez <BrowserRouter>, funkcionalnosti poput <Routes> i <Link> neće raditi.

6
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Komponente <Routes> i <Route>
<Routes> se koristi za definisanje svih ruta u aplikaciji.
Svaka pojedinačna ruta se definiše pomoću <Route>.
path atribut određuje URL putanju.
element atribut određuje komponentu koja se prikazuje na toj putanji.

<BrowserRouter>
<Routes>
<Route path="/" element={<Home />} />
<Route path="/about" element={<About />} />
</Routes>
</BrowserRouter>

7
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Izbegavanje ponovnog učitavanja stranice
React Router biblioteka pruža specijalnu komponentu Link koja se treba
koristiti za renderovanje linkova koji neće izazivati ponovno učitavanje
stranice.
import { Link } from 'react-router-dom';
function Navbar() {
return (
<nav>
<Link to="/">Početna</Link>
<Link to="/about">O nama</Link>
<Link to="/contact">Kontakt</Link>
</nav>
);
}
export default Navbar;
8
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Navigacija pomoću <Link> i <NavLink>
<Link> komponenta:
<Link> je zamena za HTML <a> tag.Ne osvežava stranicu, već omogućava
klijentsku navigaciju.
<NavLink> komponenta:
Slično <Link>, ali omogućava dodavanje klase kada je ruta aktivna.

9
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Komponenta za navigaciju
Uobičajeno je da se napravi komponenta za navigaciju u aplikaciji u vidu
navigacionog menija na vrhu ili sa strane.
import { Link } from 'react-router-dom';
import styles from '../App2.module.css';
function Navigation() {
return (
<nav className={styles.navigation}>
<Link to="/">Home</Link>
<Link to="/add">Kreiranje</Link>
<Link to="/update">Ažuriranje</Link>
<Link to="/delete">Brisanje</Link>
</nav>
);
}
export default Navigation;

10
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Komponenta za navigaciju
function App() {
return (
<UserProvider>
<BrowserRouter>
<div className={styles.container}>
<h1>IT354 User Management System</h1>
<Navigation />

}

<Routes>
<Route path="/" element={<Home />} />
<Route path="/add" element={<AddUser />} />
<Route path="/update" element={<UpdateUser />} />
<Route path="/delete" element={<DeleteUser />} />
</Routes>
</div>
</BrowserRouter>
</UserProvider>
);

11
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kreiranje Layout komponente
Može se kreirati zasebna Layout komponenta koja obavija ceo blok
definicija ruta (tj. oko Routes komponente)

import MainNavigation from './MainNavigation';
function Layout({ children }) {
return (
<>
<MainNavigation />
<main>{children}</main>
</>
);
}
export default Layout;

12
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Uključivanje Layout komponente
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Layout from './components/shared/Layout';
import Dashboard from './routes/Dashboard';
import Orders from './routes/Orders';
function App() {
return (
<BrowserRouter>
<Layout>
<Routes>
<Route path="/" element={<Dashboard />} />
<Route path="/orders" element={<Orders />} />
</Routes>
</Layout>
</BrowserRouter>
);
}
export default App;

13
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Dinamičke rute

14
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Šta su dinamičke rute?
Dinamičke rute omogućavaju kreiranje URL-ova koji sadrže promenljive
parametre, kao što su identifikatori (npr., :id).
Koriste se kada različite stranice prikazuju sličan sadržaj baziran na
vrednosti parametra.
Ruta /product/:id prikazuje detalje o proizvodu na osnovu njegovog
identifikatora (id).

15
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Parametri ruta (:id, :paramName)
Koriste se dvotačke (:) da bi se označila promenljiva u putanji.
<Route path="/product/:id" element={<ProductDetails />} />
Ako korisnik poseti /product/123, React Router prosleđuje vrednost 123
komponenti ProductDetails.

16
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pristup parametrima koristeći useParams
React Router pruža hook useParams za pristup parametrima definisanim u ruti.

import { useParams } from 'react-router-dom';
function ProductDetails() {
const { id } = useParams(); // Pristupamo parametru :id
return <h2>Detalji o proizvodu sa ID-jem: {id}</h2>;
}
Posetom URL-a /product/123, prikazuje se:
Detalji o proizvodu sa ID-jem: 123

17
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Dinamičko učitavanje podataka
Parametre često koristimo za učitavanje specifičnih podataka sa servera:

import { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';

function ProductDetails() {
const { id } = useParams();
const [product, setProduct] = useState(null);
useEffect(() => {
fetch(`https://api.example.com/products/${id}`)
.then((response) => response.json())
.then((data) => setProduct(data));
}, [id]);
if (!product) return <h2>Učitavanje...</h2>;
return <h2>{product.name}:
{product.description}</h2>;
}
18
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Višestruki parametri
Ruta može imati više parametara:

<Route path="/category/:categoryId/product/:productId"
element={<CategoryProduct />} />
Način pristupanja parametrima:

const { categoryId, productId } = useParams();

19
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Defaultne vrednosti
Moguće je postaviti defaultne vrednosti ako parametar nije obavezan:
<Route path="/product/:id?" element={<OptionalProduct />} />

20
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Kreiranje dinamičkih linkova
Ako imamo listu porudžbina (ili proizvoda u online prodavnici), stavke na listi
treba da budu klikabilne i vode do stranica sa detaljima.

Ovo se može postići dinamičkim generisanjem linkova na osnovu podataka:

function OrdersList() {
return (
<ul className={classes.list}>
{orders.map((order) => (
<li key={order.id}>
<Link to={`/orders/${order.id}`}>
<OrderItem order={order} />
</Link>
</li>
))}
</ul>
);
}
21
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Navigacija i redirekcije

22
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Programatska navigacija
Programatska navigacija omogućava da se korisnik preusmeri ka određenoj ruti
u specifičnim situacijama, kao što su uspešna prijava ili validacija forme.
function Login() {
const navigate = useNavigate();
const handleLogin = () => {
// Pretpostavimo uspešnu prijavu
navigate('/dashboard');
};

}

return (
<div>
<h2>Prijava</h2>
<button onClick={handleLogin}>Prijavi se</button>
</div>
);
export default Login;
23
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

useNavigate hook
useNavigate je hook koji omogućava programsku navigaciju unutar
React Router aplikacija.
Koristi se za prebacivanje između ruta na osnovu korisničkih interakcija
ili poslovne logike.
import { useNavigate } from 'react-router-dom';
function Home() {
const navigate = useNavigate();
const goToAbout = () => {
navigate('/about'); // Navigacija ka ruti "/about"
};

}

return (
<div>
<h2>Početna stranica</h2>
<button onClick={goToAbout}>Idi na stranicu "O nama"</button>
</div>
);

export default Home;
24
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Navigacija sa dodatnim podacima (state)
const navigate = useNavigate();
const goToProduct = () => {
navigate('/product/123', { state: { name: 'Proizvod 123' } });
};
import { useLocation } from 'react-router-dom';
function ProductDetails() {
const location = useLocation();
const productName = location.state?.name || 'Nepoznati proizvod';
}

return <h2>Detalji za: {productName}</h2>;

25
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Redirekcija u React Router-u
Redirekcije se koriste kada treba automatski preusmeriti korisnika sa
jedne rute na drugu.
Koristi se komponenta <Navigate>.
import { Navigate } from 'react-router-dom';
function RedirectToHome() {
return <Navigate to="/" />;
}

26
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Redirekcija na osnovu uslova
function ProtectedRoute({ isAuthenticated, children }) {
if (!isAuthenticated) {
return <Navigate to="/login" />;
}
}

return children;

export default ProtectedRoute;

<Route path="/dashboard" element={<ProtectedRoute
isAuthenticated={userLoggedIn}><Dashboard /></ProtectedRoute>} />

27
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Korišćenje Navigate komponente
Navigate komponenta omogućava deklarativnu redirekciju u JSX-u.
Redirekcija može biti trajna (replace) ili sačuvana u istoriji.
<Navigate to="/about" replace />

Ova redirekcija ne dodaje prethodnu rutu u istoriju pregledača, što znači
da korisnik ne može da se vrati nazad pritiskom na dugme za povratak.

28
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Ugnježđene, zaštićene i ostale rute

29
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Ugnježdene rute
Još jedna ključna funkcionalnost koju nudi React Router je podrška za
ugnježdene rute.
Ugnježdene rute omogućavaju definisanje hijerarhijske strukture ruta
gde jedna ruta može imati pod-rute.
Pod-rute nasleđuju osnovnu rutu i renderuju se unutar roditeljske
komponente.
Osnovna ruta: /dashboard
Ugnježdene rute: /dashboard/profile, /dashboard/settings

30
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer 1/2
import { Outlet } from 'react-router-dom';
export default function Dashboard() {
return (
<div>
<h2>Dashboard</h2>
<Outlet /> {/* Mesto gde će se renderovati ugnježdene rute */}
</div>
);
}
// Profile.js
export default function Profile() {
return <h3>Profil korisnika</h3>;
}
// Settings.js
export default function Settings() {
return <h3>Podešavanja</h3>;
}

31
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer 2/2
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Dashboard from './components/Dashboard';
import Profile from './components/Profile';
import Settings from './components/Settings';
function App() {
return (
<BrowserRouter>
<Routes>
<Route path="/dashboard" element={<Dashboard />}>
<Route path="profile" element={<Profile />} />
<Route path="settings" element={<Settings />} />
</Route>
</Routes>
</BrowserRouter>
);
}
export default App;
32
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Outlet
Outlet je posebna komponenta koju pruža React Router. Nakon što se
importuje iz react-router-dom, može se koristiti da se označi mesto
gde bi trebalo da se renderuju child rute.
Komponenta Outlet je mesto u roditeljskoj komponenti gde se renderuju
ugnježdene rute.
Omogućava dinamičko prikazivanje sadržaja na osnovu trenutne podrute.

33
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Nedefinisane rute
Šta ako posetilac unese URL koji jednostavno nije podržan?
Da bismo prikazali stranicu "Not Found", možemo definisati rutu koja
hvata sve ostale putanje pomoću posebne putanje *:
<Route path="*" element={<NotFound />} />
Dodavanjem ove rute u listu definicija ruta u App komponenti, NotFound
komponenta će se prikazati na ekranu kada nijedna druga ruta ne
odgovara unetom ili generisanom URL-u.

34
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Zaštićene Rute
Zaštićene rute su rute koje zahtevaju određene uslove za pristup, poput
autentifikacije ili određenih korisničkih dozvola.
Ako korisnik ne ispunjava uslove, preusmerava se na određenu rutu,
npr., stranicu za prijavu.

35
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Implementacija zaštite ruta
Koraci za implementaciju zaštićene rute:
• Kreirajnje komponente ProtectedRoute koja proverava uslove za
pristup.
• Korišćenje komponente Navigate za preusmeravanje.
• Implementiranje logike autentifikacije.

36
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Komponenta ProtectedRoute

export default App;
import { Navigate } from 'react-router-dom';
function ProtectedRoute({ isAuthenticated, children }) {
if (!isAuthenticated) {
return <Navigate to="/login" replace />;
}
return children;
}
export default ProtectedRoute;

37
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Forma za logovanje
function Login({ onLogin }) {
const [username, setUsername] = useState('');
const navigate = useNavigate();
const handleLogin = () => {
onLogin(username); // Poziva funkciju za prijavu
navigate('/dashboard'); // Preusmerava na dashboard
};
return (
<div>
<h2>Prijava</h2>
<input
type="text"
placeholder="Korisničko ime"
value={username}
onChange={(e) => setUsername(e.target.value)}
/>
<button onClick={handleLogin}>Prijavi se</button>
</div>
);
}
export default Login;

38
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

function App() {
const [isAuthenticated, setIsAuthenticated] = useState(false);
const handleLogin = (username) => {
// Logika prijave (čuva korisnika u lokalnom stanju)
setIsAuthenticated(true);
console.log(`Korisnik ${username} je prijavljen.`);
};
return (
<BrowserRouter>
<Routes>
<Route path="/login" element={<Login onLogin={handleLogin}
/>} />
<Route
path="/dashboard"
element={
<ProtectedRoute isAuthenticated={isAuthenticated}>
<Dashboard />
</ProtectedRoute>
}
/>
</Routes>
</BrowserRouter>
);
}
39

export default App;

© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Lazy loading
Lazy loading (lenjo učitavanje) je tehnika koja može poboljšati
performanse React aplikacija tako što se određeni delovi koda
aplikacije učitavaju samo kada su potrebni
Kada aplikacije imaju više ruta, moguće je da neke rute nikada neće biti
posećene od strane korisnika.
Čak i ako sve rute budu posećene, nije potrebno da se sav kod za sve
rute učita odmah na početku aplikacije.
Umesto toga, ima smisla učitati kod za pojedinačne rute tek kada one
postanu aktivne.

40
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: Lazy loading
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Layout from './components/shared/Layout';
import Dashboard from './routes/Dashboard';
const OrdersRoot = lazy(() => import('./routes/OrdersRoot'));
const Orders = lazy(() => import('./routes/Orders'));
const OrderDetail = lazy(() => import('./routes/OrderDetail'));
function App() {
return (
<BrowserRouter>
<Layout>
<Suspense fallback={<p>Loading...</p>}>
<Routes>
<Route path="/" element={<Dashboard />} />
<Route path="/orders" element={<OrdersRoot />}>
<Route element={<Orders />} index />
<Route path=":id" element={<OrderDetail />} />
</Route>
</Routes>
</Suspense>
</Layout>
</BrowserRouter>
);
}
41

export default App;

© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Primer: Lazy loading detaljno
U ovom kodu, lazy i Suspense su importovani iz React-a. Komponente
OrdersRoot, Orders, i OrderDetail više se ne importuju direktno
Umesto toga kreiraju pomoću lazy() funkcije, koja koristi dinamičku
import() funkciju da dinamički učita kod komponente kada je to
potrebno.
Definicije ruta su obavijene Suspense komponentom, tako da React
može prikazati neki fallback sadržaj (<p>Loading...</p> u ovom slučaju)
ako učitavanje koda traje malo duže.
Lazy loading može značajno poboljšati performanse React aplikacije,
posebno kada postoje rute koje nisu odmah potrebne
Ne treba koristiti lazy loading za sve rute, posebno ne za one koje će biti
učitane odmah, kao što je Dashboard komponenta, koja je
podrazumevana ruta.

42
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba

43
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

Pokazna vežba
Primeri iz lekcije

44
© UNIVERZITET METROPOLITAN, Beograd / Kopiranje i umnožavanje nije dozvoljeno.

